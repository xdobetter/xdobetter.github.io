<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【剑指offer】46. 把数字翻译成字符串</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9146-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9146-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h5 id="第一步：定义数组元素的含义"><a href="#第一步：定义数组元素的含义" class="headerlink" title="第一步：定义数组元素的含义"></a>第一步：定义数组元素的含义</h5><p>题目要求的是一个数字有多少种不同的翻译方法，因此设<code>dp[i]</code>代表第i个结尾的数字的翻译方案数量</p><h5 id="第二步：找出关系数组元素间的关系式"><a href="#第二步：找出关系数组元素间的关系式" class="headerlink" title="第二步：找出关系数组元素间的关系式"></a>第二步：找出关系数组元素间的关系式</h5><p>若$x_{i}$和$x_{i-1}$组成的数字可以被翻译，<br>则<code>dp[i]=dp[i-1]+dp[i-2]</code>,$x_{i-1}x_{i}\epsilon [10,25]$;<br>否则<code>dp[i]=dp[i-1]</code>,$x_{i-1}x_{i}\epsilon [1,10)\cup\left ( 25,99 \right ]$</p><h5 id="第三步：初始状态"><a href="#第三步：初始状态" class="headerlink" title="第三步：初始状态"></a>第三步：初始状态</h5><p><code>dp[0]=dp[1]=1</code> ,即“无数字”和“第1位数字”的翻译方法数量均为1</p><h5 id="第四步：返回值"><a href="#第四步：返回值" class="headerlink" title="第四步：返回值"></a>第四步：返回值</h5><p><code>dp[n]</code>，即此数字的翻译方案数量</p><h4 id="代码1——字符串遍历"><a href="#代码1——字符串遍历" class="headerlink" title="代码1——字符串遍历"></a>代码1——字符串遍历</h4><p>利用迭代方式编写</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ans = <span class="hljs-built_in">std</span>::to_string(num);        <span class="hljs-keyword">if</span> (ans.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//特判</span>        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(ans.size() + <span class="hljs-number">1</span>)</span></span>;        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= ans.size(); i++) &#123;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> temp = ans.substr(i - <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);            <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-string">"10"</span> || temp&gt;<span class="hljs-string">"25"</span>) dp[i] = dp[i - <span class="hljs-number">1</span>];<span class="hljs-comment">//不可以翻译</span>            <span class="hljs-keyword">else</span> dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<span class="hljs-comment">//可以翻译</span>        &#125;        <span class="hljs-keyword">return</span> dp[ans.size()];    &#125;&#125;;</code></pre></div><h4 id="代码2——数字求余"><a href="#代码2——数字求余" class="headerlink" title="代码2——数字求余"></a>代码2——数字求余</h4><p>利用递归方式编写</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">return</span> f(num);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (num % <span class="hljs-number">100</span> &lt; <span class="hljs-number">10</span> || num % <span class="hljs-number">100</span> &gt; <span class="hljs-number">25</span>) &#123;            <span class="hljs-keyword">return</span> f(num / <span class="hljs-number">10</span>);<span class="hljs-comment">//不可以翻译</span>        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> f(num / <span class="hljs-number">10</span>) + f(num / <span class="hljs-number">100</span>);<span class="hljs-comment">//可以翻译</span>        &#125;    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】45. 把数组排成最小的数</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9145-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9145-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过题意可知，不管这些数字如何排列，形成的数字位数时不变的。所以如果高位的数字越小，则最终的结果也就越小。下面的<code>n</code>为数字的个数</p><ul><li>对于<code>n=2</code>的情况<br>如[26,38],根据高位越小越好，可知，我们应该排列成2638</li><li>对于<code>n&gt;2</code>的情况<br>如[26,29,1]，根据我们定义的规则，一定是将第一位小的数字放在最高位，因此先选出1，对于剩下两个数字，由于第1位数字相同，我们会比较第2位，因此我们最终会排列成12629<br>从上面我们可以发现的排序规则就是，如果第1位小，就将其排到最前面，如果第1位相等，则比较第2位，直到数字位数结束。 </li></ul><p>注意，这里的排列规则和字符串的排列规则有区别，比如，2和20，明显应该20排在2前面，结果才会更小(202&lt;220)，因此我们可以得到最终的排序规则应该是<br>如果<code>s1+s2&lt;s2+s1</code>，那么<code>s1&lt;s2</code><br>因此我们可以写一个<code>cmp</code>函数</p><div class="hljs"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; s1, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; s2)</span> </span>&#123;    <span class="hljs-keyword">return</span> s1 + s2 &lt; s2 + s1;&#125;</code></pre></div><p>下面代码分别给出了<code>cmp</code>函数写排序规则和<code>lambda</code>写排序规则两种形式</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>1.初始化字符串数组<code>strs</code>，存储结果的字符串<code>ans</code><br>2.遍历初始的整型数组<code>nums</code>，将其元素加入<code>strs</code><br>3.调用排序<br>4.遍历<code>strs</code>，将其元素相加即为最终结果</p><p>由于使用了快排，时间复杂度<code>O(nlogn)</code><br>空间负责度<code>O(n)</code></p><h4 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h4><h5 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; s1, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; s2)</span> </span>&#123; <span class="hljs-comment">//注意这里的cmp函数可以写作Solution外</span>    <span class="hljs-keyword">return</span> s1 + s2 &lt; s2 + s1;&#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-keyword">public</span>:     <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;         <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; strs;         <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ans;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums) &#123;             strs.push_back(<span class="hljs-built_in">std</span>::to_string(n));         &#125;         <span class="hljs-built_in">std</span>::sort(strs.begin(), strs.end(), cmp);         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : strs) &#123;             ans += s;         &#125;         <span class="hljs-keyword">return</span> ans;     &#125; &#125;;</code></pre></div><h5 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; s1, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s2)</span> </span>&#123;<span class="hljs-comment">//也可以写作solution内，但要加上static，否则会报错</span>        <span class="hljs-keyword">return</span> s1 + s2 &lt; s2 + s1;    &#125;    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; strs;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ans;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums) &#123;            strs.push_back(<span class="hljs-built_in">std</span>::to_string(n));        &#125;        <span class="hljs-built_in">std</span>::sort(strs.begin(), strs.end(), cmp);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : strs) &#123;            ans += s;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><h5 id="代码3"><a href="#代码3" class="headerlink" title="代码3"></a>代码3</h5><p>利用lambda表达式写排序的规则，如果不熟悉lambda，可以采用上述方法即可</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//lambda表达式排序</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; strs;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ans;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;            strs.push_back(<span class="hljs-built_in">std</span>::to_string(nums[i]));        &#125;        <span class="hljs-comment">//lambda表达式</span>        <span class="hljs-built_in">std</span>::sort(strs.begin(), strs.end(), [](<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; s1, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; s2) &#123;<span class="hljs-keyword">return</span> s1 + s2 &lt; s2 + s1; &#125;);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.size(); i++) &#123;            ans += strs[i];        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>字符串</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】215.数组中的第K个最大元素</title>
    <link href="/%E3%80%90leetcode%E3%80%91215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html"/>
    <url>/%E3%80%90leetcode%E3%80%91215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>使用快速排序中的Partition函数，获得第j位上的元素，如果第j位和k-1相同，则直接返回即可<br>时间复杂度O(N)</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> end = nums.size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> index = Partition(nums, start, end);        <span class="hljs-keyword">while</span> (index!=k<span class="hljs-number">-1</span>) &#123;            <span class="hljs-keyword">if</span> (index &gt; k - <span class="hljs-number">1</span>) &#123;                end = index - <span class="hljs-number">1</span>;                index = Partition(nums, start, end);            &#125;            <span class="hljs-keyword">else</span> &#123;                start = index + <span class="hljs-number">1</span>;                index = Partition(nums, start, end);            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[index];    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">int</span> index = (rand() % (end - start + <span class="hljs-number">1</span>)) + start;        <span class="hljs-built_in">std</span>::swap(nums[start], nums[index]);<span class="hljs-comment">//start为主元</span>        <span class="hljs-keyword">int</span> i = start + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> j = end;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-comment">//从大到小排序</span>            <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[i] &gt;= nums[start]) i++;<span class="hljs-comment">//注意要加上"="号</span>            <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[j] &lt;= nums[start]) j--;            <span class="hljs-keyword">if</span> (i &gt; j) <span class="hljs-keyword">break</span>;            <span class="hljs-built_in">std</span>::swap(nums[i], nums[j]);        &#125;        <span class="hljs-built_in">std</span>::swap(nums[j], nums[start]);        <span class="hljs-keyword">return</span> j;    &#125;&#125;;</code></pre></div><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>小顶堆，维护一个k大的小顶堆，最终的小顶堆的堆顶，即为第k大的元素<br>时间复杂度O(nlogk)</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-built_in">std</span>::priority_queue&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-built_in">std</span>::greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; q;<span class="hljs-comment">//小元素放在队首，小顶堆 </span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : nums) &#123;            q.push(e);            <span class="hljs-keyword">if</span> (q.size() &gt; k) &#123;                q.pop();            &#125;        &#125;        <span class="hljs-keyword">return</span> q.top();    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>优先队列</tag>
      
      <tag>Partition算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】36. 二叉搜索树与双向链表</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9136-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9136-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>算法流程：<br><code>Node* treeToDoublyList(Node* root)</code><br>1.特例处理：若结点root为空，直接返回<br>2.转化为排序双向链表：调用<code>inorder(Node* root)</code><br>3.构建循环链表：head和pre双向结点引用<br>4.返回头结点</p><p><code>void inorder(Node* root)</code><br>中序遍历的改写，在访问根节点时，同时更新pre，head的值，使其能够双向连接</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    Node* pre=<span class="hljs-literal">nullptr</span>, *head;<span class="hljs-comment">//需要初始化pre=nullptr,head为链表头结点，pre为链表前驱结点</span>    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//特例处理</span>        inorder(root);<span class="hljs-comment">//中序遍历</span>        <span class="hljs-comment">//遍历完成后，head指向头结点，pre指向尾结点，因此要修改head和pre的双向结点引用，使其首尾相连</span>        head-&gt;left = pre;        pre-&gt;right = head;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-comment">//中序遍历</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(Node* root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归边界</span>        inorder(root-&gt;left);        <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">nullptr</span>) head = root;<span class="hljs-comment">//pre为空，说明此结点为链表头结点</span>        <span class="hljs-keyword">else</span> &#123;            pre-&gt;right = root;<span class="hljs-comment">//前驱结点的后继即为root</span>            root-&gt;left = pre;<span class="hljs-comment">//当前结点的前驱即为pre</span>        &#125;        pre = root;<span class="hljs-comment">//pre更新，结点root是后继结点的pre</span>        inorder(root-&gt;right);    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BST</tag>
      
      <tag>剑指offer</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】35. 复杂链表的复制</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9135-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9135-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>算法流程：</p><ol><li>建立映射<blockquote><p>对新链表结点和原链表结点建立<code>hashmap</code>的映射关系，原链表结点为<code>key</code>，新链表结点为<code>value</code></p></blockquote></li><li>赋值 <blockquote><p>通过<code>hashmap</code>将原链表的<code>next</code>，<code>random</code>所指结点赋给新链表，注意赋值时，要判断该两值是否不为空，因为建立<code>hashmap</code>时，没有建立<code>null</code>，<code>null</code>的映射</p></blockquote></li><li>返回新链表头结点<code>hashmap[head]</code></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;Node*, Node*&gt; listMap;        Node* p = head;        <span class="hljs-comment">//将原链表和新链表建立映射关系</span>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>) &#123;            listMap[p] = <span class="hljs-keyword">new</span> Node(p-&gt;val);            p = p-&gt;next;        &#125;        p = head;        <span class="hljs-comment">//将原链表的next，random值赋给新链表</span>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>) &#123;            <span class="hljs-keyword">if</span>(p-&gt;next)  listMap[p]-&gt;next = listMap[p-&gt;next];<span class="hljs-comment">//如果p-&gt;next不为空</span>            <span class="hljs-keyword">if</span>(p-&gt;random) listMap[p]-&gt;random = listMap[p-&gt;random];<span class="hljs-comment">//如果p-&gt;random不为空</span>            p = p-&gt;next;        &#125;        <span class="hljs-keyword">return</span> listMap[head];    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】33.二叉搜索树的后序遍历序列</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9133-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9133-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BST</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【SUM】二叉树的遍历方法</title>
    <link href="/%E3%80%90sum%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95.html"/>
    <url>/%E3%80%90sum%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><h5 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h5><h5 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h5><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h5 id="递归版-1"><a href="#递归版-1" class="headerlink" title="递归版"></a>递归版</h5><h5 id="非递归版-1"><a href="#非递归版-1" class="headerlink" title="非递归版"></a>非递归版</h5><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><h5 id="递归版-2"><a href="#递归版-2" class="headerlink" title="递归版"></a>递归版</h5><h5 id="非递归版-2"><a href="#非递归版-2" class="headerlink" title="非递归版"></a>非递归版</h5><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span>      <span class="hljs-keyword">int</span> val;      TreeNode *left;      TreeNode *right;      TreeNode(<span class="hljs-keyword">int</span> x) : val(x), left(<span class="hljs-literal">NULL</span>), right(<span class="hljs-literal">NULL</span>) &#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ans;        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;        q.push(root);<span class="hljs-comment">//将根结点root加入队列q</span>        <span class="hljs-keyword">while</span> (!q.empty()) &#123;            TreeNode* front = q.front();<span class="hljs-comment">//取出队首结点，访问它</span>            ans.push_back(front-&gt;val);            q.pop();<span class="hljs-comment">//弹出</span>            <span class="hljs-keyword">if</span> (front-&gt;left != <span class="hljs-literal">nullptr</span>) q.push(front-&gt;left);<span class="hljs-comment">//左子树不为空，压入左子树</span>            <span class="hljs-keyword">if</span> (front-&gt;right != <span class="hljs-literal">nullptr</span>) q.push(front-&gt;right);<span class="hljs-comment">//右子树不为空，压入右子树</span>        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ans;        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;        q.push(root);        <span class="hljs-keyword">while</span> (!q.empty()) &#123;            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;            <span class="hljs-keyword">int</span> len = q.size();<span class="hljs-comment">//这里的size要提前拿，不要写作下面的循环中</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;                TreeNode* front = q.front();                temp.push_back(front-&gt;val);                q.pop();                <span class="hljs-keyword">if</span> (front-&gt;left != <span class="hljs-literal">nullptr</span>) q.push(front-&gt;left);                <span class="hljs-keyword">if</span> (front-&gt;right != <span class="hljs-literal">nullptr</span>) q.push(front-&gt;right);            &#125;            ans.push_back(temp);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SUM</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】31. 栈的压入、弹出序列</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9131-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9131-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>算法流程：</p><ol><li>初始化，辅助栈tempS和弹出序列的索引i</li><li>遍历压入序列pushed<ul><li>压入pushed的元素e</li><li>判断tempS是否为空且栈顶元素和popped[i]相等<ul><li>tempS出栈</li><li>i++</li></ul></li></ul></li></ol><p>3.返回tempS.empty()，如果其为空，说明合法，反之不合法</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; pushed, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; popped)</span> </span>&#123;        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; tempS;<span class="hljs-comment">//辅助栈</span>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//弹出序列的索引i</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : pushed) &#123;            tempS.push(e);<span class="hljs-comment">//入栈</span>            <span class="hljs-keyword">while</span> (!tempS.empty()&amp;&amp;tempS.top()==popped[i])&#123;<span class="hljs-comment">//栈顶元素，相等，弹出序列元素popped[i]</span>                tempS.pop();<span class="hljs-comment">//出栈</span>                i++;<span class="hljs-comment">//i++</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> tempS.empty();<span class="hljs-comment">//如果为空，说明合法</span>    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】21. 调整数组顺序使奇数位于偶数前面</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9121-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9121-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>双指针，p1指向头，p2指向尾，p1在遇到偶数时停下，p2在遇到奇数时停下，如果此时p1&lt;p2，则进行交换</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>, p2 = nums.size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (p1&lt;p2)        &#123;            <span class="hljs-keyword">while</span> (p1 &lt; p2 &amp;&amp; (nums[p1] &amp; <span class="hljs-number">1</span>)  ) p1++;<span class="hljs-comment">//p1所指为奇数时</span>            <span class="hljs-keyword">while</span> (p1 &lt; p2 &amp;&amp; (nums[p2] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) p2--;<span class="hljs-comment">//p2所指为偶数时</span>            <span class="hljs-keyword">if</span> (p1 &lt; p2) swap(nums[p1], nums[p2]);<span class="hljs-comment">//p1&lt;p2时</span>        &#125;        <span class="hljs-keyword">return</span> nums;    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【MIT6.837】A3:OpenGL &amp; Phong Shading</title>
    <link href="/%E3%80%90mit6-837%E3%80%91a3-opengl-phong-shading.html"/>
    <url>/%E3%80%90mit6-837%E3%80%91a3-opengl-phong-shading.html</url>
    
    <content type="html"><![CDATA[<h1 id="A3：OpenGL-amp-Phong-Shading"><a href="#A3：OpenGL-amp-Phong-Shading" class="headerlink" title="A3：OpenGL &amp; Phong Shading"></a>A3：<a href="http://groups.csail.mit.edu/graphics/classes/6.837/F04/assignments/assignment3/" target="_blank" rel="noopener">OpenGL &amp; Phong Shading</a></h1><hr><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><ul><li>实现交互式相机</li><li>实现Blinn-Phong光照模型及对应的光滑明暗处理技术</li><li>实现绘制各个图元的方法，尤其是球图元的绘制</li></ul><h2 id="Hints"><a href="#Hints" class="headerlink" title="Hints"></a>Hints</h2><h4 id="1、Phong模型与Bling-Phong的区别"><a href="#1、Phong模型与Bling-Phong的区别" class="headerlink" title="1、Phong模型与Bling-Phong的区别"></a>1、Phong模型与Bling-Phong的区别</h4><ul><li><p>Phong适合模拟塑料，比”反射”材质表现出的介质更光滑一些，适合模拟玻璃、水、冰等高反光特性的介质</p></li><li><p>BlinnPhong大多适用于金属材质</p></li><li><p>Blinn-Phong它能提供比Phong更柔和、更平滑的高光，而且速度上也更快，因此成为很多CG软件中默认的光照渲染方法，同时也被集成到大多数的图形芯片中</p></li></ul><h4 id="2、光滑明暗处理技术"><a href="#2、光滑明暗处理技术" class="headerlink" title="2、光滑明暗处理技术"></a>2、光滑明暗处理技术</h4><ul><li>平坦着色（Flat Shading）</li></ul><p>算法思想：</p><blockquote><p>通过三角形三顶点的坐标计算出整个三角形的法向量。<br>优缺点：<br>这样就导致相邻两个三角形的法向量差别很大，所以就能看到明显的三角形的边。</p></blockquote><ul><li>Gouraud光亮度插值技术</li></ul><p>算法思想：</p><blockquote><p>将曲面表面某一点的光亮度做近似表示，近似值取为该曲面的各多边形顶点光亮度的双线性插值。</p></blockquote><p>优缺点：</p><blockquote><p>采用Gouraud明暗处理不但可以克服由多边形近似表示的曲面的光亮度不连续现象，而且计算量也很小。<br>1.不能正确地模拟高光。这是因为采用光亮度插值后将使多边形内的高光丢失。<br>2.所绘制画面会诱发马赫带效应。<br>虽然光亮度双线性插值保证了由多边形近似表示的曲面上各处光亮度的连续变化，但在相邻多边形的公共边界上光亮度的一阶导数并不连续，由于人眼的光学错觉，光亮度变化一阶不连续的边界处会呈现亮带或黑带，即马赫带效应。<br>3.克服这些缺点的一种方法是采用Phong明暗处理。</p></blockquote><ul><li>Phong法向量插值技术</li></ul><p>算法思想：</p><blockquote><p>它的基本思想是对多边形顶点处（平均）法向量做双线性插值，以增加一定的计算量为代价克服了Gouraud明暗处理的缺点。</p></blockquote><p>优缺点：</p><blockquote><p>1.优点：绘制的图形比Gouraud方法更真实<br>2.缺点：计算量远大于Gouraud方法</p></blockquote><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>部分结果如下：<br><img src="https://img-blog.csdnimg.cn/2020051922240261.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020051922240259.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/fuzhanzhan/MIT-CG6.837-2004" target="_blank" rel="noopener">符佬的github</a></li><li><a href="https://baike.baidu.com/item/%E5%A5%87%E5%BC%82%E7%9F%A9%E9%98%B5/9658459?fr=aladdin" target="_blank" rel="noopener">奇异矩阵</a></li><li><a href="https://www.cnblogs.com/yuxingli/p/7821102.html" target="_blank" rel="noopener">extern的使用</a></li><li><a href="https://www.mathsisfun.com/algebra/matrix-inverse.html" target="_blank" rel="noopener">逆矩阵的含义和应用</a></li><li><a href="https://wenku.baidu.com/view/4e6443ea9b89680202d8250f.html" target="_blank" rel="noopener">phong光照模型</a>（此中文PPT讲的还不错）</li></ul><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/xdobetter/MIT-CG6.837/tree/master/A3%20Assignment%203%20OpenGL%20&%20Phong%20Shading" target="_blank" rel="noopener">Github</a></p>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.837</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【MIT6.837】A2:Transformations &amp; Additional Primitives</title>
    <link href="/%E3%80%90mit6-837%E3%80%91a2-transformations-additional-primitives.html"/>
    <url>/%E3%80%90mit6-837%E3%80%91a2-transformations-additional-primitives.html</url>
    
    <content type="html"><![CDATA[<h1 id="A2：Transformations-amp-Additional-Primitives"><a href="#A2：Transformations-amp-Additional-Primitives" class="headerlink" title="A2：Transformations &amp; Additional Primitives"></a>A2：<a href="http://groups.csail.mit.edu/graphics/classes/6.837/F04/assignments/assignment2/" target="_blank" rel="noopener">Transformations &amp; Additional Primitives</a></h1><hr><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><p>本实验的目标是实现更多的基本图元（如Plane、Triangle类的实现）、新增两种渲染模式(normal visualization和diffuse shading)、新增PerspectiveCamera类及变换(Transform类)的实现。</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="1-TASK分析"><a href="#1-TASK分析" class="headerlink" title="1 TASK分析"></a>1 TASK分析</h3><p><img src="https://img-blog.csdnimg.cn/20200517222206828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_8,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200517222206854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>下面右边的序号是在实验中实际完成的顺序</p><p>[1] Object中更新球的计算交点方法【3】<br>[2] Object中派生出plane【2】，并实现其求交点方法【3】<br><img src="https://img-blog.csdnimg.cn/20200517222245699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>[3] Object中派生出Triangle【2】，并实现其求交点方法【3】</p><p><img src="https://img-blog.csdnimg.cn/20200517222305400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200517222305395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><b>红色部分即为|A|</b></p><p><img src="https://img-blog.csdnimg.cn/20200517222339559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200517222339550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>[4]Object中派生出Transform【2】<br>[5]实现Transform类的求交点方法【3】<br>[6]实现normal visualization和diffuse shading的渲染模式【4】</p><blockquote><p>在主函数中实现两个渲染模式，同时封装一下命令解析代码</p></blockquote><p>[7]在Camera中派生出PerspectiveCamera【1】</p><h3 id="2-代码结构分析"><a href="#2-代码结构分析" class="headerlink" title="2 代码结构分析"></a>2 代码结构分析</h3><p>不需要的编写的文件</p><blockquote><p>hit.h（A2更新）、light.h（A2给出）、ray.h、vectors.h、materials.h、image.h(c)、matrix.h(c)、scene_parser.h(c)（A2更新）<br>需要编写的文件<br>camera.h(c)、main.c、object3d.h(c)、</p></blockquote><h2 id="注意点-Hints"><a href="#注意点-Hints" class="headerlink" title="注意点(Hints)"></a>注意点(Hints)</h2><p>除实验中给出的Hints，这里给出自己在完成过程中遇到的不懂之处。</p><p>1 virtual ~Object3D() {} 为什么加virtual，有什么含义？</p><blockquote><p>上述写法叫虚析构函数，和其他函数一样，我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本；当我们delete一个动态分配的对象的指针时将执行析构函数，如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。</p></blockquote><p>2 virtual 和 override</p><blockquote><p>override只能对virtual进行重写</p></blockquote><p>3 叉乘坐标系的表示方式</p><blockquote><p>右手法则（right hand rule）</p></blockquote><p>4 new并delete指针数组的方式</p><blockquote><p><a href="https://www.cnblogs.com/chenhuan001/p/7373448.html" target="_blank" rel="noopener">见此博客</a></p></blockquote><p>5 C/C++ assert()函数用法</p><blockquote><p><a href="https://blog.csdn.net/myyllove/article/details/82898875" target="_blank" rel="noopener">见此博客</a></p></blockquote><p>6 error C2065: “M_PI”: 未声明的标识符</p><blockquote><p><a href="https://www.cnblogs.com/zzsama/p/10993125.html" target="_blank" rel="noopener">见此博客</a></p></blockquote><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>部分实验结果如下:</p><p><img src="https://img-blog.csdnimg.cn/20200517222403886.png" srcset="/img/loading.gif" alt="在这里插入图片描述"> <img src="https://img-blog.csdnimg.cn/20200517222403463.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200517222427325.png" srcset="/img/loading.gif" alt="在这里插入图片描述"> <img src="https://img-blog.csdnimg.cn/20200517222427272.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/xdobetter/MIT-CG6.837/tree/master/A2%20Transformations%20%26%20Additional%20Primitives" target="_blank" rel="noopener">xdobetter的github</a></p>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.837</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【MIT6.837】A1:Ray Casting</title>
    <link href="/%E3%80%90mit6-837%E3%80%91a1-ray-casting.html"/>
    <url>/%E3%80%90mit6-837%E3%80%91a1-ray-casting.html</url>
    
    <content type="html"><![CDATA[<h1 id="A1：Ray-Casting（光线投射"><a href="#A1：Ray-Casting（光线投射" class="headerlink" title="A1：Ray Casting（光线投射)"></a>A1：<a href="http://groups.csail.mit.edu/graphics/classes/6.837/F04/assignments/assignment1/" target="_blank" rel="noopener">Ray Casting</a>（光线投射)</h1><hr><h2 id="学术名词"><a href="#学术名词" class="headerlink" title="学术名词"></a>学术名词</h2><blockquote><p>camera obscura：针孔照相机<br>Perspective：透视投影<br>Orthographic：正交投影<br>Parallel projection：平行投影<br>Ray-Plane Intersection：射线与平面相交<br>Ray-Sphere Intersection：射线与球面相交<br>orthonormal basis：标准正交基<br>Ray Casting：光线投射<br>Ray tracing：光线追踪<br>Geometric：几何学<br>Algebraic：代数学<br>Object-Oriented Design：面向对象设计</p></blockquote><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><p>本实验的目标是要完成一个光线投射算法。光线投射算法的原理如下图（文字部分为个人见解）：<br>对于每一个像素<br>&emsp;构建一条从视点处开始的射线<br>    &emsp;&emsp;对场景中的每一个对象<br>       &emsp;&emsp;判断当前射线是否和当前对象有交点（此处要用到求交点函数）<br>    &emsp;&emsp;如果有且该交点距离视点更近，则更新最近交点值</p><p><img src="https://img-blog.csdnimg.cn/20200513230801435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>下面说明一下本实验完成过程的重点。</p><h3 id="射线和球模型的计算交点方法的实现"><a href="#射线和球模型的计算交点方法的实现" class="headerlink" title="射线和球模型的计算交点方法的实现"></a>射线和球模型的计算交点方法的实现</h3><p>此处采用的是Algebraic方法，该方法的实现不是很难理解，根据PPT的公式及实验讲解即可完成该部分。Geometric方法使用较少因此没有实现。</p><p><img src="https://img-blog.csdnimg.cn/2020051323082180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200513230821154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Sphere::intersect</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ray&amp; r, Hit&amp; h, <span class="hljs-keyword">float</span> tmin)</span> </span>&#123;<span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<span class="hljs-comment">//有交点返回true</span>Vec3f ro = r.getOrigin() - center;<span class="hljs-comment">//ro:射线到球中心的向量</span>Vec3f rd = r.getDirection();<span class="hljs-comment">//射线方向</span><span class="hljs-keyword">float</span> a = rd.Dot3(rd);<span class="hljs-comment">//rd与rd点积</span><span class="hljs-keyword">float</span> b = <span class="hljs-number">2</span> * ro.Dot3(rd);<span class="hljs-comment">//ro与rd点积,可能为负</span><span class="hljs-keyword">float</span> c = ro.Dot3(ro) - radius * radius;<span class="hljs-keyword">float</span> delta = b * b - <span class="hljs-number">4</span> * a * c;<span class="hljs-comment">//float t;//当前距离,此处可以不用</span><span class="hljs-comment">//获取最近的交点</span><span class="hljs-keyword">if</span> (delta &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">float</span> d = <span class="hljs-built_in">sqrt</span>(delta);<span class="hljs-comment">//一定为正</span><span class="hljs-keyword">float</span> t1 = (-b - d) / (<span class="hljs-number">2</span> * a);<span class="hljs-comment">//通常t1更小</span><span class="hljs-keyword">float</span> t2 = (-b + d) / (<span class="hljs-number">2</span> * a);<span class="hljs-comment">// For an orthographic camera, rays always start at infinity, so tmin will be a large negative value</span><span class="hljs-comment">//由于本节作业是正交相机，正交相机的tmin为无穷大，因此下面这块代码可以不用</span><span class="hljs-comment">//if (t1 &gt;= tmin) &#123;//在origin之前</span><span class="hljs-comment">//t = t1;</span><span class="hljs-comment">//&#125;</span><span class="hljs-comment">//else if (t2 &gt;= tmin) &#123;</span><span class="hljs-comment">//t = t2;</span><span class="hljs-comment">//&#125;</span><span class="hljs-keyword">if</span> (t1 &lt; h.getT()) &#123;<span class="hljs-comment">//closer当前交点，更新</span>h.<span class="hljs-built_in">set</span>(t1, material, r);flag = <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-keyword">return</span> flag;&#125;</code></pre></div><h3 id="正交相机的实现"><a href="#正交相机的实现" class="headerlink" title="正交相机的实现"></a>正交相机的实现</h3><p>直接参见PPT上给出的原理进行实现<br><img src="https://img-blog.csdnimg.cn/20200513230920794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function">Ray <span class="hljs-title">OrthographicCamera::generateRay</span><span class="hljs-params">(Vec2f point)</span> </span>&#123;Vec3f ro = center + (point.x() - <span class="hljs-number">0.5</span>) * horizontal * size + (point.y() - <span class="hljs-number">0.5</span>) * up * size;<span class="hljs-comment">//射线起始点到对象中心</span><span class="hljs-keyword">return</span> Ray(ro, direction);&#125;</code></pre></div><h3 id="光线投射算法的实现"><a href="#光线投射算法的实现" class="headerlink" title="光线投射算法的实现"></a>光线投射算法的实现</h3><p>该函数在主函数中进行了实现，代码如下</p><div class="hljs"><pre><code class="hljs cpp">   <span class="hljs-comment">/*输入——初始化场景、相机、对象组及两幅图像*/</span><span class="hljs-function">SceneParser <span class="hljs-title">scene</span><span class="hljs-params">(input_file)</span></span>;Camera* camera = scene.getCamera();Object3D* group = scene.getGroup();<span class="hljs-function">Image <span class="hljs-title">image</span><span class="hljs-params">(width, height)</span></span>;<span class="hljs-comment">//设置图像大小</span>image.SetAllPixels(scene.getBackgroundColor());<span class="hljs-comment">//图像背景颜色设置为场景背景颜色</span><span class="hljs-function">Image <span class="hljs-title">depthImage</span><span class="hljs-params">(width, height)</span></span>;<span class="hljs-comment">//设置深度图像</span>depthImage.SetAllPixels(Vec3f(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>));<span class="hljs-comment">//设置成黑色</span>   <span class="hljs-comment">//光线投射</span><span class="hljs-comment">/*循环遍历图像平面中的像素，使用OrthographicCamera类生成射线，将其与Group中的各个对象求交点，并将最近点保存到hit中*/</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;width;++i)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; height; ++j) &#123;<span class="hljs-keyword">float</span> x = <span class="hljs-keyword">float</span>(i) / <span class="hljs-keyword">float</span>(width);<span class="hljs-keyword">float</span> y = <span class="hljs-keyword">float</span>(j) / <span class="hljs-keyword">float_t</span>(height);Ray ray = camera-&gt;generateRay(Vec2f(x, y));<span class="hljs-comment">//产生射线</span><span class="hljs-function">Hit <span class="hljs-title">hit</span><span class="hljs-params">(INFINITY, <span class="hljs-literal">nullptr</span>)</span></span>;<span class="hljs-comment">//hit存储最近的交点，此处初始t设置为了无穷大</span><span class="hljs-keyword">bool</span> flag = group-&gt;intersect(ray, hit, camera-&gt;getTMin());<span class="hljs-comment">//使该条射线和每一个基本图元求交点</span><span class="hljs-keyword">if</span> (flag) &#123;<span class="hljs-comment">//如果存在交点</span>image.SetPixel(i, j, hit.getMaterial()-&gt;getDiffuseColor());<span class="hljs-comment">//设置该点像素的颜色</span><span class="hljs-keyword">float</span> t = hit.getT();<span class="hljs-comment">//可视化深度t</span><span class="hljs-comment">//超过则设置为边界值</span><span class="hljs-keyword">if</span> (t &gt; depth_max) t = depth_max;<span class="hljs-comment">//此处max=1、min=0</span><span class="hljs-keyword">if</span> (t &lt; depth_min) t = depth_min;t = (depth_max - t) / (depth_max - depth_min);<span class="hljs-comment">//t越小越近，越近的颜色越深</span>depthImage.SetPixel(i, j, Vec3f(t, t, t));<span class="hljs-comment">//设置颜色值</span>&#125;&#125;&#125;</code></pre></div><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://img-blog.csdnimg.cn/20200513230851178.png" srcset="/img/loading.gif" alt="在这里插入图片描述">  <img src="https://img-blog.csdnimg.cn/20200513230851180.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>在实验的过程中，阅读完实验讲义和PPT，不是很明白实验需要完成那些内容。因此我直接参考了别人已完成的代码，并对需要实现的部分一点点对着阅读和理解。边看代码边看PPT和实验讲义，对每个文件每个函数充分理解，实验也逐渐完成，本实验也是之后实验的重点，需要充分弄明白。<br>自己完成实验的步骤：<br>1.通看PPT<br>2.通看实验讲义<br>3.执行别人的代码<br>4.在不懂的情况下阅读实验讲义、PPT并阅读别人的代码</p><ul><li>记录自己要编写那些文件，完成那些函数</li><li>记录这些函数的实验原理，进一步理解这些算法的思想</li><li>记录下参考过的资料</li><li>重复该过程，直到弄懂</li></ul><p>5.整理实验，并写成报告</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/weixin_40552524/article/details/104436544" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40552524/article/details/104436544</a></li><li><a href="https://www.cnblogs.com/fengyuheliu/archive/2011/08/28/2155627.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengyuheliu/archive/2011/08/28/2155627.html</a></li></ul><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/xdobetter/MIT-CG6.837/tree/master/A1%20Ray%20Casting" target="_blank" rel="noopener">xdobetter的GitHub</a></p>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.837</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【MIT6.837】A0:IFS</title>
    <link href="/%E3%80%90mit6-837%E3%80%91a0-ifs.html"/>
    <url>/%E3%80%90mit6-837%E3%80%91a0-ifs.html</url>
    
    <content type="html"><![CDATA[<h1 id="A0：IFS（迭代函数系统）"><a href="#A0：IFS（迭代函数系统）" class="headerlink" title="A0：IFS（迭代函数系统）"></a>A0：IFS（迭代函数系统）</h1><h2 id="任务概述"><a href="#任务概述" class="headerlink" title="任务概述"></a>任务概述</h2><p>6.837的第一个作业，实现IFS算法。目的是熟悉C++的语法特性，并且熟悉使用两个和图像生成和线性代数相关的简单库。通过生成一些奇妙的分形物体来体会图形学的乐趣。</p><p>IFS <strong>是一种构造分形的方法，得到的分形通常是自相似(self-similar)的</strong>。IFS最经典的例子是绘制一种蕨类植物(Barnsley’s fern)，如下图所示，可以看到，每一个子叶片与整个叶片的形状相同。</p><p>IFS由<strong>一个仿射变换(affine transformations)集合所定义，通常定义的仿射变换包括旋转(rotation)、缩放(scale)、平移(translations)、斜切(skew)等等线性变换方法</strong>。这些变换不着了自相似的物体形状。IFS可以定义在多个维度上，在这个作业中，我们只需实现二维的变换。</p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>本实验已经提供了matrix.h、vectors.h、image.h、image.cpp、matrix.cpp5个文件<br>而我们要实现的文件是ifs.h、ifs.cpp、main.cpp<br>因此本实验的关键是实现ifs类、ifs的输入和ifs的渲染算法</p><h3 id="ifs类的创建"><a href="#ifs类的创建" class="headerlink" title="ifs类的创建"></a>ifs类的创建</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"matrix.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"image.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"vectors.h"</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IFS</span> &#123;</span><span class="hljs-keyword">private</span>:<span class="hljs-comment">//仿射变换的个数</span><span class="hljs-keyword">int</span> n;<span class="hljs-comment">//仿射变换矩阵数组</span>Matrix* matrix;<span class="hljs-comment">//每一个仿射变换的选取概率数组</span><span class="hljs-keyword">float</span>* prob;<span class="hljs-keyword">public</span>:<span class="hljs-comment">//构造函数，使用仿射变换个数初始化</span>IFS():n(<span class="hljs-number">0</span>),matrix(<span class="hljs-literal">nullptr</span>),prob(<span class="hljs-literal">nullptr</span>)&#123;&#125;<span class="hljs-comment">//析构函数</span>~IFS() &#123;<span class="hljs-keyword">delete</span>[] matrix;<span class="hljs-keyword">delete</span>[] prob;&#125;<span class="hljs-comment">//读取IFS输入</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">input</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* file)</span></span>;<span class="hljs-comment">//绘制IFS图片</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">render</span><span class="hljs-params">(Image&amp; image, <span class="hljs-keyword">int</span> num_points, <span class="hljs-keyword">int</span> num_iters)</span></span>;&#125;;</code></pre></div><h3 id="IFS输入的实现"><a href="#IFS输入的实现" class="headerlink" title="IFS输入的实现"></a>IFS输入的实现</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IFS::input</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* file)</span> </span>&#123;FILE* input = fopen(file, <span class="hljs-string">"r"</span>);assert(input != <span class="hljs-literal">nullptr</span>);<span class="hljs-comment">//断言帮助调式解决逻辑bug</span><span class="hljs-comment">//从一个流中执行格式化输入，fscanf遇到空格和换行时结束，注意空格时也结束</span><span class="hljs-built_in">fscanf</span>(input, <span class="hljs-string">"%d"</span>, &amp;n);<span class="hljs-comment">//读取变换的数量</span>matrix = <span class="hljs-keyword">new</span> Matrix[n];prob = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-built_in">fscanf</span>(input, <span class="hljs-string">"%f"</span>, &amp;prob[i]);<span class="hljs-comment">//读取变换的概率</span>matrix[i].Read3x3(input);<span class="hljs-comment">//读取变换的3x3浮点矩阵</span>&#125;fclose(input);<span class="hljs-comment">//关闭输入流</span>&#125;</code></pre></div><h3 id="IFS算法的实现"><a href="#IFS算法的实现" class="headerlink" title="IFS算法的实现"></a>IFS算法的实现</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IFS::render</span><span class="hljs-params">(Image&amp; image, <span class="hljs-keyword">int</span> num_points, <span class="hljs-keyword">int</span> num_iters)</span> </span>&#123;<span class="hljs-keyword">int</span> width = image.Width();<span class="hljs-keyword">int</span> height = image.Height();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_points;++i)&#123;Vec2f v = Vec2f(rand() * <span class="hljs-number">1.0f</span> / RAND_MAX, rand() * <span class="hljs-number">1.0f</span> / RAND_MAX);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; num_iters; ++j) &#123;<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<span class="hljs-keyword">float</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">float</span> t = rand() * <span class="hljs-number">1.0f</span> / RAND_MAX;<span class="hljs-keyword">for</span> (;k&lt;n;++k)&#123;sum += prob[k];<span class="hljs-keyword">if</span> (sum &gt; t) <span class="hljs-keyword">break</span>;&#125;matrix[k].Transform(v);&#125;<span class="hljs-keyword">if</span> (v.x() &gt;= <span class="hljs-number">0</span> &amp;&amp; v.x() &lt;= <span class="hljs-number">1</span> &amp;&amp; v.y() &gt;= <span class="hljs-number">0</span> &amp;&amp; v.y() &lt;= <span class="hljs-number">1</span>) &#123;image.SetPixel(v.x() * width, v.y() * height, Vec3f(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>));&#125;&#125;&#125;</code></pre></div><p>这里我不是很懂这个算法的思想，主要是参考了别人的代码完成</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://img-blog.csdnimg.cn/20200512201918546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200512201918518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200512201918506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200512201918519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/nycshisan/MIT6_837_Assignments/tree/master/src" target="_blank" rel="noopener">https://github.com/nycshisan/MIT6_837_Assignments/tree/master/src</a></li><li><a href="https://blog.csdn.net/u012420309/article/details/52948729" target="_blank" rel="noopener">vs2013遇到fopen不安全替换fopen_s的问题</a></li><li><a href="https://www.cnblogs.com/132818Creator/p/11014639.html" target="_blank" rel="noopener">VS中多级目录的写法</a></li><li><a href="https://blog.csdn.net/poinsettia/article/details/17138801" target="_blank" rel="noopener">CMAKE的学习</a></li><li><a href="https://github.com/fuzhanzhan/MIT-CG6.837-2004" target="_blank" rel="noopener">https://github.com/fuzhanzhan/MIT-CG6.837-2004</a></li><li><a href="https://blog.csdn.net/wonggonghong/article/details/16381975" target="_blank" rel="noopener">(MIT 6.837)迭代函数系统IFS画自相似图形的算法</a></li></ul><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/xdobetter/MIT-CG6.837" target="_blank" rel="noopener">Github下载</a></p>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.837</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【OpenGL】三维场景漫游的实现</title>
    <link href="/%E3%80%90opengl%E3%80%91%E4%B8%89%E7%BB%B4%E5%9C%BA%E6%99%AF%E6%BC%AB%E6%B8%B8%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <url>/%E3%80%90opengl%E3%80%91%E4%B8%89%E7%BB%B4%E5%9C%BA%E6%99%AF%E6%BC%AB%E6%B8%B8%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>构建一个三维场景<br>  可利用glut提供的各种简单形体来搭建，或者读入别的模型，并加入光照效果</li><li>用键盘操作一个物体（如一艘飞船，或一个机器人），在三维场景中漫游<br>视点可以放在物体上，或跟随物体，利用gluLookAt()函数来实现对视点的控制</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、开始想直接利用OpenGL的glulookAt函数，但发现并不好用<br>2、之后参考他人资料寻思构造一个摄像机类，通过摄像机类达到控制视点，这部分通过参考LearnOpenGL上的摄像机类进行实现 </p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="实验效果图"><a href="#实验效果图" class="headerlink" title="实验效果图"></a>实验效果图</h3><p><img src="https://img-blog.csdnimg.cn/2020051220023985.gif#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="程序控制键说明"><a href="#程序控制键说明" class="headerlink" title="程序控制键说明"></a>程序控制键说明</h3><ul><li>w,s,a,d分别控制视点的前进，后推，左移，右移</li><li>q，e控制视点进行左旋转，右旋转</li><li>方向键LEFT、RIGHT、UP、DOWN，视线方向转向左，视线方向转向右，视线方向转向上，视线方向转向下</li><li>Page_UP、Page_Down，视点位置升高，降低</li></ul><h2 id="实验思考"><a href="#实验思考" class="headerlink" title="实验思考"></a>实验思考</h2><h3 id="glulookAt"><a href="#glulookAt" class="headerlink" title="glulookAt()"></a>glulookAt()</h3><p>一般gluLookAt()用于从世界坐标系到眼坐标系的转换，但是由于OpenGL里面模型视图矩阵直接将本地坐标系转换为眼坐标系，所以gluLookAt()应该被用来设置模型视图矩阵，但是有一点得注意了：<br>gluLookAt()的调用应该在场景绘制初glLoadIdentity()函数调用之后，在所有的glTranslate<em>()、glRotate</em>()、glScale*()函数调用之前调用，且只调用一次<br>参考自以下资料<br><a href="https://bbs.csdn.net/topics/390124968" target="_blank" rel="noopener">https://bbs.csdn.net/topics/390124968</a><br><a href="https://blog.csdn.net/fyyyr/article/details/79298636" target="_blank" rel="noopener">https://blog.csdn.net/fyyyr/article/details/79298636</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://blog.csdn.net/conan_4869lucky/article/details/72811009" target="_blank" rel="noopener">OpenGL初探：三维迷宫游戏（一）——场景漫游</a></p><blockquote><p>首先是是场景漫游：实现场景漫游有两种方式，一种是固定照相机的位置，对整个场景进行变换，例如当人物前进时，其实是通过将整个场景向后平移实现的，转向时，是通过反向旋转整个场景实现的；另一种方式是使照相机在场景中移动，通过gluLookAt()函数设定照相机的位置，可以任意指定照相机的位置和朝向。</p></blockquote><ul><li><a href="https://blog.csdn.net/qq_27161673/article/details/72860890" target="_blank" rel="noopener">OPENGL三维场景搭建、漫游、交互</a></li></ul><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><ul><li><a href="https://download.csdn.net/download/weixin_41234001/12412946" target="_blank" rel="noopener">CSDN下载</a></li><li><a href="">Github下载</a> 待完成</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>MOOC-图形编程技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【OpenGL】机器人手臂的实现</title>
    <link href="/%E3%80%90opengl%E3%80%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%89%8B%E8%87%82%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <url>/%E3%80%90opengl%E3%80%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%89%8B%E8%87%82%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>MOOC-图形编程技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】134.加油站</title>
    <link href="/%E3%80%90leetcode%E3%80%91134-%E5%8A%A0%E6%B2%B9%E7%AB%99.html"/>
    <url>/%E3%80%90leetcode%E3%80%91134-%E5%8A%A0%E6%B2%B9%E7%AB%99.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><p>暴力破解，一方面验证自己对题目的理解是否正确，另一方面后续的优化也可以从这里入手。<br>1、考虑从第<code>0</code>个点出发，能否回到第<code>0</code>个点。<br>2、考虑从第<code>1</code>个点出发，能否回到第<code>1</code>个点。<br>3、考虑从第<code>2</code>个点出发，能否回到第<code>2</code>个点。<br>… …<br>4、考虑从第<code>n</code>个点出发，能否回到第<code>n</code>个点。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//暴力法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; gas, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; cost)</span> </span>&#123;<span class="hljs-keyword">int</span> n = gas.size();<span class="hljs-comment">//考虑从每一个点出发</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-keyword">int</span> j = i;<span class="hljs-keyword">int</span> remain = gas[i];<span class="hljs-comment">//当前剩余的油能否到达下一个点</span><span class="hljs-keyword">while</span> (remain-cost[j]&gt;=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//减去花费的加上新的点的补给</span>remain = remain - cost[j] + gas[(j + <span class="hljs-number">1</span>) % n];j = (j + <span class="hljs-number">1</span>) % n;<span class="hljs-comment">//如果j回到了i</span><span class="hljs-keyword">if</span> (j == i) &#123;<span class="hljs-keyword">return</span> i;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;&#125;;</code></pre></div><h4 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h4><p>说实话这个在LeetCode上看了很久的题解，但还是对于官方题解不是很懂，对于这个问题，主要参考了该博主的题解<a href="https://leetcode-cn.com/problems/gas-station/solution/shi-yong-tu-de-si-xiang-fen-xi-gai-wen-ti-by-cyayc/" target="_blank" rel="noopener">使用图的思想分析该问题</a></p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; gas, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; cost)</span> </span>&#123;<span class="hljs-keyword">int</span> len = gas.size();<span class="hljs-keyword">int</span> spare = <span class="hljs-number">0</span>;<span class="hljs-comment">//总剩余汽油量</span><span class="hljs-keyword">int</span> minSpare = <span class="hljs-number">9999999999</span>;<span class="hljs-comment">//最小的总剩余汽油量</span><span class="hljs-keyword">int</span> minIndex = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录出发点</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;spare += gas[i] - cost[i];<span class="hljs-keyword">if</span> (spare&lt;minSpare)&#123;minSpare = spare;minIndex = i;&#125;&#125;<span class="hljs-keyword">return</span> spare &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : (minIndex + <span class="hljs-number">1</span>) % len;<span class="hljs-comment">//minIndex+1%len为出发点</span>&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】面试题51. 数组中的逆序对</title>
    <link href="/%E3%80%90leetcode%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9851-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.html"/>
    <url>/%E3%80%90leetcode%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9851-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>分治法：<br>采用的就是归并函数中的分治思想，该题与分治排序的不同点在于，在治的过程中进行逆序对的统计，逆序对的个数为<br><code>cnt += center - i + 1;</code><br>这也是在归并排序上要加的代码</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><span class="hljs-comment">思路：分治</span><span class="hljs-comment">通过分的方式，获得每个子区间，在合并每个子区间时计算每个子区间内部的逆序对个数</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-keyword">if</span> (nums.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//特判，size为0,1不可能出现逆序对</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temps</span><span class="hljs-params">(nums.size())</span></span>;mergeSort(nums, temps, <span class="hljs-number">0</span>, nums.size() - <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-comment">//归并排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; temps, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<span class="hljs-keyword">if</span> (left &lt; right) &#123;<span class="hljs-keyword">int</span> center = left + (right - left) / <span class="hljs-number">2</span>;mergeSort(nums, temps, left, center);<span class="hljs-comment">//左分</span>mergeSort(nums, temps, center + <span class="hljs-number">1</span>, right);<span class="hljs-comment">//右分</span>merge(nums, temps, left, center, right);<span class="hljs-comment">//治</span>&#125;&#125;<span class="hljs-comment">//合并</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; temp, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> center, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<span class="hljs-keyword">int</span> i = left, j = center + <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = left; k &lt;= right; k++) &#123;<span class="hljs-keyword">if</span> (i &gt; center) &#123;<span class="hljs-comment">//左边的已经比较完，将右边的全部放到temp中</span>temp[k] = nums[j++];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; right) &#123;<span class="hljs-comment">//右边的已经比较完，将左边的全部放到temp中</span>temp[k] = nums[i++];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<span class="hljs-comment">//左边大于右边，出现逆序对，</span>temp[k] = nums[j++];<span class="hljs-comment">//取右边数组值</span>cnt += center - i + <span class="hljs-number">1</span>;<span class="hljs-comment">//此处+1是因为center是等于right的,这里也是比归并排序多的一行代码</span>&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//左边小于等于右边</span>&#123;temp[k] = nums[i++];<span class="hljs-comment">//取左边数组值</span>&#125;&#125;<span class="hljs-comment">//将temp中的元素复制到nums中</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = left; k &lt;= right; k++) &#123;nums[k] = temp[k];&#125;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【OpenGL】光照太阳系</title>
    <link href="/%E3%80%90opengl%E3%80%91%E5%85%89%E7%85%A7%E5%A4%AA%E9%98%B3%E7%B3%BB.html"/>
    <url>/%E3%80%90opengl%E3%80%91%E5%85%89%E7%85%A7%E5%A4%AA%E9%98%B3%E7%B3%BB.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>MOOC-图形编程技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【OpenGL】太阳星系的实现</title>
    <link href="/%E3%80%90opengl%E3%80%91%E5%A4%AA%E9%98%B3%E6%98%9F%E7%B3%BB%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <url>/%E3%80%90opengl%E3%80%91%E5%A4%AA%E9%98%B3%E6%98%9F%E7%B3%BB%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[<h2 id="一、功能"><a href="#一、功能" class="headerlink" title="一、功能"></a>一、功能</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>三个球体、一个表示太阳、一个表示地球、一个表示月亮；地球不停地绕太阳旋转，月亮绕地球旋转，期间它们三者都发生自转。</p><h3 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h3><p>地球有两个月亮，画上轨道线，使轨道倾斜，放缩效果</p><h3 id="自己完成的效果图"><a href="#自己完成的效果图" class="headerlink" title="自己完成的效果图"></a>自己完成的效果图<img src="https://img-blog.csdnimg.cn/20200322143615489.gif#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></h3><h2 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h2><h3 id="基本功能的实现"><a href="#基本功能的实现" class="headerlink" title="基本功能的实现"></a>基本功能的实现</h3><p>首先搭好程序框架：<br>1、    设置显示模式<br>2、    初始化窗口<br>3、    创建窗口<br>4、    设置一系列回调函数<br>5、    启动主循环<br>框架设置完毕后，针对display()函数进行编写，关于display函数的编写，即是整个基本功能的绘制，本人刚开始编写的时候，对全局变换和局部变换理解不够透彻，因此我在编写过程中一直采用全局变换的思路，并没有采用的局部变换的思路。</p><h4 id="1、创建三个球体，分别为太阳、地球和月亮，并移至对应位置"><a href="#1、创建三个球体，分别为太阳、地球和月亮，并移至对应位置" class="headerlink" title="1、创建三个球体，分别为太阳、地球和月亮，并移至对应位置"></a>1、创建三个球体，分别为太阳、地球和月亮，并移至对应位置</h4><p> <img src="https://img-blog.csdnimg.cn/20200322143807518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="2、使地球绕太阳转起来"><a href="#2、使地球绕太阳转起来" class="headerlink" title="2、使地球绕太阳转起来"></a>2、使地球绕太阳转起来</h4><p>我假设太阳为默认原点位置，地球将在xoz平面围绕太阳进行旋转，绕其旋转，起初，我思考地球位置的改变即为其x,z值的改变，对于一个圆，其x,z值采用极坐标的形式来表达，        </p><div class="hljs"><pre><code class="hljs cpp">   earthPosX=earthBound*<span class="hljs-built_in">cos</span>(curTheta*pi);<span class="hljs-comment">//求地球x</span>earthPosZ=earthBound*<span class="hljs-built_in">sin</span>(curTheta*pi);<span class="hljs-comment">//求地球z</span></code></pre></div><p>因此只要改变坐标，就能使求发生转动，于是通过编写定义定时器回调函数<code>void myTimerFunc(int value)</code>，在函数中不断增加theda的值，就可以使圆不断转动。</p><h4 id="3、使月亮绕地球转起来"><a href="#3、使月亮绕地球转起来" class="headerlink" title="3、使月亮绕地球转起来"></a>3、使月亮绕地球转起来</h4><p>月亮围绕地球转，由于我始终是从全局坐标的角度考虑了这个问题，<br>因此，月亮的坐标也要转换为全局坐标值，假设月球绕地球转动角度为far，则其x，z采用极坐标的形式来表达为</p><div class="hljs"><pre><code class="hljs cpp">monthPosX = earthPosX + monthBound* <span class="hljs-built_in">cos</span>(curFar * pi);<span class="hljs-comment">//求月球x</span>monthPosZ = earthPosZ + monthBound* <span class="hljs-built_in">sin</span>(curFar * pi);<span class="hljs-comment">//求月球y</span></code></pre></div><p>同样使其转动，在<code>void myTimerFunc(int value)</code>中，不断增加far的值即可，具体效果见SunEarthMonth.gif。而其中两个球体的自转，则设定一个自转角度curSpeed来控制，而其值的变化也在定时器回调函数中完成。<br><img src="https://img-blog.csdnimg.cn/20200322143920762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="扩展功能的实现"><a href="#扩展功能的实现" class="headerlink" title="扩展功能的实现"></a>扩展功能的实现</h3><h4 id="1、（扩展功能）实现地球上有两个月亮"><a href="#1、（扩展功能）实现地球上有两个月亮" class="headerlink" title="1、（扩展功能）实现地球上有两个月亮"></a>1、（扩展功能）实现地球上有两个月亮</h4><p>对于这个效果，很容易实现，此处简化，只设置月亮B和月亮A在同一平面内，并且两者速度相等，只需要保持轨道半径相等，位置不同即可，而如何做到这一点，仍然可以从圆出发，这里我做的是将另一个月亮和此月亮形成对称，因此使月亮B绕地球的角度比月亮A多180度即可，坐标值如下：</p><div class="hljs"><pre><code class="hljs cpp">month2PosX = earthPosX + monthBound * <span class="hljs-built_in">cos</span>(curFar * pi+pi);<span class="hljs-comment">//求月球2x</span>month2PosZ = earthPosZ + monthBound * <span class="hljs-built_in">sin</span>(curFar * pi+pi);<span class="hljs-comment">//求月球2z</span></code></pre></div><p>具体实现效果见下图<br><img src="https://img-blog.csdnimg.cn/2020032214435296.gif#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="2、（扩展功能）画上轨道线"><a href="#2、（扩展功能）画上轨道线" class="headerlink" title="2、（扩展功能）画上轨道线"></a>2、（扩展功能）画上轨道线</h4><p>实现地球绕太阳的轨道线描绘的就是以太阳为中心，以地球到太阳的距离为半径画的圆，而在OpenGL中，绘画基本图元没有圆，因此我思考通过不断的画直线来逼近圆，因此使用GL_LINE_LOOP来绘制，线段我一共绘制了7200次。同理，月亮绕地球的轨道线，就是以地球为中心，以月亮到地球的距离为半径画的圆。效果图可见下图：</p><p><img src="https://img-blog.csdnimg.cn/20200322144340217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="3、（扩展功能）让轨道倾斜"><a href="#3、（扩展功能）让轨道倾斜" class="headerlink" title="3、（扩展功能）让轨道倾斜"></a>3、（扩展功能）让轨道倾斜</h4><p>首先我实现的是地球绕太阳的轨道倾斜，要做的效果实际上就是使xoy平面发生旋转，此处我是使其绕z轴先进行旋转，后续步骤不变即可。需要注意的是此处轨道倾斜，相应的地球和月亮也要随着倾斜。<br>倾斜代码为：<br>glRotatef(earthOrbitAngle, 0.0f, 0.0f, 1.0f);//地球轨道倾斜earthOrbitAngle度,轨道沿着Z轴逆时针旋转<br>对于月亮绕地球的轨道倾斜，其效果就是在地球绕太阳的轨道平面上，再旋转即可，此处我假定月亮绕地球的轨道平面绕地球到月亮的轴线进行旋转。因此先将其变换到地球绕太阳的轨道平面上后，再进行旋转一定角度即可实现。效果图详见：<br> <img src="https://img-blog.csdnimg.cn/20200322144047223.gif#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="4、（扩展功能）实现按键控制轨道倾斜与整体图形放大缩小功能"><a href="#4、（扩展功能）实现按键控制轨道倾斜与整体图形放大缩小功能" class="headerlink" title="4、（扩展功能）实现按键控制轨道倾斜与整体图形放大缩小功能"></a>4、（扩展功能）实现按键控制轨道倾斜与整体图形放大缩小功能</h4><p>对于轨道倾斜，通过键盘控制函数改变其角度参数值（earthOrbitAngle、monthOrbitAngle）即可，对于放大缩小，通过控制G_fDistance值即可。效果图详见SunEarthMonth4.gif：</p><p><img src="https://img-blog.csdnimg.cn/20200322144102861.gif#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="三、源代码"><a href="#三、源代码" class="headerlink" title="三、源代码"></a>三、源代码</h2><p><a href="https://download.csdn.net/download/weixin_41234001/12262604" target="_blank" rel="noopener">CSDN下载</a><br><a href="">Github下载</a></p>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>MOOC-图形编程技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】409. 最长回文串</title>
    <link href="/%E3%80%90leetcode%E3%80%91409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2.html"/>
    <url>/%E3%80%90leetcode%E3%80%91409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>若要形成最长的回文串，则回文串中只会出现1次单个字符，因此只需统计字符串中有多少个字符其数目为奇数，s.size()-n个为奇数个数的字符+1即为最长回文串<br>如果字符串没有出现奇数个数目的字符，则s.size()即为最长回文串</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; sMap;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c:s)&#123;sMap[c]++;&#125;<span class="hljs-keyword">int</span> oddNum = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; it:sMap)&#123;<span class="hljs-keyword">if</span> (it.second % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) oddNum++;&#125;<span class="hljs-keyword">if</span> (oddNum &gt; <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> s.size() - oddNum + <span class="hljs-number">1</span>;<span class="hljs-comment">//s.size()-为奇数个的字符数目+1</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> s.size();<span class="hljs-comment">//无奇数</span>&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】142. 环形链表 II</title>
    <link href="/%E3%80%90leetcode%E3%80%91142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii.html"/>
    <url>/%E3%80%90leetcode%E3%80%91142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="hashmap法"><a href="#hashmap法" class="headerlink" title="hashmap法"></a>hashmap法</h4><p>思路简单，时间复杂度O(n),空间复杂度O(n)</p><h4 id="Floyd法"><a href="#Floyd法" class="headerlink" title="Floyd法"></a>Floyd法</h4><p>知道结论进行编程容易，但是自己推导出Floyd公式比较难，理解该方法，进行编程即可<br>时间复杂度O(n),空间复杂度O(1)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="hashmap法-1"><a href="#hashmap法-1" class="headerlink" title="hashmap法"></a>hashmap法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function">ListNode* <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<span class="hljs-built_in">unordered_map</span>&lt;ListNode*, <span class="hljs-keyword">int</span>&gt; nodeMap;ListNode* cur = head;<span class="hljs-keyword">while</span> (cur)&#123;<span class="hljs-keyword">if</span> (nodeMap.find(cur) != nodeMap.end()) <span class="hljs-keyword">return</span> cur;nodeMap[cur]++;cur = cur-&gt;next;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;&#125;;</code></pre></div><h4 id="Floyd法-1"><a href="#Floyd法-1" class="headerlink" title="Floyd法"></a>Floyd法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function">ListNode* <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<span class="hljs-comment">//特判</span><span class="hljs-comment">//排除空节点或单个节点不成环的情况</span><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;ListNode* slow, * fast;slow = head;<span class="hljs-comment">//slow和fast要从head同时出发，要不然根据Floyd的原理进行指针移动会发生死循环</span>fast = head;<span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next)&#123;slow = slow-&gt;next;fast = fast-&gt;next-&gt;next;<span class="hljs-keyword">if</span> (fast==slow)<span class="hljs-comment">//存在环</span>&#123;fast = head;<span class="hljs-comment">//fast重置为head，slow不变，然后fast和slow现在开始每次只走一步，相遇点就是环的入口</span><span class="hljs-keyword">while</span> (fast!=slow)&#123;fast = fast-&gt;next;slow = slow-&gt;next;&#125;<span class="hljs-keyword">return</span> fast;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
      <tag>Floyd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】141.环形链表</title>
    <link href="/%E3%80%90leetcode%E3%80%91141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html"/>
    <url>/%E3%80%90leetcode%E3%80%91141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html</url>
    
    <content type="html"><![CDATA[<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="方法1-hash表"><a href="#方法1-hash表" class="headerlink" title="方法1 hash表"></a>方法1 hash表</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<span class="hljs-comment">//特判</span><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-built_in">unordered_map</span>&lt;ListNode*,<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">list</span>;ListNode* cur = head;<span class="hljs-keyword">while</span> (cur)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span>.find(cur) != <span class="hljs-built_in">list</span>.end()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-built_in">list</span>[cur]++;cur = cur-&gt;next;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;;</code></pre></div><h4 id="方法2-双指针"><a href="#方法2-双指针" class="headerlink" title="方法2 双指针"></a>方法2 双指针</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<span class="hljs-comment">//特判</span><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;ListNode *slow = head;<span class="hljs-comment">//慢指针</span>ListNode* fast = head-&gt;next;<span class="hljs-comment">//快指针</span><span class="hljs-keyword">while</span> (slow!=fast)&#123;<span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">nullptr</span> || fast-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//fast已走为null或fast走一步已为null</span>slow = slow-&gt;next;fast = fast-&gt;next-&gt;next;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
      <tag>双指针</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】516. 最长回文子序列</title>
    <link href="/%E3%80%90leetcode%E3%80%91516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <url>/%E3%80%90leetcode%E3%80%91516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实就是求ｓ和ｓ的逆序的最长公共子序列的。转化成最长公共子序列问题就迎刃而解了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s2</span><span class="hljs-params">(s)</span></span>;<span class="hljs-comment">//s2反转</span>reverse(s2.begin(), s2.end());<span class="hljs-comment">//定义状态</span><span class="hljs-comment">//s的前i个字符和s2的前j个字符的LCS</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(s.size() + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-comment">//初始化</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=s.size();i++)&#123;dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=s.size();i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=s.size();j++)&#123;<span class="hljs-keyword">if</span> (s[i<span class="hljs-number">-1</span>] == s2[j<span class="hljs-number">-1</span>]) &#123;dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span>&#123;dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[s.size()][s.size()];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】647. 回文子串</title>
    <link href="/%E3%80%90leetcode%E3%80%91647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html"/>
    <url>/%E3%80%90leetcode%E3%80%91647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路同最长回文子串，只不过此题再开辟一个变量记录回文子串出现的次数即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(s.size()))</span></span>;<span class="hljs-comment">//初始化</span><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.size();i++)&#123;dp[i][i] = <span class="hljs-number">1</span>;ans++;<span class="hljs-keyword">if</span> (s[i] == s[i + <span class="hljs-number">1</span>]) &#123;dp[i][i + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;ans++;&#125;&#125;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len=<span class="hljs-number">3</span>;len&lt;=s.size();len++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i+len<span class="hljs-number">-1</span>&lt;s.size();i++)&#123;<span class="hljs-keyword">int</span> j = i + len - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (s[i]==s[j]&amp;&amp;dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>])&#123;ans++;dp[i][j] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span>&#123;dp[i][j] = <span class="hljs-number">0</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> ans;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】1160. 拼写单词</title>
    <link href="/%E3%80%90leetcode%E3%80%911160-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D.html"/>
    <url>/%E3%80%90leetcode%E3%80%911160-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><font color=red size=5><br> 哈希表计数</font></br><br>对于一个单词<code>word</code>，只要其中的每个字母数量都不大于<code>chars</code>中对应的字母的数量，那么就可以用<code>chars</code>中的字母拼写出<code>word</code>。所以我们只需要用一个哈希表存储<code>chars</code>中每个字母的数量，再用一个哈希表存储<code>word</code>中每个字母的数量，最后将两个哈希表的键值逐一进行比较即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countCharacters</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words, <span class="hljs-built_in">string</span> chars)</span> </span>&#123;<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; charMap;<span class="hljs-comment">//存储chars字符串每个字符出现的次数</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars)&#123;charMap[c]++;&#125;<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;words.size();i++)&#123;<span class="hljs-comment">//存储word字符串每个字符出现的次数</span><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; wordMap;<span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c:words[i])&#123;wordMap[c]++;&#125;<span class="hljs-comment">//逐一比较</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c:words[i])&#123;<span class="hljs-keyword">if</span> (wordMap[c] &gt; charMap[c]) &#123;flag = <span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (flag) ans += words[i].size();&#125;<span class="hljs-keyword">return</span> ans;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】5. 最长回文子串</title>
    <link href="/%E3%80%90leetcode%E3%80%915-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html"/>
    <url>/%E3%80%90leetcode%E3%80%915-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="1、定义数组元素的含义-定义状态"><a href="#1、定义数组元素的含义-定义状态" class="headerlink" title="1、定义数组元素的含义/定义状态"></a>1、定义数组元素的含义/定义状态</h4><p><code>dp[i][j]</code>表示<code>S[i]</code>至<code>s[j]</code>所表示的子串是否是回文子串，是则为1，不是为0.</p><h4 id="2、找出数组间的关系式"><a href="#2、找出数组间的关系式" class="headerlink" title="2、找出数组间的关系式"></a>2、找出数组间的关系式</h4><div class="hljs"><pre><code class="hljs cpp">dp[i][j]=&#123;        dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>],S[i]==S[j]        <span class="hljs-number">0</span>,S[i]!=S[j]&#125;</code></pre></div><h4 id="3、找出初始值"><a href="#3、找出初始值" class="headerlink" title="3、找出初始值"></a>3、找出初始值</h4><p><code>dp[i][i]=1,dp[i][i+1]=(S[i]==S[i+1])?1:0</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<span class="hljs-built_in">string</span> ans;<span class="hljs-comment">//dp[i][j]:s[i]到s[j]之间所表示的字符串是否为回文子串</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(s.size()))</span></span>;<span class="hljs-comment">//初始化</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.size();i++)&#123;<span class="hljs-keyword">if</span> (ans.size() &lt; <span class="hljs-number">1</span>) ans = s[i];dp[i][i] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (i&lt;s.size()<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">if</span> (s[i] == s[i + <span class="hljs-number">1</span>])&#123;dp[i][i + <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (ans.size() &lt; <span class="hljs-number">2</span>) ans = s.substr(i, <span class="hljs-number">2</span>);&#125;&#125;&#125;<span class="hljs-comment">//状态转移</span><span class="hljs-comment">//从字符串长度及位置开始枚举，进行状态的转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len=<span class="hljs-number">3</span>;len&lt;=s.size();len++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i+len<span class="hljs-number">-1</span>&lt;s.size();i++)&#123;<span class="hljs-keyword">int</span> j = i + len - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (s[i] == s[j]&amp;&amp;dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]) &#123;<span class="hljs-comment">//两个字符相等，且s[i+1]与s[j-1]之间也为回文串</span>dp[i][j] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (ans.size() &lt; len) ans=s.substr(i, len);&#125;<span class="hljs-keyword">else</span>&#123;dp[i][j] = <span class="hljs-literal">false</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> ans;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】57. 和为s的两个数字</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9157-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9157-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>刚开始自己的想法，对数组进行遍历，取第一个数时，通过二分法来找<code>target-nums[i]</code>，但发现最终这样的代码超时，时间复杂度<code>O(nlogn)</code></p><p>改进的想法<br>使用双指针法，左指针指向最小元素，右指针指向最大元素，<br>比较两个指针所指元素的和与<code>target</code>的大小，如果相等，则说明找到，如果<code>sum&gt;target</code>，则左指针++，反之，右指针++</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size()<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span> (left&lt;right)&#123;sum = nums[left] + nums[right];<span class="hljs-keyword">if</span> (sum==target)&#123;ans.push_back(nums[left]);ans.push_back(nums[right]);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (sum &gt; target) right--;<span class="hljs-keyword">else</span> left++;&#125;<span class="hljs-keyword">return</span> ans;&#125;&#125;;</code></pre></div><h4 id="超时解法"><a href="#超时解法" class="headerlink" title="超时解法"></a>超时解法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)&#123;ans.push_back(nums[i]);<span class="hljs-keyword">if</span> (binarySearch(nums, target - nums[i])) &#123;ans.push_back(target - nums[i]);<span class="hljs-keyword">return</span> ans;&#125;ans.pop_back();&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums, <span class="hljs-keyword">int</span> t)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> right = nums.size() - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (left&lt;=right)&#123;<span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (nums[mid] == t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; t) &#123;<span class="hljs-comment">//向左找</span>right = mid - <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid]&lt;t)<span class="hljs-comment">//向右找</span>&#123;left = mid + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【程序员面试金典】17.16.按摩师</title>
    <link href="/%E3%80%90%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E3%80%9117-16-%E6%8C%89%E6%91%A9%E5%B8%88.html"/>
    <url>/%E3%80%90%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E3%80%9117-16-%E6%8C%89%E6%91%A9%E5%B8%88.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="一、定义数组元素的含义"><a href="#一、定义数组元素的含义" class="headerlink" title="一、定义数组元素的含义"></a>一、定义数组元素的含义</h4><p><code>dp[i]</code>:第i次预约时，按摩师总预约时间长</p><h4 id="二、找出关系数组元素间的关系式"><a href="#二、找出关系数组元素间的关系式" class="headerlink" title="二、找出关系数组元素间的关系式"></a>二、找出关系数组元素间的关系式</h4><p>第i次时，总预约时长，要么是从第i-2次接受预约后，本次也接受预约，要么本次不接受预约<br><code>dp[i] = max(dp[i - 2] + nums[i-1], dp[i - 1]);</code></p><h4 id="三、找出初始值"><a href="#三、找出初始值" class="headerlink" title="三、找出初始值"></a>三、找出初始值</h4><p>由题目可知，第1次接受预约时，总预约时长为<code>dp[1]=nums[0]</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">massage</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-keyword">if</span> (nums.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size() +<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//初始值</span>dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=nums.size();i++)&#123;dp[i] = max(dp[i - <span class="hljs-number">2</span>] + nums[i<span class="hljs-number">-1</span>], dp[i - <span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">return</span> dp[nums.size()];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>程序员面试金典</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【程序员面试金典】16.17.连续数列</title>
    <link href="/%E3%80%90%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E3%80%9116-17-%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%88%97.html"/>
    <url>/%E3%80%90%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E3%80%9116-17-%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%88%97.html</url>
    
    <content type="html"><![CDATA[<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-keyword">if</span> (nums.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">int</span> sum = dp[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.size();i++)&#123;dp[i] = max(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]);<span class="hljs-keyword">if</span> (dp[i] &gt; sum) sum = dp[i];&#125;<span class="hljs-keyword">return</span> sum;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>程序员面试金典</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【程序员面试金典】16.17.三步问题</title>
    <link href="/%E3%80%90%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E3%80%9116-17-%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98.html"/>
    <url>/%E3%80%90%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E3%80%9116-17-%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98.html</url>
    
    <content type="html"><![CDATA[<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">waysToStep</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">4</span>)</span></span>;dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;dp[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">4</span>;i&lt;=n;i++)&#123;dp[i] = ((dp[i - <span class="hljs-number">1</span>] % mod  + dp[i - <span class="hljs-number">2</span>] % mod ) % mod + dp[i - <span class="hljs-number">3</span>] % mod )%mod;&#125;<span class="hljs-keyword">return</span> dp[n];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>程序员面试金典</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】300. 最长上升子序列</title>
    <link href="/%E3%80%90leetcode%E3%80%91300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <url>/%E3%80%90leetcode%E3%80%91300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一、定义数组元素的含义<br><code>dp[i]</code>：到第i个元素的时最长子序列的长度<br>二、找出关系数组间的关系式</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (nums[i] &gt; nums[j])<span class="hljs-comment">//出现上升</span>&#123;dp[i] = max(dp[j] + <span class="hljs-number">1</span>, dp[i]);&#125;</code></pre></div><p>三、找出初始值<br><code>dp[i] = 1;</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//dp[i]：到第i个元素的时最长子序列的长度</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-keyword">if</span> (nums.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)&#123;dp[i] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<span class="hljs-comment">//将第i个元素与前j个元素一一比较</span>&#123;<span class="hljs-keyword">if</span> (nums[i] &gt; nums[j])<span class="hljs-comment">//出现上升</span>&#123;dp[i] = max(dp[j] + <span class="hljs-number">1</span>, dp[i]);&#125;&#125;&#125;<span class="hljs-keyword">return</span> *max_element(dp.begin(), dp.end());&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】1071. 字符串的最大公因子</title>
    <link href="/%E3%80%90leetcode%E3%80%911071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90.html"/>
    <url>/%E3%80%90leetcode%E3%80%911071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>枚举法<br>从<code>1~min(str1.length(), str2.length())</code>的范围枚举每个子串，对每个子串进行check，判断其是否属于将等于该字符串</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">gcdOfStrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str1, <span class="hljs-built_in">string</span> str2)</span> </span>&#123;<span class="hljs-keyword">if</span> (str1.empty() || str2.empty()) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = min(str1.length(), str2.length()); i &gt; <span class="hljs-number">0</span>; i--)&#123;<span class="hljs-keyword">if</span> (str1.length() % i == <span class="hljs-number">0</span> &amp;&amp; str2.length() % i == <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">string</span> temp = str1.substr(<span class="hljs-number">0</span>, i);<span class="hljs-keyword">if</span> (check(temp, str1) &amp;&amp; check(temp, str2)) &#123;<span class="hljs-keyword">return</span> temp;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-built_in">string</span> temp, <span class="hljs-built_in">string</span> str)</span> </span>&#123;<span class="hljs-keyword">int</span> count = str.size() / temp.size();<span class="hljs-built_in">string</span> x = <span class="hljs-string">""</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)&#123;x += temp;&#125;<span class="hljs-keyword">return</span> x==str;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】912. 排序数组</title>
    <link href="/%E3%80%90leetcode%E3%80%91912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.html"/>
    <url>/%E3%80%90leetcode%E3%80%91912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.html</url>
    
    <content type="html"><![CDATA[<h1 id="本道题目专用于练习排序算法，后续会补齐其他排序算法的代码"><a href="#本道题目专用于练习排序算法，后续会补齐其他排序算法的代码" class="headerlink" title="本道题目专用于练习排序算法，后续会补齐其他排序算法的代码"></a><strong><em>本道题目专用于练习排序算法，后续会补齐其他排序算法的代码</em></strong></h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">/*归并排序*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(nums.size())</span></span>;MergeSort(nums, temp, <span class="hljs-number">0</span>, nums.size() - <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> nums;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;temp,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (l&lt;r)&#123;<span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<span class="hljs-comment">//分</span>MergeSort(nums, temp, l, mid);<span class="hljs-comment">//分</span>MergeSort(nums, temp, mid + <span class="hljs-number">1</span>, r);<span class="hljs-comment">//治</span>Merge(nums, temp, l, mid, r);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; temp, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k=l;k &lt;= r;k++)<span class="hljs-comment">//将分的数组合并到nums中，</span>&#123;<span class="hljs-keyword">if</span> (i &gt; mid) &#123;<span class="hljs-comment">//此时左边部分已全部加入到temp中</span>temp[k] = nums[j++];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; r) &#123;<span class="hljs-comment">//此时右边部分已全部加入到temp中</span>temp[k] = nums[i++];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &lt; nums[j]) &#123;<span class="hljs-comment">//左边数组中的元素小于右边数组的元素</span>temp[k] = nums[i++];&#125;<span class="hljs-keyword">else</span>&#123;temp[k] = nums[j++];&#125;&#125;<span class="hljs-comment">//将temp中的元素赋值给nums中</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k=l;k&lt;=r;k++)&#123;nums[k] = temp[k];&#125;&#125;&#125;;</code></pre></div><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="分割操作，单向调整"><a href="#分割操作，单向调整" class="headerlink" title="分割操作，单向调整"></a>分割操作，单向调整</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;QuickSort(nums, <span class="hljs-number">0</span>, nums.size()<span class="hljs-number">-1</span>);<span class="hljs-keyword">return</span> nums;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (l&lt;r)&#123;<span class="hljs-keyword">int</span> mid = partition(nums, l, r);QuickSort(nums, l, mid<span class="hljs-number">-1</span>);<span class="hljs-comment">//注意点，l和r的值自己写错</span>QuickSort(nums, mid + <span class="hljs-number">1</span>, r);<span class="hljs-comment">//注意点,l和r的值自己写错</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//选取不同的主元，交换方式不一样，选取左主元，得从右向左遍历，且判断该pivot是否小于当前元素，小于则交换</span><span class="hljs-comment">//下面以右主元为例</span><span class="hljs-keyword">int</span> pivot = nums[r];<span class="hljs-comment">//两个指针,一者移动</span><span class="hljs-keyword">int</span> i = l, j = l,temp;<span class="hljs-comment">//遍历序列，找主元应该插入的位置</span><span class="hljs-keyword">for</span> (;j&lt;r;j++)&#123;<span class="hljs-comment">//交换</span><span class="hljs-keyword">if</span> (nums[j] &lt; pivot) &#123;temp = nums[i];nums[i] = nums[j];nums[j] = temp;i++;&#125;&#125;nums[r] = nums[i];nums[i] = pivot;<span class="hljs-keyword">return</span> i;<span class="hljs-comment">//返回分割位置</span>&#125;&#125;;</code></pre></div><h3 id="分割操作，双向调整"><a href="#分割操作，双向调整" class="headerlink" title="分割操作，双向调整"></a>分割操作，双向调整</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;QuickSort(nums, <span class="hljs-number">0</span>, nums.size() - <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> nums;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (l &lt; r)&#123;<span class="hljs-keyword">int</span> mid = partition(nums, l, r);QuickSort(nums, l, mid - <span class="hljs-number">1</span>);<span class="hljs-comment">//注意点，l和r的值自己写错</span>QuickSort(nums, mid + <span class="hljs-number">1</span>, r);<span class="hljs-comment">//注意点,l和r的值自己写错</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> pivot = nums[l];<span class="hljs-keyword">int</span> i = l + <span class="hljs-number">1</span>, j = r;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[i] &lt;= pivot) i++;<span class="hljs-comment">//寻找比pivot大的元素</span><span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[j] &gt;= pivot) j--;<span class="hljs-comment">//寻找比pivot小的元素</span><span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-keyword">break</span>;swap(nums[i], nums[j]);&#125;<span class="hljs-comment">//把arr[j]和主元交换</span>swap(nums[j], nums[l]);<span class="hljs-keyword">return</span> j;<span class="hljs-comment">//为什么返回j而不是i，因为swap是先执行i++的while语句，如果和下面的替换顺序，则返回i</span>&#125;&#125;;</code></pre></div><h3 id="分割操作，双向调整，加入随机函数"><a href="#分割操作，双向调整，加入随机函数" class="headerlink" title="分割操作，双向调整，加入随机函数"></a>分割操作，双向调整，加入随机函数</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;QuickSort(nums, <span class="hljs-number">0</span>, nums.size() - <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> nums;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (l &lt; r)&#123;<span class="hljs-keyword">int</span> partition = randomPartition(nums, l, r);QuickSort(nums, l, partition - <span class="hljs-number">1</span>);QuickSort(nums, partition + <span class="hljs-number">1</span>, r);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">randomPartition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i = (rand() % (r - l + <span class="hljs-number">1</span>)) + l;<span class="hljs-comment">//产生[a,b]的随机整数</span>swap(nums[i], nums[l]);<span class="hljs-keyword">return</span> partition(nums, l, r);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> pivot = nums[l];<span class="hljs-keyword">int</span> i = l + <span class="hljs-number">1</span>, j = r;<span class="hljs-comment">//双指针，分别指向首尾</span><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[i] &lt;= pivot) i++;<span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[j] &gt;= pivot) j--;<span class="hljs-keyword">if</span> (i &gt; j) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//交换位置</span>swap(nums[i], nums[j]);&#125;<span class="hljs-comment">//交换主元</span>swap(nums[j], nums[l]);<span class="hljs-keyword">return</span> j;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>SUM</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】395. 至少有K个重复字符的最长子串</title>
    <link href="/%E3%80%90leetcode%E3%80%91395-%E8%87%B3%E5%B0%91%E6%9C%89k%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html"/>
    <url>/%E3%80%90leetcode%E3%80%91395-%E8%87%B3%E5%B0%91%E6%9C%89k%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分治思想<br>先遍历一遍统计字符串S中每个字母出现的次数，然后再遍历一遍找到出现次数小于k的一个字母对应的位置(partition)，包含S[mid]的子串显然不可能符合题目要求，所以原问题求S[l,r]字符串对应的答案等价于求S[l,partition-1]和S[partition+1,r]；<br>此外，可以对一些情况进行优化，例如，当l和r所指字符已经不符合题目要求，可以跳过这些字符，以减少计算量。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="未改进代码"><a href="#未改进代码" class="headerlink" title="未改进代码"></a>未改进代码</h4><p>超时</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">int</span> k;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<span class="hljs-keyword">this</span>-&gt;k = k;<span class="hljs-keyword">return</span> cnt(s,<span class="hljs-number">0</span>,s.size()<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; ch;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= r; i++)<span class="hljs-comment">//统计每个字符出现的次数</span>&#123;ch[s[i]]++;&#125;<span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//此时该子串size小于k，不存在</span><span class="hljs-comment">//寻找分割位置</span><span class="hljs-comment">//如果在l和r和范围内遇到不满足&gt;=k的，即为分割位置</span><span class="hljs-keyword">int</span> partition = l;<span class="hljs-keyword">while</span> (partition&lt;=r&amp;&amp;ch[s[partition]]&gt;=k)&#123;partition++;&#125;<span class="hljs-keyword">if</span> (partition &gt; r) <span class="hljs-keyword">return</span> r - l+<span class="hljs-number">1</span>;<span class="hljs-comment">//分割位置不存在，说明此时的串符合要求</span><span class="hljs-comment">//存在分割位置，则取其左右子串两者的最大值</span><span class="hljs-keyword">return</span> max(cnt(s, l, partition - <span class="hljs-number">1</span>), cnt(s, partition + <span class="hljs-number">1</span>, r));&#125;&#125;;</code></pre></div><h4 id="改进代码"><a href="#改进代码" class="headerlink" title="改进代码"></a>改进代码</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">int</span> k;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<span class="hljs-keyword">this</span>-&gt;k = k;<span class="hljs-keyword">return</span> cnt(s,<span class="hljs-number">0</span>,s.size()<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; ch;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= r; i++)<span class="hljs-comment">//统计每个字符出现的次数</span>&#123;ch[s[i]]++;&#125;<span class="hljs-comment">//从左到右和从右到左分别跳过字符串中不符合的字符，直到遇到符合的字符位置为止</span><span class="hljs-keyword">while</span> (l&lt;=r&amp;&amp;ch[s[l]]&lt;k)&#123;l++;&#125;<span class="hljs-keyword">while</span> (l&lt;=r&amp;&amp;ch[s[r]]&lt;k)&#123;r--;&#125;<span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//此时该子串size小于k，不存在</span><span class="hljs-comment">//寻找分割位置</span><span class="hljs-comment">//如果在l和r和范围内遇到不满足&gt;=k的，即为分割位置</span><span class="hljs-keyword">int</span> partition = l;<span class="hljs-keyword">while</span> (partition&lt;=r&amp;&amp;ch[s[partition]]&gt;=k)&#123;partition++;&#125;<span class="hljs-keyword">if</span> (partition &gt;= r) <span class="hljs-keyword">return</span> r - l + <span class="hljs-number">1</span>;<span class="hljs-comment">//分割位置不存在，说明此时的串符合要求</span><span class="hljs-comment">//存在分割位置，则取其左右子串两者的最大值</span><span class="hljs-keyword">return</span> max(cnt(s, l, partition - <span class="hljs-number">1</span>), cnt(s, partition + <span class="hljs-number">1</span>, r));&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】1025. 除数博弈</title>
    <link href="/%E3%80%90leetcode%E3%80%911025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88.html"/>
    <url>/%E3%80%90leetcode%E3%80%911025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一 动态规划"></a>方法一 动态规划</h4><h5 id="第一步：定义数组元素的含义"><a href="#第一步：定义数组元素的含义" class="headerlink" title="第一步：定义数组元素的含义"></a>第一步：定义数组元素的含义</h5><p><code>dp[n]</code>:数字为n时，此时取数字者的游戏结果</p><h5 id="第二步：找出关系数组元素间的关系时"><a href="#第二步：找出关系数组元素间的关系时" class="headerlink" title="第二步：找出关系数组元素间的关系时"></a>第二步：找出关系数组元素间的关系时</h5><p>假设Alice的<code>dp[i]=false</code>;<br>如果Alice取某个数字后，能使得Bob一定为<code>false</code>，则此时Alice一定胜</p><h5 id="第三步：找出初始值"><a href="#第三步：找出初始值" class="headerlink" title="第三步：找出初始值"></a>第三步：找出初始值</h5><p>在<code>n=1</code>时，Alice先取，一定无法获胜<code>dp[1]=false</code>;<br>在<code>n=2</code>时，Alice先取，一定可以获胜 <code>dp[2]=true</code>;</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">divisorGame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(N+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//base case</span>dp[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;dp[<span class="hljs-number">2</span>] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;i&lt;=N;i++)&#123;dp[i] = <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<span class="hljs-keyword">if</span> ((i%j==<span class="hljs-number">0</span>)&amp;&amp;!dp[i-j])<span class="hljs-comment">//所取的数复合条件，且取完该数后，Bob在i-j数的游戏结果为false，则此时alice的游戏结果为true</span>&#123;dp[i] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[N];&#125;&#125;;</code></pre></div><h4 id="方法二-数学法"><a href="#方法二-数学法" class="headerlink" title="方法二 数学法"></a>方法二 数学法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">divisorGame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<span class="hljs-keyword">return</span> N%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】746. 使用最小花费爬楼梯</title>
    <link href="/%E3%80%90leetcode%E3%80%91746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html"/>
    <url>/%E3%80%90leetcode%E3%80%91746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="第一步：定义数组元素的含义"><a href="#第一步：定义数组元素的含义" class="headerlink" title="第一步：定义数组元素的含义"></a>第一步：定义数组元素的含义</h4><p>题目的要求的是爬到楼层顶部需要的最低花费。因此可将<code>dp</code>定义为，<strong>到达第n阶台阶时的最低花费<code>dp[i]</code></strong><br>由于最终要到达的是楼顶，所以此处<code>dp</code>的<code>size</code>为<code>cost</code>的<code>size+1</code>。</p><h4 id="第二步：找出关系数组元素间的关系式"><a href="#第二步：找出关系数组元素间的关系式" class="headerlink" title="第二步：找出关系数组元素间的关系式"></a>第二步：找出关系数组元素间的关系式</h4><p>要到达下一阶，可以走一步，也可以走两步，要到达位置<code>i</code>，<br>一种是从<code>i-1</code>这个位置走一步到达<br>一种是从<code>i-2</code>这个位置走一步到达<br>因为是要计算走到<code>i</code>位置时，花费最小，要取上述两种情况中的最小者，此处<code>cost[i]</code>表示的是到达i+1/i+2阶所需要的体力花费值，所以到达了i-1/i-2阶后，再到达i阶台阶要花费的最小力气关系式是<code>dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])</code></p><h4 id="第三步：找出初始值"><a href="#第三步：找出初始值" class="headerlink" title="第三步：找出初始值"></a>第三步：找出初始值</h4><p>由题目可知，在开始时，我们可以从索引0或者1的元素作为初始阶梯，因此初始值为<code>dp[0]=0</code>和<code>dp[1]=0</code></p><p>另外需要注意的是对特殊情况的判断</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; cost)</span> </span>&#123;<span class="hljs-comment">//特判</span><span class="hljs-keyword">if</span> (cost.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (cost.size() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> cost[<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span> (cost.size() == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> min(cost[<span class="hljs-number">0</span>], cost[<span class="hljs-number">1</span>]);<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size()+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//初始值</span>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=cost.size();i++)&#123;dp[i] = min(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);&#125;<span class="hljs-keyword">return</span> dp[cost.size()];&#125;&#125;;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】72. 编辑距离</title>
    <link href="/%E3%80%90leetcode%E3%80%9172-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html"/>
    <url>/%E3%80%90leetcode%E3%80%9172-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="第一步：定义数组元素的含义"><a href="#第一步：定义数组元素的含义" class="headerlink" title="第一步：定义数组元素的含义"></a>第一步：定义数组元素的含义</h4><p><strong>当字符串<code>word1</code>的长度为i，字符串<code>word2</code>的长度为j时，将<code>word1</code>转化为<code>word2</code>所使用的最少操作次数为<code>dp[i][j]</code></strong><br><em>这句定义可以说使理解这道题目的核心，一定要理解dp数组的含义，这样才会理解关系式是如何得出的</em></p><h4 id="第二步：找出关系数组元素间的关系时"><a href="#第二步：找出关系数组元素间的关系时" class="headerlink" title="第二步：找出关系数组元素间的关系时"></a>第二步：找出关系数组元素间的关系时</h4><p>我们的目标是，从规模小的，通过一些操作，推导出规模大的。对于这道题，对<code>word1</code>进行三种操作<br>插入、删除、替换<br>由于我们是要让操作的次数最小，所以我们要寻找最佳操作<br>2.2 当<code>word1[i]```与`word[j]</code>相等，这个时候不需要任何操作，此时最少操作次数<code>dp[i][j]=dp[i-1][j-1]</code><br>2.3 如果不相等，此时有三种操作</p><ul><li>2.3.1 如果实行插入<code>dp[i][j]=dp[i][j-1]+1</code>;</li><li>2.3.2 如果实行删除<code>dp[i][j]=dp[i-1][j]+1</code>;</li><li>2.3.3 如果实行替换<code>dp[i][j]=dp[i-1][j-1]+1</code>;<h4 id="第三步：找出初始值"><a href="#第三步：找出初始值" class="headerlink" title="第三步：找出初始值"></a>第三步：找出初始值</h4>如果i或者<code>j</code>有一个为0，则<code>word1</code>要么一直插入<code>(i==0)</code>，要么一直删除<code>(j==0)</code>，才能到达<code>word2</code></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word1, <span class="hljs-built_in">string</span> word2)</span> </span>&#123;<span class="hljs-keyword">int</span> n1 = word1.length();<span class="hljs-keyword">int</span> n2 = word2.length();<span class="hljs-comment">//特判</span><span class="hljs-comment">//if (n1*n2==0) return n1+n2;</span><span class="hljs-comment">//定义数组元素的含义</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n1+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n2+<span class="hljs-number">1</span>))</span></span>;<span class="hljs-comment">//初始值</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n2; j++)<span class="hljs-comment">//插入</span>&#123;dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++)<span class="hljs-comment">//删除</span>&#123;dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n1; i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n2; j++)&#123;<span class="hljs-keyword">if</span> (word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>]) &#123;dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">else</span>&#123;dp[i][j] = min(dp[i - <span class="hljs-number">1</span>][j], min(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<span class="hljs-comment">//删除、插入、替换</span>&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[n1][n2];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】64. 最小路径和</title>
    <link href="/%E3%80%90leetcode%E3%80%9164-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.html"/>
    <url>/%E3%80%90leetcode%E3%80%9164-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="第一步：定义数组元素的含义"><a href="#第一步：定义数组元素的含义" class="headerlink" title="第一步：定义数组元素的含义"></a>第一步：定义数组元素的含义</h4><p>题目的要求的是到达网格的右下角，路径上的数字和为最小。因此可将<code>dp</code>定义为，<strong>当走到(i,j)这个位置时，路径数字和最小为<code>dp[i][j]</code></strong></p><h4 id="第二步：找出关系数组元素间的关系时"><a href="#第二步：找出关系数组元素间的关系时" class="headerlink" title="第二步：找出关系数组元素间的关系时"></a>第二步：找出关系数组元素间的关系时</h4><p>要到达右下角，可以往下走，也可以往右走，要到达位置<code>(i,j)</code>，<br>一种是从<code>(i-1,j)</code>这个位置走一步到达<br>一种是从<code>(i,j-1)</code>这个位置走一步到达<br>因为是要计算走到<code>(i,j)</code>位置时，数字和要为最小，所以是要取上述两种情况中的最小者，所以关系式是<code>dp[i][j]=min(dp[i][j-1],dp[i-1][j])+grid[i][j];</code></p><h4 id="第三步：找出初始值"><a href="#第三步：找出初始值" class="headerlink" title="第三步：找出初始值"></a>第三步：找出初始值</h4><p><code>dp[i][j]</code>中，如果i或者j有一个为0，那么就不能用关系式了，因为这个时候i-1或者j-1就变成负数了，数组就会出问题，所以我们的初始值是计算出所有的<code>dp[0][0...n-1]</code>和所有的<code>dp[0...m-1][0]</code>。初始值如下<br><code>i=0,j=0,dp[0][0]=num[0][0]</code>//起点(0,0)<br><code>i=0,dp[0][j]=dp[0][j-1]+grid[0][j];</code> // 相当于最上面一行，只能一直往左走<br><code>j=0,dp[i][0]=dp[i-1][0]+grid[i][0]</code> // 相当于最左面一列，只能一直往下走</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//1、走到(i,j)这个位置时，路径上的最小数字和为dp[i][j]</span><span class="hljs-comment">//2、dp[i][j]=min(dp[i][j-1],dp[i-1][j])+grid[i][j];</span><span class="hljs-comment">//3、i=0,j=0,dp[0][0]=num[0][0]</span><span class="hljs-comment">//  i=0,dp[0][j]=dp[0][j-1]+grid[0][j]</span><span class="hljs-comment">//  j=0,dp[i][0]=dp[i-1][0]+grid[i][0]</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(grid.size(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(grid[<span class="hljs-number">0</span>].size))</span></span>;<span class="hljs-comment">//Base case</span>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;grid[<span class="hljs-number">0</span>].size();j++)&#123;dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;grid.size();i++)&#123;dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;grid.size();i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;grid[<span class="hljs-number">0</span>].size();j++)&#123;dp[i][j] = min(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]) + grid[i][j];&#125;&#125;<span class="hljs-keyword">return</span> dp[dp.size() - <span class="hljs-number">1</span>][dp[<span class="hljs-number">0</span>].size() - <span class="hljs-number">1</span>];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】62. 不同路径</title>
    <link href="/%E3%80%90leetcode%E3%80%9162-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html"/>
    <url>/%E3%80%90leetcode%E3%80%9162-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="第一步：定义数组元素的含义"><a href="#第一步：定义数组元素的含义" class="headerlink" title="第一步：定义数组元素的含义"></a>第一步：定义数组元素的含义</h4><p>题目的要求的是机器人到达网格的右下角，总共有多少条不同的路径。因此可将<code>dp</code>定义为，<strong>当机器人走到(i,j)这个位置时，一共有<code>dp[i][j]</code>条路径</strong></p><h4 id="第二步：找出关系数组元素间的关系时"><a href="#第二步：找出关系数组元素间的关系时" class="headerlink" title="第二步：找出关系数组元素间的关系时"></a>第二步：找出关系数组元素间的关系时</h4><p>机器人要到达右下角，可以往下走，也可以往右走，要到达位置<code>(i,j)</code>，<br>一种是从<code>(i-1,j)</code>这个位置走一步到达<br>一种是从<code>(i,j-1)</code>这个位置走一步到达<br>因为是要计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是<code>dp[i][j]=dp[i-1][j]+dp[i][j-1]</code></p><h4 id="第三步：找出初始值"><a href="#第三步：找出初始值" class="headerlink" title="第三步：找出初始值"></a>第三步：找出初始值</h4><p><code>dp[i][j]</code>中，如果i或者j有一个为0，那么就不能用关系式了，因为这个时候i-1或者j-1就变成负数了，数组就会出问题，所以我们的初始值是计算出所有的<code>dp[0][0...n-1]</code>和所有的<code>dp[0...m-1][0]</code>。这个是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下<br><code>dp[0] [0….n-1] = 1;</code> // 相当于最上面一行，机器人只能一直往左走<br><code>dp[0…m-1] [0] = 1;</code> // 相当于最左面一列，机器人只能一直往下走</p><h3 id="代码（自底向上）"><a href="#代码（自底向上）" class="headerlink" title="代码（自底向上）"></a>代码（自底向上）</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-comment">//定义数组元素的含义</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n))</span></span>;<span class="hljs-comment">//初始化</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<span class="hljs-comment">//dp[0][j]=dp[0][j-1]</span>&#123;dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<span class="hljs-comment">//dp[i][0]=dp[i][0]</span>&#123;dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];&#125;&#125;<span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】322. 零钱兑换</title>
    <link href="/%E3%80%90leetcode%E3%80%91322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html"/>
    <url>/%E3%80%90leetcode%E3%80%91322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>dp[n]:当前的目标金额是n，至少需要dp[n]个金币凑出该金额<br>初始值，dp[0]=0,目标金额为0，需要0个金币<br>状态转移，dp[money] = min(dp[money], dp[money - coin] + 1);<br>当前需要金币个数，等于dp[money-coin]+1个与dp[money]的小者</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//动态规划-迭代</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<span class="hljs-comment">//初始化dp数组</span><span class="hljs-comment">//初始值为amount+1是因为，amount+1将是硬币个数的最大值，所以可以用此数值</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, amount + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//base case </span>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> money = <span class="hljs-number">1</span>; money &lt;= amount; money++)<span class="hljs-comment">//内层for求所有子问题+1的最小值</span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins)&#123;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">if</span> (money - coin &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//当前的钱数比硬币的面额大，才能选择这种硬币</span>dp[money] = min(dp[money], dp[money - coin] + <span class="hljs-number">1</span>);&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[amount] == amount + <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : dp[amount];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【OpenGL】绘制球体</title>
    <link href="/%E3%80%90opengl%E3%80%91%E7%BB%98%E5%88%B6%E7%90%83%E4%BD%93.html"/>
    <url>/%E3%80%90opengl%E3%80%91%E7%BB%98%E5%88%B6%E7%90%83%E4%BD%93.html</url>
    
    <content type="html"><![CDATA[<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="1-初始化："><a href="#1-初始化：" class="headerlink" title="1-初始化："></a>1-初始化：</h4><p> GLFW窗口，GLAD</p><h4 id="2-计算球体顶点："><a href="#2-计算球体顶点：" class="headerlink" title="2-计算球体顶点："></a>2-计算球体顶点：</h4><p>通过数学方法计算球体的每个顶点坐标</p><h4 id="3-数据处理："><a href="#3-数据处理：" class="headerlink" title="3-数据处理："></a>3-数据处理：</h4><p> 通过球体顶点坐标构造三角形网络，生成并绑定VAO&amp;VBO&amp;EBO（准备再GPU中进行处理)，设置顶点属性指针（本质上就是告诉OpenGL如何处理数据）</p><h4 id="4-着色器："><a href="#4-着色器：" class="headerlink" title="4-着色器："></a>4-着色器：</h4><p>给出顶点和片段着色器，然后链接为着色器程序，渲染时使用着色器程序</p><h4 id="5-渲染："><a href="#5-渲染：" class="headerlink" title="5-渲染："></a>5-渲染：</h4><p>使用画线模式画圆，开启面剔除，剔除背面，使用线框模式画球,清空缓冲，交换缓冲区检查触发事件</p><h4 id="6-结束："><a href="#6-结束：" class="headerlink" title="6-结束："></a>6-结束：</h4><p>释放资源</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><h4 id="填充模式和线框模式效果对比"><a href="#填充模式和线框模式效果对比" class="headerlink" title="填充模式和线框模式效果对比"></a>填充模式和线框模式效果对比</h4><div align=center><img src="https://img-blog.csdnimg.cn/20200306183123169.png" srcset="/img/loading.gif" width=400 height=400><img src="https://img-blog.csdnimg.cn/20200306183442280.png" srcset="/img/loading.gif" width=400 height=400></div><h4 id="开启面剔除和线框模式效果对比"><a href="#开启面剔除和线框模式效果对比" class="headerlink" title="开启面剔除和线框模式效果对比"></a>开启面剔除和线框模式效果对比</h4><p>只需要展示一个面，否则会有重合，此处剔除背面为例</p><div align=center><img src="https://img-blog.csdnimg.cn/20200306183708962.png" srcset="/img/loading.gif" width=400 height=400><img src="https://img-blog.csdnimg.cn/20200306183442280.png" srcset="/img/loading.gif" width=400 height=400></div><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>此处只给出main.cpp,具体工程参考<a href="">本人的github</a></p><h5 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><span class="hljs-comment">步骤：</span><span class="hljs-comment">1-初始化： GLFW窗口，GLAD</span><span class="hljs-comment">2-计算球体顶点：通过数学方法计算球体的每个顶点坐标</span><span class="hljs-comment">3-数据处理： 通过球体顶点坐标构造三角形网络，生成并绑定VAO&amp;VBO&amp;EBO（准备再GPU中进行处理)，设置顶点属性指针（本质上就是告诉OpenGL如何处理数据）</span><span class="hljs-comment">4-着色器：给出顶点和片段着色器，然后链接为着色器程序，渲染时使用着色器程序</span><span class="hljs-comment">5-渲染：使用画线模式画圆，开启面剔除，剔除背面，使用线框模式画球,清空缓冲，交换缓冲区检查触发事件</span><span class="hljs-comment">6-结束：释放资源</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glad/glad.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GLFW/glfw3.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Shader.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> screen_width = <span class="hljs-number">780</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> screen_height = <span class="hljs-number">780</span>;<span class="hljs-keyword">const</span> GLfloat PI= <span class="hljs-number">3.14159265358979323846f</span>;<span class="hljs-comment">//将球横纵划分成50*50的网格</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Y_SEGMENTS = <span class="hljs-number">50</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> X_SEGMENTS = <span class="hljs-number">50</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*1-初始化*/</span><span class="hljs-comment">//初始化GLFW</span>glfwInit();<span class="hljs-comment">//初始化GLFW</span>glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);<span class="hljs-comment">//opengl版本号3.3</span>glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);<span class="hljs-comment">// 次版本号3</span>glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="hljs-comment">//使用核心模式(无序向后兼容性)</span>glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);<span class="hljs-comment">//如果使用的是Mac OS X系统，需加上这行</span>glfwWindowHint(GLFW_RESIZABLE, <span class="hljs-literal">false</span>);<span class="hljs-comment">//不可改变窗口大小</span><span class="hljs-comment">//创建窗口（宽、高、窗口名称）</span><span class="hljs-keyword">auto</span> window = glfwCreateWindow(screen_width, screen_height,<span class="hljs-string">"Sphere"</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<span class="hljs-comment">//检测窗口是否创建成功</span><span class="hljs-keyword">if</span> (window==<span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to Create OpenGL Context"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;glfwTerminate();<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;glfwMakeContextCurrent(window);<span class="hljs-comment">//将窗口的上下文设置为当前进程的主上下文</span><span class="hljs-comment">//初始化GLAD，加载OpenGL指针地址的函数</span><span class="hljs-keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Failed to initialize GLAD"</span>&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-comment">//指定当前视口尺寸（前两个参数为左下角位置，后两个参数是渲染窗口宽、高）</span>glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, screen_width, screen_height);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">float</span>&gt; sphereVertices;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sphereIndices;<span class="hljs-comment">/*2-计算球体顶点*/</span><span class="hljs-comment">//生成球的顶点</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>;y&lt;=Y_SEGMENTS;y++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x&lt;=X_SEGMENTS;x++)&#123;<span class="hljs-keyword">float</span> xSegment = (<span class="hljs-keyword">float</span>)x / (<span class="hljs-keyword">float</span>)X_SEGMENTS;<span class="hljs-keyword">float</span> ySegment = (<span class="hljs-keyword">float</span>)y / (<span class="hljs-keyword">float</span>)Y_SEGMENTS;<span class="hljs-keyword">float</span> xPos = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cos</span>(xSegment * <span class="hljs-number">2.0f</span> * PI) * <span class="hljs-built_in">std</span>::<span class="hljs-built_in">sin</span>(ySegment * PI);<span class="hljs-keyword">float</span> yPos = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cos</span>(ySegment * PI);<span class="hljs-keyword">float</span> zPos = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">sin</span>(xSegment * <span class="hljs-number">2.0f</span> * PI) * <span class="hljs-built_in">std</span>::<span class="hljs-built_in">sin</span>(ySegment * PI);sphereVertices.push_back(xPos);sphereVertices.push_back(yPos);sphereVertices.push_back(zPos);&#125;&#125;<span class="hljs-comment">//生成球的Indices</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;Y_SEGMENTS;i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;X_SEGMENTS;j++)&#123;sphereIndices.push_back(i * (X_SEGMENTS + <span class="hljs-number">1</span>) + j);sphereIndices.push_back((i + <span class="hljs-number">1</span>) * (X_SEGMENTS + <span class="hljs-number">1</span>) + j);sphereIndices.push_back((i + <span class="hljs-number">1</span>) * (X_SEGMENTS + <span class="hljs-number">1</span>) + j+<span class="hljs-number">1</span>);sphereIndices.push_back(i* (X_SEGMENTS + <span class="hljs-number">1</span>) + j);sphereIndices.push_back((i + <span class="hljs-number">1</span>) * (X_SEGMENTS + <span class="hljs-number">1</span>) + j + <span class="hljs-number">1</span>);sphereIndices.push_back(i * (X_SEGMENTS + <span class="hljs-number">1</span>) + j + <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-comment">/*3-数据处理*/</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> VBO, VAO;glGenVertexArrays(<span class="hljs-number">1</span>, &amp;VAO);glGenBuffers(<span class="hljs-number">1</span>, &amp;VBO);<span class="hljs-comment">//生成并绑定球体的VAO和VBO</span>glBindVertexArray(VAO);glBindBuffer(GL_ARRAY_BUFFER, VBO);<span class="hljs-comment">//将顶点数据绑定至当前默认的缓冲中</span>glBufferData(GL_ARRAY_BUFFER, sphereVertices.size() * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), &amp;sphereVertices[<span class="hljs-number">0</span>], GL_STATIC_DRAW);GLuint element_buffer_object;<span class="hljs-comment">//EBO</span>glGenBuffers(<span class="hljs-number">1</span>, &amp;element_buffer_object);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, element_buffer_object);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sphereIndices.size() * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), &amp;sphereIndices[<span class="hljs-number">0</span>], GL_STATIC_DRAW);<span class="hljs-comment">//设置顶点属性指针</span>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);glEnableVertexAttribArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//解绑VAO和VBO</span>glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);glBindVertexArray(<span class="hljs-number">0</span>);<span class="hljs-comment">/*4-着色器*/</span><span class="hljs-function">Shader <span class="hljs-title">shader</span><span class="hljs-params">(<span class="hljs-string">"task3.vs"</span>, <span class="hljs-string">"task3.fs"</span>)</span></span>;<span class="hljs-comment">/*5-渲染*/</span><span class="hljs-comment">//渲染循环</span><span class="hljs-keyword">while</span> (!glfwWindowShouldClose(window))&#123;<span class="hljs-comment">//清空颜色缓冲</span>glClearColor(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.34f</span>, <span class="hljs-number">0.57f</span>, <span class="hljs-number">1.0f</span>);glClear(GL_COLOR_BUFFER_BIT);shader.Use();<span class="hljs-comment">//绘制球</span><span class="hljs-comment">//开启面剔除(只需要展示一个面，否则会有重合)</span>glEnable(GL_CULL_FACE);glCullFace(GL_BACK);glBindVertexArray(VAO);<span class="hljs-comment">//使用线框模式绘制</span>glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);glDrawElements(GL_TRIANGLES, X_SEGMENTS * Y_SEGMENTS * <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<span class="hljs-comment">//点阵模式绘制</span><span class="hljs-comment">//glPointSize(5);</span><span class="hljs-comment">//glDrawElements(GL_POINTS, X_SEGMENTS * Y_SEGMENTS * 6, GL_UNSIGNED_INT, 0);</span><span class="hljs-comment">//交换缓冲并且检查是否有触发事件(比如键盘输入、鼠标移动)</span>glfwSwapBuffers(window);glfwPollEvents();&#125;<span class="hljs-comment">/*6-结束*/</span><span class="hljs-comment">//删除VAO和VBO，EBO</span>glDeleteVertexArrays(<span class="hljs-number">1</span>, &amp;VAO);glDeleteBuffers(<span class="hljs-number">1</span>, &amp;VBO);glDeleteBuffers(<span class="hljs-number">1</span>, &amp;element_buffer_object);<span class="hljs-comment">//清理所有的资源并正确退出程序</span>glfwTerminate();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>MOOC-计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C/C++】C/C++头文件的引用格式</title>
    <link href="/%E3%80%90c-c-%E3%80%91c-c-%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%BC%95%E7%94%A8%E6%A0%BC%E5%BC%8F.html"/>
    <url>/%E3%80%90c-c-%E3%80%91c-c-%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%BC%95%E7%94%A8%E6%A0%BC%E5%BC%8F.html</url>
    
    <content type="html"><![CDATA[<h4 id="include-lt-gt"><a href="#include-lt-gt" class="headerlink" title="#include&lt;&gt;"></a>#include&lt;&gt;</h4><p>1.在编译器设置的include路径内搜索；<br>2.如果是在命令行中编译，则在系统的INCLUDE环境变量内搜索。</p><h4 id="include””"><a href="#include””" class="headerlink" title="#include””"></a>#include””</h4><p>1.在包含当前include指令的文件所在的文件夹内搜索；<br>2.如果上一步找不到，则在之前已经使用include指令打开过的文件所在的文件夹内搜索，如果已经有多个被include的文件，则按照它们被打开的相反顺序去搜索；<br>3.如果上一步找不到，则在编译器设置的include路径内搜索；<br>4.如果上一步找不到，则在系统的include环境变量内搜索。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、使用<code>#include&lt;&gt;</code> 程序会直接到标准函数库中找文件<br>2、使用<code>#include&quot;&quot;</code> 程序会会先从当前目录中找文件，如果找不到会再到标准函数库中找文件。所以，一般情况下我们引用标准函数库中的头文件时，用#include&lt;&gt;能有更高的效率。<br>3、另外，要注意的一点就是，<strong>如果我们自己写的头文件，而不是标准库函数中的，那么引用这个头文件要使用<code>#include&quot;&quot;</code>，而不能使用<code>#include&lt;&gt;</code></strong>，因为我们<strong>自己写的头文件并不在编译器设置的路径内</strong>，使用<code>#include&lt;&gt;</code>会提示无法找到。</p>]]></content>
    
    
    <categories>
      
      <category>【被·技】C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【OpenGL】绘制四边形</title>
    <link href="/%E3%80%90opengl%E3%80%91%E7%BB%98%E5%88%B6%E5%9B%9B%E8%BE%B9%E5%BD%A2.html"/>
    <url>/%E3%80%90opengl%E3%80%91%E7%BB%98%E5%88%B6%E5%9B%9B%E8%BE%B9%E5%BD%A2.html</url>
    
    <content type="html"><![CDATA[<h3 id="EBO、VBO和VAO的简介"><a href="#EBO、VBO和VAO的简介" class="headerlink" title="EBO、VBO和VAO的简介"></a>EBO、VBO和VAO的简介</h3><p><img src="https://img-blog.csdnimg.cn/20200305224816650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200305224826602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200305224838148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200305224858755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>画一个四边形，可以有两种方法</p><p>1、通过2个三角形拼接而成，这就和前一个实验画三角形类似，利用VAO和VBO实验，我们要做的只是需要把给出的顶点增加为6个即可。</p><p>2、但是我们会发现使用上述方式，会有两个顶点我们使用了两次，一个矩形只有四个顶点，如果是大量的复杂模型计算就会产生很大浪费。如何解决这个问题呢？其实我们只要存储矩形的四个顶点，然后指定绘制顺序就好了，EBO帮助我们实现了这个功能。这种方式我们可以称之为<font color=red><strong>索引绘制</strong></font>。</p><p>定义不重复的顶点及索引数据如下：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//四边形的顶点数据</span><span class="hljs-keyword">float</span> vertices[] = &#123;<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//右上</span><span class="hljs-number">0.5f</span>,<span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//右下</span><span class="hljs-number">-0.5f</span>,<span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//左下</span><span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.0f</span><span class="hljs-comment">//左上</span>&#125;;<span class="hljs-comment">//索引数据（注意这里是从0开始的）</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> indices[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-comment">//第一个三角形</span><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><span class="hljs-comment">//第二个三角形</span>&#125;;</code></pre></div><p>创建索引缓冲对象如下：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//生成并绑定EBO</span>GLuint element_buffer_object;<span class="hljs-comment">//EBO</span>glGenBuffers(<span class="hljs-number">1</span>, &amp;element_buffer_object);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, element_buffer_object);<span class="hljs-comment">//将索引数据绑定至EBO中</span>glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</code></pre></div><p><font color=red>下面介绍通过<code>VAO+VBO+EBO</code>的形式画一个四边形</font>，<code>VAO+VBO</code>的方法同该过程，两种方法的代码都将在后面贴出</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h5 id="1-初始化："><a href="#1-初始化：" class="headerlink" title="1-初始化："></a>1-初始化：</h5><p>初始化GLFW，创建窗口，初始化GLAD，创建视口</p><h5 id="2-数据处理："><a href="#2-数据处理：" class="headerlink" title="2-数据处理："></a>2-数据处理：</h5><p>给定顶点数据，生成并绑定VAO、VBO、EBO（准备在GPU中进行处理），设置顶点属性指针（本质上就是告诉OpenGL如何处理数据）。</p><h5 id="3-着色器："><a href="#3-着色器：" class="headerlink" title="3-着色器："></a>3-着色器：</h5><p>给出顶点和片段着色器，然后链接为着色器程序，渲染时使用着色器程序。</p><h5 id="4-渲染："><a href="#4-渲染：" class="headerlink" title="4-渲染："></a>4-渲染：</h5><p>清空缓冲，使用着色器程序，绘制三角形，交换缓冲区并检查触发事件（比如键盘移动、鼠标移动）</p><h5 id="5-释放资源："><a href="#5-释放资源：" class="headerlink" title="5-释放资源："></a>5-释放资源：</h5><p>删除VAO、VBO、EBO，调用GLFW的函数来清理所有的资源并退出程序</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://img-blog.csdnimg.cn/20200305225149303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>开启线框模式的效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305223713257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在配置好基本的OpenGL环境下，可直接运行</p><h4 id="VAO-VBO-EBO"><a href="#VAO-VBO-EBO" class="headerlink" title="VAO+VBO+EBO"></a>VAO+VBO+EBO</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glad/glad.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GLFW/glfw3.h&gt;</span></span><span class="hljs-comment">//四边形的顶点数据</span><span class="hljs-keyword">float</span> vertices[] = &#123;<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//右上</span><span class="hljs-number">0.5f</span>,<span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//右下</span><span class="hljs-number">-0.5f</span>,<span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//左下</span><span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.0f</span><span class="hljs-comment">//左上</span>&#125;;<span class="hljs-comment">//索引数据（注意这里是从0开始的）</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> indices[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-comment">//第一个三角形</span><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><span class="hljs-comment">//第二个三角形</span>&#125;;<span class="hljs-comment">//屏幕宽、高</span><span class="hljs-keyword">int</span> screen_width = <span class="hljs-number">1280</span>;<span class="hljs-keyword">int</span> screen_height = <span class="hljs-number">720</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*初始化*/</span>glfwInit();<span class="hljs-comment">//初始化glfw</span>glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);<span class="hljs-comment">//OpenGl版本为3.3，主次版本号均为3</span>glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="hljs-comment">//使用核心模式（无需向后兼容性）</span>glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);<span class="hljs-comment">//如果使用的是Mac OS X系统，需加上这行</span>glfwWindowHint(GLFW_RESIZABLE,<span class="hljs-literal">false</span>);<span class="hljs-comment">//不可改变窗口大小</span><span class="hljs-comment">//创建窗口（宽，高，窗口名称）</span><span class="hljs-keyword">auto</span> window = glfwCreateWindow(screen_width, screen_height, <span class="hljs-string">"Quad"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<span class="hljs-keyword">if</span> (window==<span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//如果窗口创建失败，输出报错信息</span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to Create OpenGL Context"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;glfwTerminate();<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;glfwMakeContextCurrent(window);<span class="hljs-comment">//将窗口的上下文设置为当前线程的上下文</span><span class="hljs-comment">//初始化GLAD,加载OpenGL函数指针地址的函数</span><span class="hljs-keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-comment">//指定当前视口尺寸（前两个参数为左下角位置，后两个参数是渲染窗口宽、高）</span>glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, screen_width, screen_height);<span class="hljs-comment">/*数据处理*/</span><span class="hljs-comment">//生成并绑定VAO和VBO</span>GLuint vertex_array_object;<span class="hljs-comment">//VAO</span>glGenVertexArrays(<span class="hljs-number">1</span>, &amp;vertex_array_object);glBindVertexArray(vertex_array_object);GLuint vertex_buffer_object;<span class="hljs-comment">//VBO</span>glGenBuffers(<span class="hljs-number">1</span>, &amp;vertex_buffer_object);glBindBuffer(GL_ARRAY_BUFFER,vertex_buffer_object);<span class="hljs-comment">//将顶点数据绑定至VBO中</span>glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices),vertices, GL_STATIC_DRAW);<span class="hljs-comment">//生成并绑定EBO</span>GLuint element_buffer_object;<span class="hljs-comment">//EBO</span>glGenBuffers(<span class="hljs-number">1</span>, &amp;element_buffer_object);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, element_buffer_object);<span class="hljs-comment">//将索引数据绑定至EBO中</span>glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);<span class="hljs-comment">//设置顶点属性指针</span>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT,GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>),(<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);glEnableVertexAttribArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//开启0通道，默认不开启</span><span class="hljs-comment">//解绑VAO和VBO</span>glBindVertexArray(<span class="hljs-number">0</span>);glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<span class="hljs-comment">/*着色器*/</span><span class="hljs-comment">//顶点着色器和片段着色器源码</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* vertex_shader_source =<span class="hljs-string">"#version 330 core\n"</span><span class="hljs-string">"layout (location=0) in vec3 aPos;\n"</span><span class="hljs-comment">//位置变量的属性位置值为0</span><span class="hljs-string">"void main()\n"</span><span class="hljs-string">"&#123;\n"</span><span class="hljs-string">"gl_Position=vec4(aPos,1.0);\n"</span><span class="hljs-string">"&#125;\n\0"</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fragment_shader_source =<span class="hljs-string">"#version 330 core\n"</span><span class="hljs-string">"out vec4 FragColor;\n"</span><span class="hljs-comment">//输出的颜色向量</span><span class="hljs-string">"void main()\n"</span><span class="hljs-string">"&#123;\n"</span><span class="hljs-string">"  FragColor=vec4(1.0f,0.5f,0.2f,1.0f);\n"</span><span class="hljs-string">"&#125;\n\0"</span>;<span class="hljs-comment">//生成并编译着色器</span><span class="hljs-comment">//顶点着色器</span><span class="hljs-keyword">int</span> vertex_shader = glCreateShader(GL_VERTEX_SHADER);glShaderSource(vertex_shader, <span class="hljs-number">1</span>, &amp;vertex_shader_source, <span class="hljs-literal">nullptr</span>);glCompileShader(vertex_shader);<span class="hljs-keyword">int</span> success;<span class="hljs-keyword">char</span> info_log[<span class="hljs-number">512</span>];<span class="hljs-comment">//检查着色器是否成功编译，如果编译失败，打印错误信息</span>glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &amp;success);<span class="hljs-keyword">if</span> (!success)&#123;glGetShaderInfoLog(vertex_shader, <span class="hljs-number">512</span>, <span class="hljs-literal">nullptr</span>, info_log);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//片段着色器</span><span class="hljs-keyword">int</span> fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragment_shader, <span class="hljs-number">1</span>, &amp;fragment_shader_source, <span class="hljs-literal">nullptr</span>);glCompileShader(fragment_shader);<span class="hljs-comment">//检查着色器是否成功编译，如果编译失败，打印错误信息</span>glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &amp;success);<span class="hljs-keyword">if</span> (!success)&#123;glGetShaderInfoLog(vertex_shader, <span class="hljs-number">512</span>, <span class="hljs-literal">nullptr</span>, info_log);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//链接顶点和片段着色器至一个着色器程序</span><span class="hljs-keyword">int</span> shader_program = glCreateProgram();glAttachShader(shader_program, vertex_shader);glAttachShader(shader_program, fragment_shader);glLinkProgram(shader_program);<span class="hljs-comment">//检查着色器是否成功链接，如果链接失败，打印错误信息</span>glGetProgramiv(shader_program, GL_LINK_STATUS, &amp;success);<span class="hljs-keyword">if</span> (!success)&#123;glGetProgramInfoLog(shader_program, <span class="hljs-number">512</span>, <span class="hljs-literal">nullptr</span>, info_log);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//删除着色器</span>glDeleteShader(vertex_shader);glDeleteShader(fragment_shader);<span class="hljs-comment">//线框模式-可选（GL-LINE为线框模式，GL_FILL为填充模式（无下面该语句默认该模式）</span><span class="hljs-comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span><span class="hljs-comment">/*渲染*/</span><span class="hljs-keyword">while</span> (!glfwWindowShouldClose((window)))&#123;<span class="hljs-comment">//清空颜色缓冲</span>glClearColor(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.34f</span>, <span class="hljs-number">0.57f</span>, <span class="hljs-number">1.0f</span>);glClear(GL_COLOR_BUFFER_BIT);<span class="hljs-comment">//使用着色器程序</span>glUseProgram(shader_program);<span class="hljs-comment">//绘制四边形</span>glBindVertexArray(vertex_array_object);<span class="hljs-comment">//绑定VAO</span>glDrawElements(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<span class="hljs-comment">//EBO绘制四边形</span>glBindVertexArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//解除绑定VAO</span><span class="hljs-comment">//交换缓冲并且检查是否有触发时间（比如键盘输入，鼠标移动等）</span>glfwSwapBuffers(window);glfwPollEvents();&#125;<span class="hljs-comment">/*释放资源*/</span><span class="hljs-comment">//删除VAO/VBO/EBO</span>glDeleteVertexArrays(<span class="hljs-number">1</span>, &amp;vertex_array_object);glDeleteBuffers(<span class="hljs-number">1</span>, &amp;vertex_buffer_object);glDeleteBuffers(<span class="hljs-number">1</span>, &amp;vertex_buffer_object);<span class="hljs-comment">//清理所有资源并正确退出程序</span>glfwTerminate();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h4 id="VAO-VBO"><a href="#VAO-VBO" class="headerlink" title="VAO+VBO"></a>VAO+VBO</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><span class="hljs-comment">步骤：</span><span class="hljs-comment">1-初始化：GLFW窗口，GLAD</span><span class="hljs-comment">2-数据处理：给定顶点数据，生成并绑定VAO&amp;VBO（准备再GPU中进行处理），设置顶点属性指针（本质上就是告诉OpenGL如何处理数据）。</span><span class="hljs-comment">3-着色器：给出顶点和片段着色器，然后链接为着色器程序，渲染时使用着色器程序。</span><span class="hljs-comment">4-渲染：清空缓冲，绑定纹理，使用着色器程序，绘制三角形，交换缓冲区检查触发时间后释放资源</span><span class="hljs-comment">*/</span><span class="hljs-comment">//使用VAO、VBO的方式形成四边形</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glad/glad.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GLFW/glfw3.h&gt;</span></span><span class="hljs-comment">//using namespace std;</span><span class="hljs-comment">//三角形顶点数据</span><span class="hljs-comment">//const float triangle[] = &#123;</span><span class="hljs-comment">//     //位置</span><span class="hljs-comment">//     -0.5,-0.5,0.0,//左下</span><span class="hljs-comment">//     0.5f,-0.5f,0.0f,//右下</span><span class="hljs-comment">//     0.0f,0.5f,0.0f//正上</span><span class="hljs-comment">//&#125;;</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> triangle[] = &#123;<span class="hljs-comment">//第一个三角形66</span><span class="hljs-number">0.5f</span>,<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//右上</span><span class="hljs-number">0.5f</span>,<span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//右下</span><span class="hljs-number">-0.5f</span>,<span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//左下</span><span class="hljs-comment">//第二个三角形</span><span class="hljs-number">-0.5f</span>,<span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//左下</span><span class="hljs-number">0.5f</span>,<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//右上</span><span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.0f</span><span class="hljs-comment">//左上</span>&#125;;<span class="hljs-comment">//屏幕宽，高</span><span class="hljs-keyword">int</span> screen_width = <span class="hljs-number">1280</span>;<span class="hljs-keyword">int</span> screen_height = <span class="hljs-number">720</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//初始化GLFW</span>glfwInit();<span class="hljs-comment">//OpenGL版本为3.3，主次版本号均设为3</span>glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);glfwWindowHint(GLFW_OPENGL_ANY_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="hljs-comment">//使用核心模式，无需向后兼容</span>glfwWindowHint(GLFW_RELEASE, <span class="hljs-literal">false</span>);<span class="hljs-comment">//创建窗口（宽、高、窗口名称）</span><span class="hljs-keyword">auto</span> window = glfwCreateWindow(screen_width, screen_height, <span class="hljs-string">"Triangle"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<span class="hljs-keyword">if</span> (window == <span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//如果窗口创建失败</span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to Create OpenGL ConText"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;glfwTerminate();<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;glfwMakeContextCurrent(window);<span class="hljs-comment">//将窗口的上下文设置为当前线程的主上下文</span><span class="hljs-comment">//初始化GLAD,加载OpenGL函数指针地址的函数</span><span class="hljs-keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//指定当前视口尺寸(前两个参数为左下角位置，后两个参数是渲染窗口宽、高)</span>glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, screen_width, screen_height);<span class="hljs-comment">//生成并绑定VAO和VBO</span>GLuint vertex_array_object;<span class="hljs-comment">//VAO</span>glGenVertexArrays(<span class="hljs-number">1</span>, &amp;vertex_array_object);glBindVertexArray(vertex_array_object);GLuint vertex_buffer_object;<span class="hljs-comment">//VBO</span>glGenBuffers(<span class="hljs-number">1</span>, &amp;vertex_buffer_object);glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer_object);<span class="hljs-comment">//将顶点数据绑定至当前默认的缓存中</span>glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(triangle), triangle, GL_STATIC_DRAW);<span class="hljs-comment">//设置顶点属性指针</span>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);glEnableVertexAttribArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//解绑VAO和VBO</span>glBindVertexArray(<span class="hljs-number">0</span>);glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<span class="hljs-comment">//顶点着色器和片段着色器源码</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* vertex_shader_source =<span class="hljs-string">"#version 330 core\n"</span><span class="hljs-string">"layout (location=0) in vec3 aPos;\n"</span><span class="hljs-string">"void main()\n"</span><span class="hljs-string">"&#123;\n"</span><span class="hljs-string">"      gl_Position=vec4(aPos,1.0);\n"</span><span class="hljs-string">"&#125;\n\0"</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fragment_shader_source =<span class="hljs-string">"#version 330 core\n"</span><span class="hljs-string">"out vec4 FragColor;\n"</span><span class="hljs-string">"void main()\n"</span><span class="hljs-string">"&#123;\n"</span><span class="hljs-string">"      FragColor=vec4(0.5f,1.5f,0.2f,1.0f);\n"</span><span class="hljs-comment">//三角形的颜色</span><span class="hljs-string">"&#125;\n\0"</span>;<span class="hljs-comment">//生成并编译着色器</span><span class="hljs-comment">//顶点着色器</span><span class="hljs-keyword">int</span> vertex_shader = glCreateShader(GL_VERTEX_SHADER);glShaderSource(vertex_shader, <span class="hljs-number">1</span>, &amp;vertex_shader_source, <span class="hljs-literal">NULL</span>);glCompileShader(vertex_shader);<span class="hljs-keyword">int</span> success;<span class="hljs-keyword">char</span> info_log[<span class="hljs-number">512</span>];<span class="hljs-comment">//检查着色器是否编译成功，如果编译失败，打印错误信息</span>glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &amp;success);<span class="hljs-keyword">if</span> (!success)&#123;glGetShaderInfoLog(vertex_shader, <span class="hljs-number">512</span>, <span class="hljs-literal">nullptr</span>, info_log);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//片段着色器</span><span class="hljs-keyword">int</span> fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragment_shader, <span class="hljs-number">1</span>, &amp;fragment_shader_source, <span class="hljs-literal">nullptr</span>);glCompileShader(fragment_shader);<span class="hljs-comment">//检查着色器是否成功编译，如果编译失败，打印错误信息</span>glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &amp;success);<span class="hljs-keyword">if</span> (!success)&#123;glGetShaderInfoLog(fragment_shader, <span class="hljs-number">512</span>, <span class="hljs-literal">nullptr</span>, info_log);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//链接顶点和片段着色器至一个着色器程序</span><span class="hljs-keyword">int</span> shader_program = glCreateProgram();glAttachShader(shader_program, vertex_shader);glAttachShader(shader_program, fragment_shader);glLinkProgram(shader_program);<span class="hljs-comment">//检查着色器是否成功链接，如果链接失败，打印错误信息</span>glGetProgramiv(shader_program, GL_LINK_STATUS, &amp;success);<span class="hljs-keyword">if</span> (!success)&#123;glGetProgramInfoLog(shader_program, <span class="hljs-number">512</span>, <span class="hljs-literal">nullptr</span>, info_log);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//删除着色器</span>glDeleteShader(vertex_shader);glDeleteShader(fragment_shader);<span class="hljs-comment">//线框模式</span><span class="hljs-comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span><span class="hljs-comment">//渲染循环4</span><span class="hljs-keyword">while</span> (!glfwWindowShouldClose((window)))&#123;<span class="hljs-comment">//清空颜色缓冲</span>glClearColor(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.34f</span>, <span class="hljs-number">0.57f</span>, <span class="hljs-number">1.0f</span>);<span class="hljs-comment">//背景色</span>glClear(GL_COLOR_BUFFER_BIT);<span class="hljs-comment">//使用着色器程序</span>glUseProgram(shader_program);<span class="hljs-comment">//绘制三角形</span>glBindVertexArray(vertex_array_object);<span class="hljs-comment">//绑定VAO</span>glDrawArrays(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);<span class="hljs-comment">//绑定三角形</span>glBindVertexArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//解除绑定</span><span class="hljs-comment">//交换缓冲并且检查是否有触发事件(比如键盘输入、鼠标移动等)</span>glfwSwapBuffers(window);glfwPollEvents();&#125;<span class="hljs-comment">//删除VAO和VBO</span>glDeleteVertexArrays(<span class="hljs-number">1</span>, &amp;vertex_array_object);glDeleteBuffers(<span class="hljs-number">1</span>, &amp;vertex_buffer_object);<span class="hljs-comment">//清理所有的资源并正确退出程序</span>glfwTerminate();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://learnopengl-cn.github.io/#_1" target="_blank" rel="noopener">LearnOpenGL</a><br><a href="https://www.icourse163.org/learn/HUST-1003636001?tid=1206895203#/learn/announce" target="_blank" rel="noopener">中国大学MOOC《计算机图形学》——华中科技大学</a></p>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>MOOC-计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】69. x的平方根</title>
    <link href="/%E3%80%90leetcode%E3%80%9169-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9.html"/>
    <url>/%E3%80%90leetcode%E3%80%9169-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目要求的是x的平方根，且只保留整数的部分，小数部分都被舍去<br>以x=8为例，题目是 <strong>求最后1个小于2.828的正整数</strong><br>这属于“寻找有序序列中第一个满足某条件的元素的位置”中的一类题目（所要求的的正整数就是位置），如果想要寻找最后一个满足“条件C”的元素的位置，则可以先求第一个满足“条件!C”的元素的位置，然后将该位置减1即可。<br>因此题目就变为了 <strong>求第一个大于2.828的正整数</strong> ，套用“求序列中第一个大于x的元素的位置”的二分查找模板即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> x;<span class="hljs-comment">//特殊情况</span><span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> right = x;<span class="hljs-keyword">while</span> (left &lt; right)&#123;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-comment">//使用长整数，之后相乘有可能出现溢出</span><span class="hljs-keyword">if</span> (mid*mid&gt;x)<span class="hljs-comment">//说明第一个大于x的位置一定在mid处或mid的左侧</span>&#123;right = mid;<span class="hljs-comment">//往左子区间[left,mid]查找</span>&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//说明第一个大于等于x的元素的位置一定在mid+1处或mid+1的右侧</span>&#123;left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//往右子区间[mid+1,right]查找</span>&#125;&#125;<span class="hljs-keyword">return</span> left<span class="hljs-number">-1</span>;<span class="hljs-comment">//返回夹出来的位置</span>&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】278. 第一个错误的版本</title>
    <link href="/%E3%80%90leetcode%E3%80%91278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC.html"/>
    <url>/%E3%80%90leetcode%E3%80%91278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>二分查找的经典问题：“寻找有序序列中第一个满足某条件的元素的位置”<br>时间复杂度：O(logn)。<br>空间复杂度：O(1)。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// Forward declaration of isBadVersion API.</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBadVersion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> version)</span></span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstBadVersion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">int</span> pLeft = <span class="hljs-number">1</span>, pRight = n;<span class="hljs-keyword">while</span> (pLeft &lt; pRight)&#123;<span class="hljs-keyword">int</span> mid = pLeft + (pRight - pLeft) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (isBadVersion(mid)) &#123;pRight = mid;&#125;<span class="hljs-keyword">else</span>&#123;pLeft = mid + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> pLeft;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【SUM】二分查找</title>
    <link href="/%E3%80%90sum%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html"/>
    <url>/%E3%80%90sum%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近自己在做二分查找类题目，二分查找是非常基础的算法，但其并不简单，有很多细节需要掌握，因此自己结合资料进行了一些整理，在看完这些后，建议做几道给出的习题这样效果会更好。</p><h2 id="二分查找介绍"><a href="#二分查找介绍" class="headerlink" title="二分查找介绍"></a>二分查找介绍</h2><p>二分查找是<strong>基于有序序列</strong>的查找算法。二分查找的高效之处在于，每一步都可以去除当前区间的一半元素，因此其时间复杂度时<code>O(logn)</code>，这是十分优秀的。</p><h3 id="基本的二分查找"><a href="#基本的二分查找" class="headerlink" title="基本的二分查找"></a>基本的二分查找</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p><font color=red> <strong>“查找序列中是否存在某条件的元素”</strong></font></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>首先给出最基本的二分查找问题及解决代码</p><p>eg：查找某元素在数组中的位置，如果找到，则返回下标，未找到，返回-1</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//二分区间为[left,right]，传入的初值为[0,n-1]</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;       <span class="hljs-keyword">int</span> mid;<span class="hljs-comment">//mid为中点</span>       <span class="hljs-keyword">while</span> (left&lt;=right)<span class="hljs-comment">//如果left&gt;right就没办法形成闭区间</span>       &#123;              mid = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-comment">//取中点-采用此种形式防止left+right超出int范围</span>              <span class="hljs-keyword">if</span> (nums[mid] == x) <span class="hljs-keyword">return</span> mid;<span class="hljs-comment">// 找到x，返回下标</span>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid]&gt;x)<span class="hljs-comment">//中间的数大于x</span>              &#123;                     right = mid - <span class="hljs-number">1</span>;<span class="hljs-comment">//往左子区间[left,mid-1]查找</span>              &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//中间的数小于x</span>                     left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//往右子区间[mid+1,right]查找</span>              &#125;       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//查找失败，返回-1</span>&#125;</code></pre></div><h3 id="二分查找的变形"><a href="#二分查找的变形" class="headerlink" title="二分查找的变形"></a>二分查找的变形</h3><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p><font color=red><strong>寻找有序序列中第一个满足某条件的元素的位置</strong></font>。</p><h5 id="举例1：求序列中的第一个大于等于x的元素的位置"><a href="#举例1：求序列中的第一个大于等于x的元素的位置" class="headerlink" title="举例1：求序列中的第一个大于等于x的元素的位置"></a>举例1：求序列中的第一个大于等于x的元素的位置</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//二分区间为[left,right]，传入的初值为[0,n],函数返回第一个大于等于x的元素的位置</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;       <span class="hljs-keyword">int</span> mid;<span class="hljs-comment">//mid为中点</span>       <span class="hljs-keyword">while</span> (left &lt; right)<span class="hljs-comment">//对于[left,right来说]，left==right说明找到了唯一位置</span>       &#123;              mid = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-comment">//取中点</span>              <span class="hljs-keyword">if</span> (nums[mid]&gt;=x)<span class="hljs-comment">//说明第一个大于等于x的元素的位置一定在mid处或mid的左侧</span>              &#123;                     right = mid;<span class="hljs-comment">//往左子区间[left,mid]查找</span>              &#125;              <span class="hljs-keyword">else</span><span class="hljs-comment">//说明第一个大于等于x的元素的位置一定在mid+1处处或mid+1的右侧</span>              &#123;                     left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//往右子区间[mid+1,right]查找</span>              &#125;       &#125;       <span class="hljs-keyword">return</span> left;<span class="hljs-comment">//返回夹出来的位置</span>&#125;</code></pre></div><p>注意点：</p><ul><li>循环条件为<code>left&lt;right</code>而非之前的<code>left&lt;=right</code>，这是由问题本身决定的。在上一个问题中，需要当元素不存在时返回-1，这样当<code>left&gt;right</code>时<code>[left,right]</code>就不再是闭区间，可以此作为元素不存在的判定原则，因此<code>left&lt;=right</code>满足时循环应当一致执行；但是如果想要返回第一个大于等于<code>x</code>的元素的位置，就不需要判断<code>x</code>本身是否存在，因为就算它不存在，返回的也是<b>“假设它存在，它应该在的位置”</b>，于是当<code>left==right</code>时，<code>[left,right]</code>刚好能夹出唯一的位置，就是需要的结果，因此只需要当<code>left&lt;right</code>时让循环一直执行即可。</li><li>由于当<code>left==right</code>时<code>while</code>循环停止，因此最后的返回值既可以是<code>left</code>，也可以是<code>right</code>。</li><li>二分的初始区间应当能覆盖到所有可能返回的结果。首先，二分下界是0是显然的，但是二分上界是<code>n-1</code>还是<code>n</code>呢？考虑到要查询元素有可能比序列中的所有元素都要大，此时应当返回<code>n</code>（即假设它存在，它应该在的位置），因此二分上界是<code>n</code>，故二分的初始区间为<code>[left,right]=[0,n]</code></li></ul><h5 id="举例2：求序列中第一个大于x的元素的位置"><a href="#举例2：求序列中第一个大于x的元素的位置" class="headerlink" title="举例2：求序列中第一个大于x的元素的位置"></a>举例2：求序列中第一个大于x的元素的位置</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//二分区间为[left,right]，传入的初值为[0,n],函数返回第一个大于x的元素的位置</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;       <span class="hljs-keyword">int</span> mid;<span class="hljs-comment">//中点</span>       <span class="hljs-keyword">while</span> (left&lt;right)<span class="hljs-comment">//对于[left,right来说]，left==right说明找到了唯一位置</span>       &#123;              mid = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-comment">//取中点</span>              <span class="hljs-keyword">if</span> (nums[mid]&gt;x)<span class="hljs-comment">//说明第一个大于x的元素的位置一定在mid处或mid的左侧</span>              &#123;                     right = mid;<span class="hljs-comment">//往左子区间[left,mid]查找</span>              &#125;              <span class="hljs-keyword">else</span><span class="hljs-comment">//说明第一个大于等于x的元素的位置一定在mid+1处或mid+1的右侧</span>              &#123;                     left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//往右子区间[mid+1,right]查找</span>              &#125;       &#125;       <span class="hljs-keyword">return</span> left;<span class="hljs-comment">//返回夹出来的位置</span>&#125;</code></pre></div><p>通过思考会发现，<code>lower_bound</code>函数和<code>upper_bound</code>函数都在解决这样一个问题：<font color=red><strong>寻找有序序列中第一个满足某条件的元素的位置</strong></font>。这是一个非常重要的且经典的问题，<strong>平时能碰到的大部分二分法问题都可以归结于这个问题</strong>。<br>例如对<code>lower_bound</code>函数来说，它寻找的就是第一个满足条件值“大于等于<code>x</code>”的元素的位置；<br>而对<code>upper_bound</code>函数来说，它寻找的是第一个满足条件“值大于<code>x</code>”的元素的位置。<br>显然，<font color=red>所谓的<strong>“某条件”在序列中一定是从左到右先不满足，然后满足的（否则把该条件取反即可）</strong><font>。</p><h4 id="变形问题的代码模板"><a href="#变形问题的代码模板" class="headerlink" title="变形问题的代码模板"></a>变形问题的代码模板</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//解决“寻找有序序列中第一个满足某条件的元素的位置”问题的固定模板</span><span class="hljs-comment">//二分区间为[left,right]，传入的初值为[0,n],函数返回第一个大于x的元素的位置</span><span class="hljs-function"><span class="hljs-keyword">int</span>   <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;       <span class="hljs-keyword">int</span> mid;<span class="hljs-comment">//中点</span>       <span class="hljs-keyword">while</span> (left &lt; right)<span class="hljs-comment">//对于[left,right来说]，left==right说明找到了唯一位置</span>       &#123;              mid = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-comment">//取中点</span>              <span class="hljs-keyword">if</span> (条件成立)<span class="hljs-comment">//位置一定在mid处或mid的左侧</span>              &#123;                     right = mid;<span class="hljs-comment">//往左子区间[left,mid]查找</span>              &#125;              <span class="hljs-keyword">else</span><span class="hljs-comment">//条件不成立，位置一定在mid+1处或mid+1的右侧</span>              &#123;                     left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//往右子区间[mid+1,right]查找</span>              &#125;       &#125;       <span class="hljs-keyword">return</span> left;<span class="hljs-comment">//返回夹出来的位置</span>&#125;</code></pre></div><p>另外，<font color=red><strong>如果想要寻找最后一个满足“条件C”的元素的位置，则可以先求第一个满足“条件!C”的元素的位置，然后将该位置减1即可</strong></font>（在最长回文子串的二分解法用到了这一点）。</p><p>最后，如何判断lower_bound函数和upper_bound函数的查询是否成功，只需对上界进行处理即可。例如下面的处理代码：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (left == nums.length) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">// 数组中未找到</span><span class="hljs-keyword">return</span> nums[left] == target ? left : <span class="hljs-number">-1</span>;<span class="hljs-comment">//如果该位置元素值和目标值相等，则找到，否则，未找到</span></code></pre></div><h3 id="LeetCode练习题"><a href="#LeetCode练习题" class="headerlink" title="LeetCode练习题"></a>LeetCode练习题</h3><p><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">278. 第一个错误的版本</a></p><ul><li>“寻找有序序列中第一个满足某条件的元素的位置”的方法的应用</li></ul><p><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a></p><ul><li>“如果想要寻找最后一个满足“条件C”的元素的位置，则可以先求第一个满足“条件!C”的元素的位置，然后将该位置减1即可”该方法的应用</li><li>思路可以参考<a href="https://blog.csdn.net/weixin_41234001/article/details/104666868" target="_blank" rel="noopener">我的blog</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
      <tag>SUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】167. 两数之和 II - 输入有序数组</title>
    <link href="/%E3%80%90leetcode%E3%80%91167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-ii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.html"/>
    <url>/%E3%80%90leetcode%E3%80%91167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-ii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>自己开始的思路是，对另一个数，在已有的数组中进行二分查找，而不是简单的遍历，自己觉得复杂度挺小的O(nlogn)，但是一直超时，同时自己的代码考虑了一种情况[2,7,7,10,11]，target=9，如果是官方题解应该是返回值时{1,3}；而我觉得正确的情况是[1,2]（我写的代码可以获得该结果），因此从官方题解可以看出没有这种情况出现。代码见后<br><img src="https://img-blog.csdnimg.cn/20200304191328292.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>之后参考自<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-by-leetco/" target="_blank" rel="noopener">LeetCode官方提解</a><br>使用两个指针，初始分别位于第一个元素和最后一个元素位置，比较这两个元素之和与目标值的大小。<br>如果和等于目标值，我们发现了这个唯一解。<br>如果比目标值小，我们将较小元素指针增加一。<br>如果比目标值大，将较大指针减小一。移动指针后重复上述比较直到找到答案。<br>时间复杂度O(n)，空间复杂度O(1)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//双指针</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>, high = numbers.size() - <span class="hljs-number">1</span>;<span class="hljs-comment">//low低指针，high高指针</span><span class="hljs-keyword">while</span> (low &lt; high)&#123;<span class="hljs-keyword">int</span> sum = numbers[low] + numbers[high];<span class="hljs-keyword">if</span> (sum == target) <span class="hljs-keyword">return</span> &#123; low + <span class="hljs-number">1</span>,high + <span class="hljs-number">1</span> &#125;;<span class="hljs-comment">//学到了</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target)&#123;low++;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target)&#123;high--;&#125;&#125;<span class="hljs-keyword">return</span> &#123; <span class="hljs-number">-1</span>,<span class="hljs-number">-1</span> &#125;;<span class="hljs-comment">//学到了</span>&#125;&#125;;</code></pre></div><h4 id="自己的想法"><a href="#自己的想法" class="headerlink" title="自己的想法"></a>自己的想法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//下列算法，超时无法通过题目</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numbers.size();i++)&#123;res.push_back(i+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> index = binarySearch(i+<span class="hljs-number">1</span>, numbers, target - numbers[i]);<span class="hljs-keyword">if</span> (index != <span class="hljs-number">-1</span>)&#123;res.push_back(index+<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> res;&#125;res.pop_back();&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">//寻找左侧边界的二分搜索</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; numbers,<span class="hljs-keyword">int</span> target)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> left = i;<span class="hljs-keyword">int</span> right = numbers.size();<span class="hljs-keyword">while</span> (left&lt;right) &#123;<span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (numbers[mid] == target) right=mid;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] &lt; target) &#123;left = mid + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid]&gt;target)&#123;right = mid;&#125;&#125;<span class="hljs-keyword">if</span> (left == numbers.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-keyword">return</span> numbers[left]==target?left:<span class="hljs-number">-1</span>;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】994. 腐烂的橘子</title>
    <link href="/%E3%80%90leetcode%E3%80%91994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90.html"/>
    <url>/%E3%80%90leetcode%E3%80%91994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>思路：多个腐烂橘子，让其均入队，对这些腐烂橘子同时广度优先使其周围橘子腐烂</p><p>算法：<br>1、先找出腐烂橘子，添加进queue<br>2、出队时，让当前腐烂橘子四周的新鲜就只都变为腐烂，即grid[tempX][tempY]=2;<br>3、用minute记录腐烂的持续时间，如果每一层的内一层橘子有腐烂，则自增1<br>4、检查网格中是否还有新鲜的的橘子</p><ul><li>有，返回-1</li><li>没有，返回minute</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-comment">//辅助定位——BFS常用</span><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 4&gt; dx = &#123; <span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;;<span class="hljs-comment">//上、下、左、右</span><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 4&gt; dy = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span> &#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<span class="hljs-keyword">int</span> minute = <span class="hljs-number">0</span>;<span class="hljs-comment">//腐烂时间</span><span class="hljs-built_in">queue</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; q;<span class="hljs-comment">//存储所有烂橘子</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; grid.size(); x++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; grid[<span class="hljs-number">0</span>].size(); y++)&#123;<span class="hljs-keyword">if</span> (grid[x][y] == <span class="hljs-number">2</span>)&#123;q.push(&#123; x,y &#125;);<span class="hljs-comment">//所有烂橘子依次入队</span>&#125;&#125;&#125;<span class="hljs-comment">//多源广度优先</span><span class="hljs-keyword">while</span> (!q.empty())&#123;<span class="hljs-keyword">int</span> qSize = q.size();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; qSize; i++)<span class="hljs-comment">//多源广度优先</span>&#123;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; front = q.front();<span class="hljs-comment">//首元素</span>q.pop();<span class="hljs-comment">//首元素出队</span><span class="hljs-comment">//进行四个方向的污染</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<span class="hljs-keyword">int</span> tempX = front.first + dx[i];<span class="hljs-keyword">int</span> tempY = front.second + dy[i];<span class="hljs-comment">//存储是否越界的值</span><span class="hljs-keyword">bool</span> noOver = (tempX &gt;= <span class="hljs-number">0</span> &amp;&amp; tempX &lt; grid.size() &amp;&amp; tempY &gt;= <span class="hljs-number">0</span> &amp;&amp; tempY &lt; grid[<span class="hljs-number">0</span>].size());<span class="hljs-comment">//未越界且该橘子为新鲜橘子</span><span class="hljs-keyword">if</span> (noOver &amp;&amp; grid[tempX][tempY] == <span class="hljs-number">1</span>)&#123;grid[tempX][tempY] = <span class="hljs-number">2</span>;<span class="hljs-comment">//污染该橘子</span>q.push(&#123; tempX,tempY &#125;);&#125;&#125;&#125;<span class="hljs-keyword">if</span> (!q.empty()) minute++;<span class="hljs-comment">//有内一层橘子腐烂（进入队列），则不为空，minute增加</span>&#125;<span class="hljs-comment">//检查是否还有新鲜橘子</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;grid.size();i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;grid[i].size();j++)&#123;<span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;&#125;<span class="hljs-comment">//返回时间</span><span class="hljs-keyword">return</span> minute;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【OpenGL】绘制三角形</title>
    <link href="/%E3%80%90opengl%E3%80%91%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2.html"/>
    <url>/%E3%80%90opengl%E3%80%91%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2.html</url>
    
    <content type="html"><![CDATA[<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><h5 id="1-初始化："><a href="#1-初始化：" class="headerlink" title="1-初始化："></a>1-初始化：</h5><p>初始化GLFW，创建窗口，初始化GLAD，创建视口</p><h5 id="2-数据处理："><a href="#2-数据处理：" class="headerlink" title="2-数据处理："></a>2-数据处理：</h5><p>给定顶点数据，生成并绑定VAO&amp;VBO（准备再GPU中进行处理），设置顶点属性指针（本质上就是告诉OpenGL如何处理数据）。</p><h5 id="3-着色器："><a href="#3-着色器：" class="headerlink" title="3-着色器："></a>3-着色器：</h5><p>给出顶点和片段着色器，然后链接为着色器程序，渲染时使用着色器程序。</p><h5 id="4-渲染："><a href="#4-渲染：" class="headerlink" title="4-渲染："></a>4-渲染：</h5><p>清空缓冲，使用着色器程序，绘制三角形，交换缓冲区并检查触发事件（比如键盘移动、鼠标移动）</p><h5 id="5-释放资源："><a href="#5-释放资源：" class="headerlink" title="5-释放资源："></a>5-释放资源：</h5><p>删除VAO、VBO，调用GLFW的函数来清理所有的资源并退出程序</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="https://img-blog.csdnimg.cn/2020030312364610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>开启线框模式的效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200303124604343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在配置好基本的OpenGL环境下，可直接运行</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><span class="hljs-comment">步骤：</span><span class="hljs-comment">1-初始化：GLFW窗口，GLAD</span><span class="hljs-comment">2-数据处理：给定顶点数据，生成并绑定VAO&amp;VBO（准备再GPU中进行处理），设置顶点属性指针（本质上就是告诉OpenGL如何处理数据）。</span><span class="hljs-comment">3-着色器：给出顶点和片段着色器，然后链接为着色器程序，渲染时使用着色器程序。</span><span class="hljs-comment">4-渲染：清空缓冲，绑定纹理，使用着色器程序，绘制三角形，交换缓冲区检查触发时间后释放资源</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glad/glad.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GLFW/glfw3.h&gt;</span></span><span class="hljs-comment">//using namespace std;</span><span class="hljs-comment">//三角形顶点数据</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> triangle[] = &#123;<span class="hljs-comment">//位置</span><span class="hljs-number">-0.5</span>,<span class="hljs-number">-0.5</span>,<span class="hljs-number">0.0</span>,<span class="hljs-comment">//左下</span><span class="hljs-number">0.5f</span>,<span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//右下</span><span class="hljs-number">0.0f</span>,<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.0f</span><span class="hljs-comment">//正上</span>&#125;;<span class="hljs-comment">//屏幕宽，高</span><span class="hljs-keyword">int</span> screen_width = <span class="hljs-number">1280</span>;<span class="hljs-keyword">int</span> screen_height = <span class="hljs-number">720</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//初始化GLFW</span>glfwInit();<span class="hljs-comment">//OpenGL版本为3.3，主次版本号均设为3</span>glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);glfwWindowHint(GLFW_OPENGL_ANY_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="hljs-comment">//使用核心模式，无需向后兼容</span>glfwWindowHint(GLFW_RELEASE, <span class="hljs-literal">false</span>);<span class="hljs-comment">//创建窗口（宽、高、窗口名称）</span><span class="hljs-keyword">auto</span> window = glfwCreateWindow(screen_width, screen_height, <span class="hljs-string">"Triangle"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<span class="hljs-keyword">if</span> (window==<span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//如果窗口创建失败</span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to Create OpenGL ConText"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;glfwTerminate();<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;glfwMakeContextCurrent(window);<span class="hljs-comment">//将窗口的上下文设置为当前线程的主上下文</span><span class="hljs-comment">//初始化GLAD,加载OpenGL函数指针地址的函数</span><span class="hljs-keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//指定当前视口尺寸(前两个参数为左下角位置，后两个参数是渲染窗口宽、高)</span>glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, screen_width, screen_height);<span class="hljs-comment">//生成并绑定VAO和VBO</span>GLuint vertex_array_object;<span class="hljs-comment">//VAO</span>glGenVertexArrays(<span class="hljs-number">1</span>, &amp;vertex_array_object);glBindVertexArray(vertex_array_object);GLuint vertex_buffer_object;<span class="hljs-comment">//VBO</span>glGenBuffers(<span class="hljs-number">1</span>, &amp;vertex_buffer_object);glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer_object);<span class="hljs-comment">//将顶点数据绑定至当前默认的缓存中</span>glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(triangle), triangle, GL_STATIC_DRAW);<span class="hljs-comment">//设置顶点属性指针</span>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);glEnableVertexAttribArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//解绑VAO和VBO</span>glBindVertexArray(<span class="hljs-number">0</span>);glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<span class="hljs-comment">//顶点着色器和片段着色器源码</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* vertex_shader_source =<span class="hljs-string">"#version 330 core\n"</span><span class="hljs-string">"layout (location=0) in vec3 aPos;\n"</span><span class="hljs-string">"void main()\n"</span><span class="hljs-string">"&#123;\n"</span><span class="hljs-string">"gl_Position=vec4(aPos,1.0);\n"</span><span class="hljs-string">"&#125;\n\0"</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fragment_shader_source =<span class="hljs-string">"#version 330 core\n"</span><span class="hljs-string">"out vec4 FragColor;\n"</span><span class="hljs-string">"void main()\n"</span><span class="hljs-string">"&#123;\n"</span><span class="hljs-string">"FragColor=vec4(0.5f,1.5f,0.2f,1.0f);\n"</span><span class="hljs-comment">//三角形的颜色</span><span class="hljs-string">"&#125;\n\0"</span>;<span class="hljs-comment">//生成并编译着色器</span><span class="hljs-comment">//顶点着色器</span><span class="hljs-keyword">int</span> vertex_shader = glCreateShader(GL_VERTEX_SHADER);glShaderSource(vertex_shader, <span class="hljs-number">1</span>, &amp;vertex_shader_source, <span class="hljs-literal">NULL</span>);glCompileShader(vertex_shader);<span class="hljs-keyword">int</span> success;<span class="hljs-keyword">char</span> info_log[<span class="hljs-number">512</span>];<span class="hljs-comment">//检查着色器是否编译成功，如果编译失败，打印错误信息</span>glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &amp;success);<span class="hljs-keyword">if</span> (!success)&#123;glGetShaderInfoLog(vertex_shader, <span class="hljs-number">512</span>, <span class="hljs-literal">nullptr</span>, info_log);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//片段着色器</span><span class="hljs-keyword">int</span> fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragment_shader, <span class="hljs-number">1</span>, &amp;fragment_shader_source, <span class="hljs-literal">nullptr</span>);glCompileShader(fragment_shader);<span class="hljs-comment">//检查着色器是否成功编译，如果编译失败，打印错误信息</span>glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &amp;success);<span class="hljs-keyword">if</span> (!success)&#123;glGetShaderInfoLog(fragment_shader, <span class="hljs-number">512</span>, <span class="hljs-literal">nullptr</span>, info_log);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//链接顶点和片段着色器至一个着色器程序</span><span class="hljs-keyword">int</span> shader_program = glCreateProgram();glAttachShader(shader_program, vertex_shader);glAttachShader(shader_program, fragment_shader);glLinkProgram(shader_program);<span class="hljs-comment">//检查着色器是否成功链接，如果链接失败，打印错误信息</span>glGetProgramiv(shader_program, GL_LINK_STATUS, &amp;success);<span class="hljs-keyword">if</span> (!success)&#123;glGetProgramInfoLog(shader_program, <span class="hljs-number">512</span>, <span class="hljs-literal">nullptr</span>, info_log);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//删除着色器</span>glDeleteShader(vertex_shader);glDeleteShader(fragment_shader);<span class="hljs-comment">//线框模式</span><span class="hljs-comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span><span class="hljs-comment">//渲染循环</span><span class="hljs-keyword">while</span> (!glfwWindowShouldClose((window)))&#123;<span class="hljs-comment">//清空颜色缓冲</span>glClearColor(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.34f</span>, <span class="hljs-number">0.57f</span>, <span class="hljs-number">1.0f</span>);<span class="hljs-comment">//背景色</span>glClear(GL_COLOR_BUFFER_BIT);<span class="hljs-comment">//使用着色器程序</span>glUseProgram(shader_program);<span class="hljs-comment">//绘制三角形</span>glBindVertexArray(vertex_array_object);<span class="hljs-comment">//绑定VAO</span>glDrawArrays(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">//绑定三角形</span>glBindVertexArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//解除绑定</span><span class="hljs-comment">//交换缓冲并且检查是否有触发事件(比如键盘输入、鼠标移动等)</span>glfwSwapBuffers(window);glfwPollEvents();&#125;<span class="hljs-comment">//删除VAO和VBO</span>glDeleteVertexArrays(<span class="hljs-number">1</span>, &amp;vertex_array_object);glDeleteBuffers(<span class="hljs-number">1</span>, &amp;vertex_buffer_object);<span class="hljs-comment">//清理所有的资源并正确退出程序</span>glfwTerminate();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://learnopengl-cn.github.io/#_1" target="_blank" rel="noopener">LearnOpenGL</a><br><a href="https://www.icourse163.org/learn/HUST-1003636001?tid=1206895203#/learn/announce" target="_blank" rel="noopener">中国大学MOOC《计算机图形学》——华中科技大学</a></p>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>MOOC-计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Error】visual studio2019报错，无法解析的外部符号gladLoadGLLoader，该符号在函数main中被引用</title>
    <link href="/%E3%80%90error%E3%80%91visual-studio2019%E6%8A%A5%E9%94%99%EF%BC%8C%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84%E5%A4%96%E9%83%A8%E7%AC%A6%E5%8F%B7gladloadglloader%EF%BC%8C%E8%AF%A5%E7%AC%A6%E5%8F%B7%E5%9C%A8%E5%87%BD%E6%95%B0main%E4%B8%AD%E8%A2%AB%E5%BC%95%E7%94%A8.html"/>
    <url>/%E3%80%90error%E3%80%91visual-studio2019%E6%8A%A5%E9%94%99%EF%BC%8C%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84%E5%A4%96%E9%83%A8%E7%AC%A6%E5%8F%B7gladloadglloader%EF%BC%8C%E8%AF%A5%E7%AC%A6%E5%8F%B7%E5%9C%A8%E5%87%BD%E6%95%B0main%E4%B8%AD%E8%A2%AB%E5%BC%95%E7%94%A8.html</url>
    
    <content type="html"><![CDATA[<h3 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h3><p>今天在打开之前写的OpenGL绘制三角形的程序时，发现一直报如下错误<br><img src="https://img-blog.csdnimg.cn/20200303115648500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="遇到的问题"><br>当时一直以为是自己没有链接好头文件和库文件，经过上网搜索，终于找到了问题所在，是自己没有把glad.c文件添加到项目中。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>之前记得自己添加glad.c文件是通过在源文件-&gt;新建项，新建一个glad.c文件，然后把其他目录下的glad.c文件的内容拷贝进来。<br>后来，我发现可以不需要这么麻烦。通过右击源文件-&gt;添加现有项-&gt;找到glad.c添加进去就可以了<br><img src="https://img-blog.csdnimg.cn/20200303120311940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>Error</tag>
      
      <tag>MOOC-计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】303. 区域和检索 - 数组不可变</title>
    <link href="/%E3%80%90leetcode%E3%80%91303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98.html"/>
    <url>/%E3%80%90leetcode%E3%80%91303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>dp[i]:nums[0…i-1]的累计和（包括这两个值）<br>初始值dp[0]=0;<br>状态转移<br>dp[i+1]=nums[i]+dp[i];<br>计算sumrange如下：<br>sumrange(i,j)=dp[j+1]-dp[i]</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//dp[i]:nums[0...i-1]的累计和（包括这两个值）：</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp;NumArray(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<span class="hljs-comment">//初始值</span>dp.assign(nums.size()+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)&#123;dp[i+<span class="hljs-number">1</span>] = nums[i] + dp[i];&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<span class="hljs-keyword">return</span> dp[j + <span class="hljs-number">1</span>] - dp[i];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】337. 打家劫舍 III</title>
    <link href="/%E3%80%90leetcode%E3%80%91337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iii.html"/>
    <url>/%E3%80%90leetcode%E3%80%91337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iii.html</url>
    
    <content type="html"><![CDATA[<p>思路参考自<a href="https://leetcode-cn.com/problems/house-robber-iii/solution/san-chong-fang-fa-jie-jue-shu-xing-dong-tai-gui-hu/" target="_blank" rel="noopener">王小二的题解</a></p><p>以下面的这棵树来说明<br>&nbsp;&nbsp;a<br>&nbsp;b&nbsp;&nbsp;c&nbsp;<br>d&nbsp;&nbsp;e f&nbsp;&nbsp;g<br>对于这棵树，我们用爷爷-两个孩子-四个孙子来说明<br>问题的状态：<br>爷爷节点获取到最大的偷钱数是多少呢？<br>1、首先要明确相邻的节点不能偷，也就是爷爷选择偷，儿子就不能偷了，但是孙子可以偷<br>2、二叉树只有左右两个孩子，一个爷爷最多2个儿子，4个孙子<br>根据以上条件，可以得出单个节点的钱该怎么算：<br><strong>4个孙子的偷的钱+爷爷的钱VS两个儿子偷的钱</strong><br>哪个组合钱多，就能成为当前节点能偷的最大钱数，这就是动态规划里的<strong>最优子结构</strong><br>由于是二叉树，这里可以选择计算所有子节点<br>4个孙子投的钱加上爷爷的钱如下<br>int method1=root.val+rob(root.left.left)+rob(root.left.right)+rob(root.right.left)+rob(root.right.right)<br>两个儿子偷的钱如下<br>int method2=rob(root.left)+rob(root.right);<br>挑选一个钱数多的方案则<br>int result=Math.max(method1,method2)<br>编写代码如下</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> money = root-&gt;val;<span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-comment">//左孩子不为空，把孙子的钱抢了</span>money += rob(root-&gt;left-&gt;left) + rob(root-&gt;left-&gt;right);&#125;<span class="hljs-keyword">if</span> (root-&gt;right!=<span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//右孩子不为空，把孙子的钱抢了</span>&#123;money + rob(root-&gt;right-&gt;left) + rob(root-&gt;right-&gt;right);&#125;<span class="hljs-keyword">return</span> max(money, rob(root-&gt;left) + rob(root-&gt;right));<span class="hljs-comment">//抢孙子及爷爷的钱和抢两个儿子的钱进行比较</span>&#125;&#125;;</code></pre></div><p><strong>记忆化优化</strong><br>本题记忆化需要拿哈希表来当缓存，也是自己第一次遇到这种情况，大开眼界<br>对于上述思想进行编码，无法通过案例，因此，采用记忆化的方式，减少中间的计算量。<strong>由于二叉树不适合拿数组当缓存，需要使用哈希表来存储结果，TreeNode当做key，能偷的钱当做value</strong></p><p>优化后的代码如下：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<span class="hljs-built_in">unordered_map</span>&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; dp;<span class="hljs-keyword">return</span> robMemory(root, dp);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">robMemory</span><span class="hljs-params">(TreeNode* root, <span class="hljs-built_in">unordered_map</span>&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt;&amp; dp)</span> </span>&#123;<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (dp.find(root) != dp.end()) <span class="hljs-keyword">return</span> dp[root];<span class="hljs-comment">//已存在</span><span class="hljs-keyword">int</span> money = root-&gt;val;<span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;money += robMemory(root-&gt;left-&gt;left, dp) + robMemory(root-&gt;left-&gt;right, dp);&#125;<span class="hljs-keyword">if</span> (root-&gt;right != <span class="hljs-literal">nullptr</span>)&#123;money += robMemory(root-&gt;right-&gt;left, dp) + robMemory(root-&gt;right-&gt;right, dp);&#125;money = max(money, robMemory(root-&gt;left, dp) + robMemory(root-&gt;right, dp));dp.insert(&#123; root,money &#125;);<span class="hljs-comment">//更新未存储过的dp键值对</span><span class="hljs-keyword">return</span> dp[root];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】213. 打家劫舍 II</title>
    <link href="/%E3%80%90leetcode%E3%80%91213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-ii.html"/>
    <url>/%E3%80%90leetcode%E3%80%91213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-ii.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>参考自<br><a href="/u/jyd/">@jyd</a></p><p>环状排列意味着第一个房子和最后一个房子只能选择一个偷窃，因此可以把此环装排列房间问题简化成为两个单排排列房间子问题：<br>1.在不偷窃第一个房子的情况下(即nums[1:])，最大金额是p1；<br>2.在不偷窃最后一个房子的情况下(即nums[:n-1])，最大金额是p2；</p><p>综合偷窃最大金额：为以上情况的较大值,即max(p1,p2);<br>因此问题转换为解决两个单排排列房间问题。<br>自己分别写了两份代码，第一份是直接利用198.打家劫舍的版代码复制了其中一些内容完成的。时间复杂度O(n)，空间复杂度O(1)<br>第二份代码，参考了<a href="https://leetcode-cn.com/problems/house-robber-ii/solution/213-da-jia-jie-she-iidong-tai-gui-hua-jie-gou-hua-/" target="_blank" rel="noopener">krahets的题解</a>进行了优化和修改，<br>时间复杂度O(n),空间复杂度O(1)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="未简化版代码"><a href="#未简化版代码" class="headerlink" title="未简化版代码"></a>未简化版代码</h4><p>dp[i]：表示为盗窃到第i个房间获得的最大值<br>由于不可以在相邻的房屋闯入,所以在当前位置i房屋可盗窃的最大值，要么就是i-1房屋可盗窃的最大值，要么就是<br>i-2房屋可盗窃的最大值加上当前房屋的值，二者之前取最大值<br>dp[i] = max(dp[i - 1], nums[i] + dp[i - 2]);</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-keyword">int</span> sizeNums = nums.size();<span class="hljs-comment">//对size==0、1、2时的特殊判断</span><span class="hljs-keyword">if</span> (sizeNums == <span class="hljs-number">0</span>||sizeNums==<span class="hljs-number">1</span>||sizeNums==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//dp数组</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//边界值</span>dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//第1个房屋可盗窃的最大值</span>dp[<span class="hljs-number">2</span>] = max(nums[<span class="hljs-number">1</span>], dp[<span class="hljs-number">1</span>]);<span class="hljs-comment">//第2个房屋可盗窃的最大值</span><span class="hljs-comment">//状态转移</span><span class="hljs-comment">//偷1房间不偷n房间</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt; nums.size() + <span class="hljs-number">1</span>; i++)&#123;<span class="hljs-keyword">if</span> (i != nums.size())dp[i] = max(dp[i - <span class="hljs-number">1</span>], nums[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]);<span class="hljs-keyword">else</span> dp[i] = dp[i - <span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">int</span> maxOne = dp[nums.size()];<span class="hljs-comment">//偷n房间，不偷1房间</span>dp[<span class="hljs-number">2</span>] = nums[<span class="hljs-number">1</span>];dp[<span class="hljs-number">3</span>] = max(nums[<span class="hljs-number">2</span>], dp[<span class="hljs-number">2</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &lt; nums.size() + <span class="hljs-number">1</span>; i++)&#123;dp[i] = max(dp[i - <span class="hljs-number">1</span>], nums[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]);&#125;<span class="hljs-keyword">return</span> max(maxOne, dp[nums.size()]);&#125;&#125;;</code></pre></div><h4 id="简化版代码"><a href="#简化版代码" class="headerlink" title="简化版代码"></a>简化版代码</h4><p>dp[i]=max(dp[i-2]+num[i],dp[i-1])<br>pre对应的是前dp[i-2];<br>cur对应dp[i-1]，也对应着dp[i]<br>在该式cur=max(pre + num, cur)中，cur在左侧充当dp[i]，在右侧充当dp[i-1]</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-keyword">if</span> (nums.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (nums.size() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">return</span> max(myRob(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(nums.begin(), nums.end() - <span class="hljs-number">1</span>)), myRob(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(nums.begin() + <span class="hljs-number">1</span>, nums.end())));&#125;<span class="hljs-keyword">private</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">myRob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums)</span> </span>&#123;<span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>, tmp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums)&#123;tmp = cur;cur = max(pre + num, cur);pre = tmp;&#125;<span class="hljs-keyword">return</span> cur;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】198. 打家劫舍</title>
    <link href="/%E3%80%90leetcode%E3%80%91198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html"/>
    <url>/%E3%80%90leetcode%E3%80%91198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>动态规划<br>dp[i]：第i个房间可盗窃的最大值<br>由于不可以在相邻的房屋闯入,所以在当前房屋i可盗窃的最大值，要么就是i-1房屋可盗窃的最大值，要么就是<br>i-2房屋可盗窃的最大值加上当前房屋的值，二者之前取最大值<br>dp[i] = max(dp[i - 1], nums[i-1] + dp[i - 2]); 其中nums[i-1]为当前房屋的值</p><p>使用循环的方式自底向上实现该思想<br>时间复杂度O(n)<br>空间复杂度O(n)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-keyword">if</span> (nums.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//对size==0特判</span><span class="hljs-keyword">if</span> (nums.size() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//对size==1特判</span><span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size()+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//边界值</span>dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//第1个房屋可盗窃的最大值</span>dp[<span class="hljs-number">2</span>] = max(nums[<span class="hljs-number">1</span>], dp[<span class="hljs-number">1</span>]);<span class="hljs-comment">//第2个房屋可盗窃的最大值</span><span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;nums.size()+<span class="hljs-number">1</span>; i++)&#123;dp[i] = max(dp[i - <span class="hljs-number">1</span>], nums[i<span class="hljs-number">-1</span>] + dp[i - <span class="hljs-number">2</span>]);&#125;<span class="hljs-keyword">return</span> dp[nums.size()];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】95. 不同的二叉搜索树 II</title>
    <link href="/%E3%80%90leetcode%E3%80%9195-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-ii.html"/>
    <url>/%E3%80%90leetcode%E3%80%9195-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-ii.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>参考自<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-2-7/" target="_blank" rel="noopener">详细通俗的思路分析，多解法</a><br>利用查找二叉树的性质。左子树的所有值小于根节点，右子树的所有值大于根节点。</p><p>所以如果求 1…n 的所有可能。</p><p>我们只需要把 1 作为根节点，[ ] 空作为左子树，[ 2 … n ] 的所有可能作为右子树。</p><p>2 作为根节点，[ 1 ] 作为左子树，[ 3…n ] 的所有可能作为右子树。</p><p>3 作为根节点，[ 1 2 ] 的所有可能作为左子树，[ 4 … n ] 的所有可能作为右子树，然后左子树和右子树两两组合。</p><p>4 作为根节点，[ 1 2 3 ] 的所有可能作为左子树，[ 5 … n ] 的所有可能作为右子树，然后左子树和右子树两两组合。</p><p>…</p><p>n 作为根节点，[ 1… n ] 的所有可能作为左子树，[ ] 作为右子树。</p><p>至于，[ 2 … n ] 的所有可能以及 [ 4 … n ] 以及其他情况的所有可能，可以利用上边的方法，把每个数字作为</p><p>根节点，然后把所有可能的左子树和右子树组合起来即可。</p><p>特判情况</p><p>如果是n==0，那就返回 null。</p><p>递归边界</p><ul><li><p>如果只有一个数字，那么所有可能就是一种情况，把该数字作为一棵树。</p></li><li><p>如果start&lt;end，则说明此时没有数字，将null加入结果中</p></li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; ans;<span class="hljs-comment">//此时没有数字，将null加入结果中</span><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<span class="hljs-keyword">return</span> getAns(<span class="hljs-number">1</span>, n);&#125;<span class="hljs-keyword">private</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; <span class="hljs-title">getAns</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; ans;<span class="hljs-comment">//此时没有数字，将null加入结果中</span><span class="hljs-keyword">if</span> (start &gt; end) &#123;ans.push_back(<span class="hljs-literal">nullptr</span>);<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-comment">//只有一个数字，当前数字作为一颗树加入到结果中</span><span class="hljs-keyword">if</span> (start==end)&#123;TreeNode* tree = <span class="hljs-keyword">new</span> TreeNode(start);ans.push_back(tree);<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-comment">//尝试每个数组作为根节点</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=start;i&lt;=end;i++)&#123;<span class="hljs-comment">//得到所有可能的左子树</span><span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; leftTrees = getAns(start, i - <span class="hljs-number">1</span>);<span class="hljs-comment">//左子树的所有值小于根节点</span><span class="hljs-comment">//得到所有可能的右子树</span><span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; rightTrees = getAns(i + <span class="hljs-number">1</span>, end);<span class="hljs-comment">//右子树的所有值大于根节点</span><span class="hljs-comment">//左子树右子树两两组合</span><span class="hljs-keyword">for</span> (TreeNode* leftTree:leftTrees)&#123;<span class="hljs-keyword">for</span> (TreeNode* rightTree:rightTrees)&#123;TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(i);root-&gt;left = leftTree;root-&gt;right = rightTree;<span class="hljs-comment">//加入到最终结果中</span>ans.push_back(root);&#125;&#125;&#125;<span class="hljs-keyword">return</span> ans;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二叉搜索树</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】面试题14- II. 剪绳子 II</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9814-ii-%E5%89%AA%E7%BB%B3%E5%AD%90-ii.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9814-ii-%E5%89%AA%E7%BB%B3%E5%AD%90-ii.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路参考自<a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/" target="_blank" rel="noopener">面试题14- II. 剪绳子 II（贪心 + 快速幂求余，清晰图解）</a><br><img src="https://img-blog.csdnimg.cn/202003021001519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200302100154340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> m = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//特判</span><span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-comment">//贪心</span><span class="hljs-comment">//当n&gt;3时，求n除以3的整数部分a和余数部分b(即n=3a+b)，并分为以下三种情况</span><span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (CalculateProduce(<span class="hljs-number">3</span>, n / <span class="hljs-number">3</span> - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>) % m; <span class="hljs-comment">//b==1</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> (CalculateProduce(<span class="hljs-number">3</span>, n / <span class="hljs-number">3</span>) * <span class="hljs-number">2</span>) % m; <span class="hljs-comment">//b==2</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> (CalculateProduce(<span class="hljs-number">3</span>, n / <span class="hljs-number">3</span>)) % m; <span class="hljs-comment">//b==0</span>&#125;<span class="hljs-comment">//循环求余法</span><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">CalculateProduce</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<span class="hljs-comment">//由于res*n可能超过int，因此要先使用longlong进行存储</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123; res = (res * n % m);&#125;<span class="hljs-keyword">return</span> res;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>剑指offer</tag>
      
      <tag>动态规划</tag>
      
      <tag>数学</tag>
      
      <tag>大数问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】面试题14- I. 剪绳子</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9814-i-%E5%89%AA%E7%BB%B3%E5%AD%90.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9814-i-%E5%89%AA%E7%BB%B3%E5%AD%90.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>F(n)为长度为n的绳子可以得到的最大乘积</strong>，对于每一个F(n)，可以得到如下分解：<br><img src="https://img-blog.csdnimg.cn/20200301224120149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>从上图可以看出可以把求解F(n)的问题分解成求解F(n-1)的问题，依次类推，直到求解到F(2)时，F(2)=1,递推回去，问题就得到了解决。<br>在每一次将一段绳子剪成两段时，剩下的部分可以继续剪，也可以不剪，因此我们得到了递归函数<br>F(n)=max(i<em>(n-i)，i*F(n-i)),i=1,2，…，n/2（由于对称性）,i</em>(n-i)表示不剪，i*F(n-i)表示继续剪</p><p>上述的递归函数，可以改写成动态规划中的状态转移方程</p><p>dp[n]=max(dp[n],max(i<em>(n-i)，i</em>F(n-i))；<br>其中dp[n]:存储长度为n的绳子的最大乘积。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度O(n^2)<br>空间复杂度O(n)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//初始值</span>dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> cuttingRopeCur(n,dp);&#125;<span class="hljs-comment">//递归</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRopeCur</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; dp)</span> </span>&#123;<span class="hljs-keyword">if</span> (dp[n] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[n];<span class="hljs-keyword">int</span> res = <span class="hljs-number">-1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n/<span class="hljs-number">2</span>;i++)&#123;<span class="hljs-comment">//状态转移</span>dp[n] = max(dp[n], max(i * (n - i), i * cuttingRopeCur(n - i,dp)));&#125;<span class="hljs-keyword">return</span> dp[n];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】225. 用队列实现栈</title>
    <link href="/%E3%80%90leetcode%E3%80%91225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html"/>
    <url>/%E3%80%90leetcode%E3%80%91225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html</url>
    
    <content type="html"><![CDATA[<p><strong><em>2020.6.30号更新</em></strong></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路和以前一样，此次复习时，对精简了代码</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q1, q2;<span class="hljs-comment">//q1进行插入和保存数据，q2作为辅助队列</span>    <span class="hljs-comment">/** Initialize your data structure here. */</span>    MyStack() &#123;    &#125;    <span class="hljs-comment">/** Push element x onto stack. */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        q1.push(x);    &#125;    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (q1.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//判断q1是否为空</span>        <span class="hljs-keyword">while</span> (q1.size()&gt;<span class="hljs-number">1</span>)<span class="hljs-comment">//q1中还剩下1个元素时</span>        &#123;            q2.push(q1.front());            q1.pop();        &#125;        <span class="hljs-keyword">int</span> value = q1.front();        q1.pop();        swap(q1, q2);<span class="hljs-comment">//交换q1和q2</span>        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-comment">/** Get the top element. */</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> value = pop();<span class="hljs-comment">//先pop拿到要出来的元素值</span>        q1.push(value);<span class="hljs-comment">//再将其压回</span>        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-comment">/** Returns whether the stack is empty. */</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (q1.empty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre></div><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>队列的特性：先进先出<br>栈的特性：先进后出<br>在解决用栈实现队列问题时，利用的是两个栈，采用的是利用辅助栈来实现队列的功能。因此对于此题也可以使用此思想。<br>利用两个队列，一个作为输入队列inputQ，一个作为输出队列outputQ。</p><ul><li>对于MyStack.push()操作，由inputQ完成</li><li>对于MyStack.pop()操作，由于栈的先进后出特性，可以使inputQ不断的pop，并将其值压回到outputQ，直到inputQ.size()==1即为此时应该出栈的元素，记录下来。</li><li>之后再把outputQ中的元素压回到inputQ中（可使用inputQ=outputQ完成该操作），outputQ清空，至此该过程结束。</li><li>对于MyStack.top()操作，类似于pop，只不过把可以进行简化一下，对inputQ不断pop，并记录front，直达为空，同时将该值压回到outputQ。之后把outputQ赋值给inputQ即可。<br>对于MyStack.empty()操作，判断inputQ是否为空即可。</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-comment">/** Initialize your data structure here. */</span><span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; inputQ;<span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; outputQ;MyStack() &#123;&#125;<span class="hljs-comment">/** Push element x onto stack. */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;inputQ.push_back(x);&#125;<span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> popNum=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (!inputQ.empty())&#123;<span class="hljs-keyword">while</span> (inputQ.size()!=<span class="hljs-number">1</span>)&#123;outputQ.push_back(inputQ.front());inputQ.pop_front();&#125;popNum = inputQ.front();inputQ.pop_front();inputQ = outputQ;outputQ.clear();&#125;<span class="hljs-keyword">return</span> popNum;&#125;<span class="hljs-comment">/** Get the top element. */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> popNum = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (!inputQ.empty())&#123;<span class="hljs-keyword">while</span> (!inputQ.empty())&#123;popNum = inputQ.front();outputQ.push_back(inputQ.front());inputQ.pop_front();&#125;inputQ = outputQ;outputQ.clear();&#125;<span class="hljs-keyword">return</span> popNum;&#125;<span class="hljs-comment">/** Returns whether the stack is empty. */</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (inputQ.empty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】96. 不同的二叉搜索树</title>
    <link href="/%E3%80%90leetcode%E3%80%9196-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <url>/%E3%80%90leetcode%E3%80%9196-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><em>个人的一些思考：<br>看完别人提供给的解题思路，对这道题目自己一开始的想法是，把所有的BST树的组合统计出来，而看到下面的解法，感觉并没有利用到题目中提到的BST的特性，主要是通过卡特兰数公式进行了求解</em></p><p><img src="https://img-blog.csdnimg.cn/20200301170636574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>参考自<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/hua-jie-suan-fa-96-bu-tong-de-er-cha-sou-suo-shu-b/" target="_blank" rel="noopener">灵魂画手的题解</a></p><p>下面是自己关于上述的解释<br>过程：<br>1、要获得以当前值为根节点的二叉树个数，如果知道了左子树和右子树的二叉树种类数 ，那我当前的结果只需要把左右子树的二叉树种类相乘即可。<br>因此，假设函数** f(i)** 表示<strong>以节点n为根的二叉搜索树的个数</strong>。</p><p>2、为了表达f()，我们需要定义<strong>n个节点拥有二叉搜索树的个数</strong>的函数，因此，假设这个函数为<strong>G(n)</strong>，则可以知道G(n) = f(1)+f(2)+…+f(n)，即<strong>等于以任何一个节点为根节点的二叉搜索树的个数和</strong>。</p><p>3、同样的，当i为根节点时，我们可以推导到，左子树节点个数为i-1个，则其拥有二叉搜索树的个数为G(i-1)右子树节点个数为n-i，则其拥有二叉搜索树的个数为G(n-i)。则以i为根节点的二叉搜索树的个数为f(i) = 左子树的二叉树的种类数目 * 右子树的二叉树的种类数目，即f(i) = G(i-1)*G(n-i)</p><p>4、可以发现这个转移方程是两步进行的，合并可以得到<strong>关于G的最终的动态转移方程<br>G(n) = G(0)G(n-1)+G(1)G(n-1)+G(2)G(n-2)…+G(n-1)G(0);</strong><br>该公式称之为<a href="https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0" target="_blank" rel="noopener">卡特兰数</a><br>而初始值为dp[0]=0，dp[1]=1。</p><p>5、因此，实现代码需要对长度为n的数组的每一个节点进行遍历，使其为根节点，其次是遍历子树的长度，合并结果，最终的dp[n]即为我们要求的结果。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//初始值</span>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i+<span class="hljs-number">1</span>;j++)&#123;<span class="hljs-comment">//状态转移</span><span class="hljs-comment">//卡特兰数公式</span>dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];&#125;&#125;<span class="hljs-keyword">return</span> dp[n];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二叉搜索树</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】779. 第K个语法符号</title>
    <link href="/%E3%80%90leetcode%E3%80%91779-%E7%AC%ACk%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7.html"/>
    <url>/%E3%80%90leetcode%E3%80%91779-%E7%AC%ACk%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>参考自<a href="https://leetcode-cn.com/problems/k-th-symbol-in-grammar/solution/di-kge-yu-fa-fu-hao-by-ikaruga-2/" target="_blank" rel="noopener">Ikaruga的题解</a><br><img src="https://img-blog.csdnimg.cn/20200228220740904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>通过上图分析，可以得到其实第N行的第K个数字，可以从第N-1行的第(K-1)/2+1个数字产生<br>因此可以采用递归的方法进行处理</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//公式法</span><span class="hljs-comment">//通过找规律可以发现</span><span class="hljs-comment">//第n行的第k个等于第n-1行的第(k-1)/2+1个数产生</span><span class="hljs-comment">//第n-1行的第(k-1)/2+1个数可能为0，可能为1，所以要分两种情况</span><span class="hljs-comment">//判断第n行中的第k个数字，属于奇数还是偶数，奇数选择第一个数字，偶数选择第二个数字（通过%号来选择）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthGrammar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<span class="hljs-keyword">if</span> (N == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> kthGrammar(N - <span class="hljs-number">1</span>, (K - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? (K - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span> : <span class="hljs-number">1</span> - (K - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>递归</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】119. 杨辉三角 II</title>
    <link href="/%E3%80%90leetcode%E3%80%91119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-ii.html"/>
    <url>/%E3%80%90leetcode%E3%80%91119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-ii.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>写出5行杨辉三角<br>1                    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowIndex=0<br>1 1                &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rowIndex=1<br>1 2 1            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowIndex=2<br>1 3 3 1            &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; rowIndex=3<br>1 4 6 4 1        &nbsp; &nbsp; &nbsp; rowIndex=4<br>可以发现从rowIndex=2开始，f[i][j]=f[i-1][j-1]+f[i-1][j]<br>因此O(k)即通过保存上一行的结果，就可以求得下一行</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//O(K)空间复杂度</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=rowIndex;i++)&#123;dp.push_back(<span class="hljs-number">1</span>);<span class="hljs-comment">//数组随i增大1格</span><span class="hljs-comment">//当前项等于上一行中的该项和前一项相加</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=i<span class="hljs-number">-1</span>;j&gt;<span class="hljs-number">0</span>;j--)&#123;dp[j] = dp[j - <span class="hljs-number">1</span>]+ dp[j];<span class="hljs-comment">//dp[j]对应于f[i-1][j],dp[j-1]对应于f[i-1][j-1]</span>&#125;&#125;<span class="hljs-keyword">return</span> dp;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】118. 杨辉三角</title>
    <link href="/%E3%80%90leetcode%E3%80%91118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92.html"/>
    <url>/%E3%80%90leetcode%E3%80%91118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>动态规划</p><p>初始值<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL2ViN2MzMjJjNjRiYTdlNjU1Mzk2ZTZjYzEwYTE1NmE1N2IxNGUzZDJhZDJiM2VhNmU2MTc2NTc4Y2ViMTJmNjItaW1hZ2UucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="image.png"><br>状态转移<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tLzdhYzIxOTEwNWQyNTllZWEwMWQ3MTYwZWE5N2NhNDQ0OTFiYWI3ZTNhZDdmMDIxNTdmZGFjYzU5NzI0NDJlNGYtaW1hZ2UucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="image.png"></p><p>两个版本：非递归和递归</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">generate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numRows)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(numRows)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numRows;i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> || j == i) dp[i].push_back(<span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> dp[i].push_back(dp[i - <span class="hljs-number">1</span>][j] + dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);&#125;&#125;<span class="hljs-keyword">return</span> dp;&#125;&#125;;</code></pre></div><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">generate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numRows)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(numRows)</span></span>;<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;generateRec(row, col, dp);<span class="hljs-keyword">return</span> dp;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generateRec</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; row, <span class="hljs-keyword">int</span>&amp; col, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; dp)</span> </span>&#123;<span class="hljs-keyword">if</span> (row &gt;= dp.size()) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//初始值</span><span class="hljs-keyword">if</span> (row == <span class="hljs-number">0</span> &amp;&amp; col == <span class="hljs-number">0</span> || col == <span class="hljs-number">0</span> || col == row) dp[row].push_back(<span class="hljs-number">1</span>);<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//状态转移</span>dp[row].push_back(dp[row - <span class="hljs-number">1</span>][col] + dp[row - <span class="hljs-number">1</span>][col - <span class="hljs-number">1</span>]);<span class="hljs-comment">//改变row,col</span><span class="hljs-keyword">if</span> (col == row) &#123;<span class="hljs-comment">//行、列相等</span>col = <span class="hljs-number">0</span>;row++;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (col &lt; row)<span class="hljs-comment">//行&lt;列</span>&#123;col++;&#125;<span class="hljs-comment">//递归</span>generateRec(row, col, dp);&#125;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】24. 两两交换链表中的节点</title>
    <link href="/%E3%80%90leetcode%E3%80%9124-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html"/>
    <url>/%E3%80%90leetcode%E3%80%9124-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>递归求解</p><p>对于自己写的递归，举例解释如下，以1-2-3-4-null为例</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-literal">null</span><span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-literal">null</span></code></pre></div><p>参照别人写的递归</p><div class="hljs"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;null <span class="hljs-symbol">2 </span><span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>  <span class="hljs-number">3</span>-&gt;null<span class="hljs-symbol">2 </span><span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;null<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;null</code></pre></div><p>二者差异在于，我的是每次都会把head和next连接起来,而改进的是，在交换后再进行连接，因此需要保存的量少，变得也就更简洁了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="自己写的递归"><a href="#自己写的递归" class="headerlink" title="自己写的递归"></a>自己写的递归</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<span class="hljs-comment">//空节点或者只剩一个节点</span><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//交换列表中的前两个节点head和head.next</span>ListNode* tempFirst = head;ListNode* tempHead = head-&gt;next;<span class="hljs-comment">//交换后新的头节点为head.next</span>ListNode* tempSecond = head-&gt;next-&gt;next;head-&gt;next-&gt;next = tempFirst;head-&gt;next = tempSecond;head = tempHead;<span class="hljs-comment">//更新一下交换后的头节点</span><span class="hljs-comment">//将交换后子列表的返回头和head.next.next相连</span>head-&gt;next-&gt;next = swapPairs(head-&gt;next-&gt;next);&#125;<span class="hljs-keyword">return</span> head;&#125;&#125;;</code></pre></div><h4 id="参考别人写的递归"><a href="#参考别人写的递归" class="headerlink" title="参考别人写的递归"></a>参考别人写的递归</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//参考别人后更简化的写法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<span class="hljs-comment">//空节点或者只剩一个节点</span><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;ListNode* next = head-&gt;next;        <span class="hljs-comment">//将子列表的返回节点与head.next相连，形成新的链表</span>head-&gt;next = swapPairs(next-&gt;next);<span class="hljs-comment">//将交换后的next指向head，将next和head连接起来</span>next-&gt;next = head;<span class="hljs-keyword">return</span> next;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>递归</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】47.礼物的最大价值</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9147-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9147-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><div class="hljs"><pre><code class="hljs latex">状态转移dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];初始值dp[0][0] &#x3D; grid[0][0];dp[i][0] &#x3D; grid[i][0] + dp[i - 1][0];dp[0][j] &#x3D; dp[0][j - 1] + grid[0][j];</code></pre></div><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<span class="hljs-built_in">vector</span> &lt; <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp(grid.size(),<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(grid[<span class="hljs-number">0</span>].size(),<span class="hljs-number">0</span>));<span class="hljs-comment">//初始值设置</span>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<span class="hljs-comment">//dp[i][0]的初始值设置</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;grid.size();i++)&#123;dp[i][<span class="hljs-number">0</span>] = grid[i][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">//dp[0][j]的初始值设置</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;grid[<span class="hljs-number">0</span>].size();j++)&#123;dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];&#125;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; grid.size(); i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;grid[<span class="hljs-number">0</span>].size();j++)&#123;dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j];&#125;&#125;<span class="hljs-comment">//返回结果</span><span class="hljs-keyword">return</span> dp[grid.size() - <span class="hljs-number">1</span>][grid[<span class="hljs-number">0</span>].size() - <span class="hljs-number">1</span>];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】49.丑数</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9149-%E4%B8%91%E6%95%B0.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9149-%E4%B8%91%E6%95%B0.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tLzg0ZmNjZWViNTI0ODY4MzViNzgxYmVhOWYxNTFiYjNjOTgwYjFiNmE4ODc4YTczOWRmOWIwYTViMTU1OWY1MTEtaW1hZ2UucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="image.png"><br>题目做了很久，看了很多解析都很迷惑，看到一位同学关于此题的评论，感觉很有道理，解释也很清晰，特此和大家分享，我只是个搬运工，大家多感谢原作者。<br><a href="https://leetcode-cn.com/problems/chou-shu-lcof/comments/250364" target="_blank" rel="noopener">sunrise。同学的评论</a><br>以下均节选自该同学的评论</p><blockquote><p>丑数的排列肯定是1,2,3,4,5,6,8,10…. 然后有一个特点是，任意一个丑数都是由小于它的某一个丑数<em>2，</em>3或者<em>5得到的，那么如何得到所有丑数呢？ 现在假设有3个数组，分别是： A：{1</em>2，2<em>2，3</em>2，4<em>2，5</em>2，6<em>2，8</em>2，10*2……}</p></blockquote><blockquote><p>B：{1<em>3，2</em>3，3<em>3，4</em>3，5<em>3，6</em>3，8<em>3，10</em>3……}</p></blockquote><blockquote><p>C：{1<em>5，2</em>5，3<em>5，4</em>5，5<em>5，6</em>5，8<em>5，10</em>5……}</p></blockquote><blockquote><p>那么所有丑数的排列，必定就是上面ABC3个数组的合并结果然后去重得到的，那么这不就转换成了三个有序数组的无重复元素合并的问题了吗？而这三个数组就刚好是{1,2,3,4,&gt;5,6,8,10….}乘以2,3,5得到的。</p></blockquote><blockquote><p>合并有序数组的一个比较好的方法，就是每个数组都对应一个指针，然后比较这些指针所指的数中哪个最小，就将这个数放到结果数组中，然后该指针向后挪一位。<br>此外，注意到ABC三个数组实际上就是ugly[]<em>2，ugly[]</em>3和ugly[]<em>5的结果，所以每次只需要比较A[i]=ugly[i]</em>2，B[j]=ugly[j]<em>3和C[k]=ugly[k]</em>5的大小即可。然后谁最小，就把对应的指针往后移动一个，为了去重，如果三个指针所指的元素都是最小的元素，那么这3个指针都要往后移动一个。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">saveUUglyNumbers</span><span class="hljs-params">(n)</span></span>;saveUUglyNumbers[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//基础丑数为1</span><span class="hljs-keyword">int</span> p2, p3, p5;<span class="hljs-comment">//分别指向三个有序链表（现象）的首元素，A，B，C</span>p2 = p3 = p5 = <span class="hljs-number">0</span>;<span class="hljs-comment">//将丑数排序</span><span class="hljs-keyword">while</span> (count &lt; n)&#123;saveUUglyNumbers[count] = min(min(saveUUglyNumbers[p2] * <span class="hljs-number">2</span>, saveUUglyNumbers[p3] * <span class="hljs-number">3</span>), saveUUglyNumbers[p5] * <span class="hljs-number">5</span>);            <span class="hljs-comment">//三个有序链表可能有相同元素，所以只要是最小的，都要移动指针</span><span class="hljs-keyword">if</span> (saveUUglyNumbers[p2] * <span class="hljs-number">2</span> == saveUUglyNumbers[count]) p2++;<span class="hljs-keyword">if</span> (saveUUglyNumbers[p3] * <span class="hljs-number">3</span> == saveUUglyNumbers[count]) p3++;<span class="hljs-keyword">if</span> (saveUUglyNumbers[p5] * <span class="hljs-number">5</span> == saveUUglyNumbers[count]) p5++;count++;&#125;<span class="hljs-keyword">return</span> saveUUglyNumbers[count<span class="hljs-number">-1</span>];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>多指针</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】12. 矩阵中的路径</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9112-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9112-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>回溯法可以看成蛮力法的升级版，它从解决问题每一步的所有可能选项里系统地选择出一个可行的解决方案。回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。当我们在某一步选择了其中一个选项时，就进入下一步，然后又面临新的选项。我们就这样重复选择，直至到达最终的状态。<br><img src="https://img-blog.csdnimg.cn/20200227203847659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>举例如下</p><p><img src="https://img-blog.csdnimg.cn/20200227203922857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-comment">/*</span><span class="hljs-comment">x[4]、y[4]和dfs中for循环，共同构成遍历字符board的“左右上下”四个字符这一功能</span><span class="hljs-comment">*/</span><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>,4&gt; x = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span> &#125;;<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>,4&gt; y = &#123; <span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-built_in">string</span> word)</span> </span>&#123;<span class="hljs-comment">//特判</span><span class="hljs-keyword">if</span> (board.empty() || word.empty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">int</span> pathLength = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; board.size(); row++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; board[<span class="hljs-number">0</span>].size(); col++)&#123;<span class="hljs-comment">//对每个点依次判断是否存在一条路径</span><span class="hljs-keyword">if</span> (hasPathCore(board, row, col, pathLength, word))&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasPathCore</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">int</span>&amp; pathLength, <span class="hljs-built_in">string</span> word)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//递归边界</span><span class="hljs-keyword">if</span> (pathLength == word.size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">bool</span> hasPath = <span class="hljs-literal">false</span>;<span class="hljs-keyword">bool</span> noOverIndex = (row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; board.size() &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; board[<span class="hljs-number">0</span>].size());<span class="hljs-comment">//坐标是否越界</span><span class="hljs-keyword">if</span> (noOverIndex &amp;&amp; board[row][col] == word[pathLength])<span class="hljs-comment">//未越界，且该点字符和word字符相等（此处隐含了已被标记）</span>&#123;<span class="hljs-keyword">char</span> temp = board[row][col];++pathLength;<span class="hljs-comment">//找一下个</span>board[row][col] = <span class="hljs-string">'*'</span>;<span class="hljs-comment">//标记已看过</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<span class="hljs-comment">//如果路径还不存在，依次遍历上下左右四个方向未被遍历的方向——剪枝作用</span><span class="hljs-keyword">if</span>(!hasPath) hasPath = hasPathCore(board, row + x[i], col + y[i], pathLength, word);                <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">//回溯</span><span class="hljs-keyword">if</span> (!hasPath) &#123;--pathLength;board[row][col] = temp;<span class="hljs-comment">//还原</span>&#125;&#125;<span class="hljs-keyword">return</span> hasPath;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>回溯</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】48.最长不含重复字符的子字符串</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9148-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9148-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>利用unordered_map作滑动窗口<br>算法：<br>1.初始化头尾指针分别为head=0,tail=0<br>2.tail指针右移，并将tail所指元素加入到窗口中，判断tail当前指向的元素在滑动窗口中是否出现，<br>    - 如果出现，则将滑动窗口当前head所指元素数量-1，并移动head，直到该窗口中不包含该元素.<br>    - 如果未出现，则更新res，并进行下一轮循环，直到tail=s.size()</p><p>3.返回结果res</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; window;<span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-comment">//存储答案</span><span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>, tail = <span class="hljs-number">0</span>;<span class="hljs-comment">//双指针</span><span class="hljs-keyword">for</span> (;tail&lt;s.size();tail++)&#123;<span class="hljs-keyword">char</span> temp = s[tail];<span class="hljs-comment">//当前字符</span>window[temp]++;<span class="hljs-comment">//判断该窗口中是否存在该元素</span><span class="hljs-comment">//如果存在该元素，使head右移，直到该窗口不包含该元素</span><span class="hljs-keyword">while</span> (window[temp]&gt;<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">char</span> temp2 = s[head];window[temp2]--;<span class="hljs-comment">//滑动窗口中该字符数量-1</span>head++;<span class="hljs-comment">//右移</span>&#125;res = max(res, tail - head+<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>双指针</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】50.第一个只出现一次的字符</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9150-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9150-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>先统计出每个字符的出现次数<br>再按照s中字符的顺序进行遍历</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<span class="hljs-keyword">char</span> res=<span class="hljs-string">' '</span>;<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; hashMap;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it=s.begin();it!=s.end();it++)&#123;++hashMap[*it];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = s.begin(); it != s.end(); it++)&#123;<span class="hljs-keyword">if</span> (hashMap[*it] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> *it;&#125;<span class="hljs-keyword">return</span> res;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】17. 打印从1到最大的n位数</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9117-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9117-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0.html</url>
    
    <content type="html"><![CDATA[<h3 id="2020-7-6解题"><a href="#2020-7-6解题" class="headerlink" title="2020.7.6解题"></a>2020.7.6解题</h3><p>复习了一下全排列的写法</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;        <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">number</span><span class="hljs-params">(n, <span class="hljs-string">'0'</span>)</span></span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            number[<span class="hljs-number">0</span>] = i + <span class="hljs-string">'0'</span>;            Print1ToMaxOfNDigitsRecursively(number, <span class="hljs-number">0</span>);<span class="hljs-comment">//深度优先</span>        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-comment">//全排列</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print1ToMaxOfNDigitsRecursively</span><span class="hljs-params">(<span class="hljs-built_in">string</span> number, <span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> (index == number.size() - <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">int</span> temp = stoi(number);            <span class="hljs-keyword">if</span>(temp!=<span class="hljs-number">0</span>) ans.push_back(temp);<span class="hljs-comment">//对0特判</span>            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            number[index + <span class="hljs-number">1</span>] = i + <span class="hljs-string">'0'</span>;            Print1ToMaxOfNDigitsRecursively(number, index + <span class="hljs-number">1</span>);        &#125;    &#125;&#125;;</code></pre></div><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目本身其实需要考虑的问题很多，并不是一道easy题，只不过是LeetCode上把它简化了非常多。<br>希望大家通过这道题目学会其大数解法和递归求解全排列的思想，只知道用第一种方法这道题目就是水题了。</p><p>1、针对本题的常规思路，利用pow函数，秒解<br>2、假设可能出现大数（本题不可能），转换为大数问题求解<br>本题自己对于大数解法，自己开始对char和string也不是很熟练，通过本题分别练习了使用char和string两种字符数组的方式分别进行求解</p><ul><li>通过使用char数组进行求解</li><li>通过使用string进行求解</li></ul><p>3、递归求解</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="针对本题的简单解法"><a href="#针对本题的简单解法" class="headerlink" title="针对本题的简单解法"></a>针对本题的简单解法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<span class="hljs-comment">//打印到数组中</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,max=<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,n);i&lt;max;i++)&#123;res.push_back(i);&#125;<span class="hljs-keyword">return</span> res;&#125;&#125;;</code></pre></div><h4 id="大数解法-char版"><a href="#大数解法-char版" class="headerlink" title="大数解法 char版"></a>大数解法 char版</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<span class="hljs-comment">//创建一个能容纳最大值的字符数组,由于有一位要存储'\0'，因此要开大一格</span><span class="hljs-keyword">char</span>* number = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n + <span class="hljs-number">1</span>];<span class="hljs-comment">//初始全部设置为0</span><span class="hljs-built_in">memset</span>(number, <span class="hljs-string">'0'</span>, n);number[n] = <span class="hljs-string">'\0'</span>;<span class="hljs-comment">//第n位设为'\0'</span><span class="hljs-keyword">while</span> (!Increment(number))&#123;PrintNumber(number);&#125;<span class="hljs-keyword">delete</span>[]number;<span class="hljs-comment">//注意要释放内存</span><span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Increment</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* number)</span> </span>&#123;<span class="hljs-comment">//形参传递char*指针</span><span class="hljs-keyword">bool</span> isOverflow = <span class="hljs-literal">false</span>;<span class="hljs-comment">//检测是否越界</span><span class="hljs-keyword">int</span> nTakeOver = <span class="hljs-number">0</span>;<span class="hljs-comment">//存储进位</span><span class="hljs-keyword">int</span> nLength = <span class="hljs-built_in">strlen</span>(number);<span class="hljs-comment">//长度为n,不是n+1</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nLength - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<span class="hljs-keyword">int</span> nSum = number[i] - <span class="hljs-string">'0'</span> + nTakeOver;<span class="hljs-keyword">if</span> (i == nLength - <span class="hljs-number">1</span>)<span class="hljs-comment">//如果是第一位，进位</span>&#123;nSum++;&#125;<span class="hljs-keyword">if</span> (nSum &gt;= <span class="hljs-number">10</span>)<span class="hljs-comment">//有进位</span>&#123;<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<span class="hljs-comment">//如果是最高位有进位，说明超过了给定得到最大值，越界</span>&#123;isOverflow = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//非最高位有进位</span>&#123;nTakeOver = <span class="hljs-number">1</span>;number[i] = nSum - <span class="hljs-number">10</span> + <span class="hljs-string">'0'</span>;<span class="hljs-comment">//对第i位进行设置</span>&#125;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//没有进位</span><span class="hljs-comment">//设置第i位数字</span><span class="hljs-comment">//并直接跳出循环</span>&#123;number[i] = nSum + <span class="hljs-string">'0'</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">return</span> isOverflow;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintNumber</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* number)</span></span><span class="hljs-function"><span class="hljs-comment">//形参传递char*指针，此处改变形参number指向的位置，不会使原始的number指针所指位置改变</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">string</span> s = <span class="hljs-string">""</span>;<span class="hljs-keyword">bool</span> isBegin0 = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (*number != <span class="hljs-string">'\0'</span>)&#123;<span class="hljs-keyword">if</span> (isBegin0 &amp;&amp; *number != <span class="hljs-string">'0'</span>) isBegin0 = <span class="hljs-literal">false</span>;<span class="hljs-comment">//碰到'0'，则不输出</span><span class="hljs-keyword">if</span> (!isBegin0)&#123;s += *number;&#125;number++;&#125;<span class="hljs-keyword">int</span> num = stoi(s);<span class="hljs-comment">//转为整数</span>res.push_back(num);&#125;&#125;;</code></pre></div><h4 id="大数解法string版"><a href="#大数解法string版" class="headerlink" title="大数解法string版"></a>大数解法string版</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<span class="hljs-comment">//创建一个能容纳最大值的字符数组</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">number</span><span class="hljs-params">(n, <span class="hljs-string">'0'</span>)</span></span>;<span class="hljs-comment">//初始全部设置为0</span><span class="hljs-keyword">while</span> (!Increment(number))&#123;saveNumber(number);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Increment</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; number)</span> </span>&#123;<span class="hljs-comment">//注意要使用引用传递，否则无法修改number</span><span class="hljs-keyword">bool</span> isOverflow = <span class="hljs-literal">false</span>;<span class="hljs-comment">//检测是否越界</span><span class="hljs-keyword">int</span> nTakeOver = <span class="hljs-number">0</span>;<span class="hljs-comment">//存储进位</span><span class="hljs-keyword">int</span> nLength = number.size();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nLength - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<span class="hljs-keyword">int</span> nSum = number[i] - <span class="hljs-string">'0'</span> + nTakeOver;<span class="hljs-keyword">if</span> (i == nLength - <span class="hljs-number">1</span>)<span class="hljs-comment">//如果是第一位，进位</span>&#123;nSum++;&#125;<span class="hljs-keyword">if</span> (nSum &gt;= <span class="hljs-number">10</span>)<span class="hljs-comment">//有进位</span>&#123;<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<span class="hljs-comment">//如果是最高位有进位，说明超过了给定得到最大值，越界</span>&#123;isOverflow = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">else</span>&#123;nTakeOver = <span class="hljs-number">1</span>;number[i] = nSum - <span class="hljs-number">10</span> + <span class="hljs-string">'0'</span>;<span class="hljs-comment">//对第i位进行设置</span>&#125;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//没有进位</span><span class="hljs-comment">//设置第i位数字</span><span class="hljs-comment">//并直接跳出循环</span>&#123;number[i] = nSum + <span class="hljs-string">'0'</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">return</span> isOverflow;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveNumber</span><span class="hljs-params">(<span class="hljs-built_in">string</span> number)</span></span><span class="hljs-function"><span class="hljs-comment">//由于此处输出，不需要修改number，因此不需要加引用</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">string</span> s = <span class="hljs-string">""</span>;<span class="hljs-keyword">bool</span> isBegin0 = <span class="hljs-literal">true</span>;<span class="hljs-built_in">string</span>::iterator it = number.begin();<span class="hljs-keyword">while</span> (it != number.end())&#123;<span class="hljs-keyword">if</span> (isBegin0 &amp;&amp; *it != <span class="hljs-string">'0'</span>) isBegin0 = <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (!isBegin0)&#123;s += *it;&#125;it++;&#125;<span class="hljs-keyword">int</span> num = stoi(s);res.push_back(num);&#125;&#125;;</code></pre></div><h4 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">number</span><span class="hljs-params">(n, <span class="hljs-string">'0'</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++)<span class="hljs-comment">//从高位到低位进行全排列</span>&#123;number[<span class="hljs-number">0</span>] = i + <span class="hljs-string">'0'</span>;<span class="hljs-comment">//首字符赋初值</span>permutationNumbers(number, n, <span class="hljs-number">1</span>);<span class="hljs-comment">//设置下一位</span>&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">//对数字全排列</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">permutationNumbers</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; number, <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<span class="hljs-keyword">if</span> (index == length) &#123;<span class="hljs-comment">//递归边界</span>saveNumber(number);<span class="hljs-comment">//存储结果</span><span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++)&#123;number[index] = <span class="hljs-string">'0'</span> + i;<span class="hljs-comment">//设置第index位的字符</span>permutationNumbers(number, length, index + <span class="hljs-number">1</span>);&#125;&#125;&#125;<span class="hljs-comment">//存储结果</span><span class="hljs-comment">//只能存储前导非0的排列</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveNumber</span><span class="hljs-params">(<span class="hljs-built_in">string</span> number)</span> </span>&#123;<span class="hljs-keyword">bool</span> isBegin0 = <span class="hljs-literal">true</span>;<span class="hljs-built_in">string</span> tempStr = <span class="hljs-string">""</span>;<span class="hljs-built_in">string</span>::iterator it = number.begin();<span class="hljs-keyword">while</span> (it != number.end())&#123;<span class="hljs-keyword">if</span> (isBegin0 &amp;&amp; *it != <span class="hljs-string">'0'</span>) isBegin0 = <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (!isBegin0) &#123;tempStr += *it;&#125;it++;&#125;<span class="hljs-comment">//从高位到低位全排列，要注意首字符为0时，tempStr为空，不能执行stoi</span><span class="hljs-keyword">if</span> (tempStr != <span class="hljs-string">""</span>) &#123;<span class="hljs-keyword">int</span> tempNum = stoi(tempStr);res.push_back(tempNum);&#125;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>递归</tag>
      
      <tag>大数问题</tag>
      
      <tag>深度优先</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】42. 连续子数组的最大和</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9142-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9142-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.html</url>
    
    <content type="html"><![CDATA[<h3 id="2020-7-17更新"><a href="#2020-7-17更新" class="headerlink" title="2020.7.17更新"></a>2020.7.17更新</h3><p>动态规划<br>时间复杂度O(n)<br>空间复杂度O(1)</p><h4 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//1.定义数组元素的含义</span><span class="hljs-comment">// 以第i个数字结尾的子数组的最大和</span><span class="hljs-comment">//2.找出关系数组间的关系式</span><span class="hljs-comment">// if(dp[i-1]&gt;0) dp[i]=dp[i-1]+nums[i]</span><span class="hljs-comment">// else dp[i]=nums[i];</span><span class="hljs-comment">//3. 找出初始值</span><span class="hljs-comment">// dp[0]=nums[0];</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums.size() &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> nCurSum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> nGreatestSum = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;            <span class="hljs-keyword">if</span> (nCurSum &lt;= <span class="hljs-number">0</span>) &#123;                nCurSum = nums[i];            &#125;            <span class="hljs-keyword">else</span> &#123;                nCurSum += nums[i];            &#125;            <span class="hljs-keyword">if</span> (nCurSum &gt; nGreatestSum) nGreatestSum = nCurSum;        &#125;        <span class="hljs-keyword">return</span> nGreatestSum;    &#125;&#125;;</code></pre></div><h4 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums.size() &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>)</span></span>;        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//定义初始值</span>        <span class="hljs-keyword">int</span> ans = dp[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.size(); i++) &#123;            dp[i] = <span class="hljs-built_in">std</span>::max(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]);            <span class="hljs-keyword">if</span> (dp[i] &gt; ans) ans = dp[i];        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<span class="hljs-comment">//dp数组大小</span><span class="hljs-comment">//边界</span>dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.size();i++)&#123;dp[i] = max(nums[i], nums[i] + dp[i - <span class="hljs-number">1</span>]);&#125;<span class="hljs-comment">//求出最大值</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator myMax = max_element(dp.begin(), dp.end());<span class="hljs-keyword">return</span> *myMax;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】41.数据流中的中位数</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9141-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9141-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.html</url>
    
    <content type="html"><![CDATA[<h3 id="2020-7-17更新"><a href="#2020-7-17更新" class="headerlink" title="2020.7.17更新"></a>2020.7.17更新</h3><p>左中位数，大顶堆<br>右中位数，小顶堆<br>当奇数个数时，中位数是大顶堆中的top<br>当偶数个数时，中位数是大顶堆的top+小顶堆的top 的平均</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-built_in">std</span>::priority_queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">std</span>::greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; min_q;<span class="hljs-comment">//小顶堆</span>    <span class="hljs-built_in">std</span>::priority_queue&lt;<span class="hljs-keyword">int</span>&gt; max_q;<span class="hljs-comment">//大顶堆</span>    MedianFinder() &#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        max_q.push(num);<span class="hljs-comment">//加到大顶堆</span>        min_q.push(max_q.top());<span class="hljs-comment">//平衡</span>        max_q.pop();        <span class="hljs-keyword">if</span> (max_q.size() &lt; min_q.size()) &#123;<span class="hljs-comment">//维护两个堆中的元素个数</span>            max_q.push(min_q.top());            min_q.pop();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> max_q.size() &gt; min_q.size() ? (<span class="hljs-keyword">double</span>)max_q.top() : (max_q.top() + min_q.top()) * <span class="hljs-number">0.5</span>;    &#125;&#125;;</code></pre></div><p>—.</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>参考剑指offer的思路，要划分出中位数x，则左边均小于x，右边均大于x<br>因此通过堆，可以设置左边为最大堆，堆顶即是左边的最大值，右边设置最大堆，堆顶即是右边的最小值；<br>通过两个堆的总size，<br>如果为奇数，则为中间数字，该值我们存放在minHeap的top中<br>如果为偶数，则为中间两个数/2.0，即minHeap.top()+maxHeap.top()/2<br>大家如果不明白，可以用[2,3,4]和[2,3,4,5]两个例子来手动模拟一下添加的过程，这样能有更清晰的认识</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-comment">/** initialize your data structure here. */</span>priority_queue&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,less&lt;<span class="hljs-keyword">int</span>&gt;&gt; maxHeap;<span class="hljs-comment">//大顶堆</span>priority_queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; minHeap;<span class="hljs-comment">//小顶堆</span>MedianFinder() &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<span class="hljs-keyword">int</span> size = maxHeap.size() + minHeap.size();<span class="hljs-comment">/*</span><span class="hljs-comment">为了保证数据平均分配到两个堆中，因此两个堆中数据的数目之差不能超过1</span><span class="hljs-comment">因此可以假定总数目为偶数时，插入最小堆，否则插入最大堆</span><span class="hljs-comment">如果当前总数目为偶数，插入最小堆</span><span class="hljs-comment">*/</span><span class="hljs-keyword">if</span> ((size&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)<span class="hljs-comment">//判断是否为偶数个</span>&#123;<span class="hljs-comment">/*</span><span class="hljs-comment">如果最大堆个数不为0</span><span class="hljs-comment">且出现num比最大堆中的top还要小，如果直接插入最小堆(放到右边)</span><span class="hljs-comment">是不行的，因为没有遵守右边均大于左边，因此要先插入到最大堆</span><span class="hljs-comment">在最大堆中，取出top，再插入到最小堆</span><span class="hljs-comment">*/</span><span class="hljs-keyword">if</span> (maxHeap.size() &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; maxHeap.top()) &#123;maxHeap.push(num);<span class="hljs-comment">//入堆</span>num = maxHeap.top();<span class="hljs-comment">//去堆顶元素</span>maxHeap.pop();<span class="hljs-comment">//出堆</span>&#125;minHeap.push(num);<span class="hljs-comment">//插入最小堆</span>&#125;<span class="hljs-comment">//如果当前总数目为奇数，插入最大堆</span><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/*</span><span class="hljs-comment">如果最小堆个数不为0</span><span class="hljs-comment">且出现num比最小堆中的top还要大，如果直接插入最大堆(放到左边)</span><span class="hljs-comment">是不行的，因为没有遵守左边均小于右边，因此要先插入到最小堆</span><span class="hljs-comment">在最小堆中，取出top，再插入到最小堆</span><span class="hljs-comment">*/</span><span class="hljs-keyword">if</span> (minHeap.size()&gt;<span class="hljs-number">0</span>&amp;&amp;num&gt; minHeap.top())&#123;minHeap.push(num);num = minHeap.top();minHeap.pop();&#125;maxHeap.push(num);<span class="hljs-comment">//插入最大堆</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> size = minHeap.size() + maxHeap.size();<span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//size为0</span><span class="hljs-keyword">if</span> ((size&amp;<span class="hljs-number">1</span>))<span class="hljs-comment">//判断是否为奇数个</span>&#123;<span class="hljs-keyword">return</span> minHeap.top();&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//偶数</span>&#123;<span class="hljs-keyword">return</span> (maxHeap.top() + minHeap.top()) / <span class="hljs-number">2.0</span>;&#125;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优先队列</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】15.二进制中1的个数</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9115-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9115-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>1、按位判断<br>判断每一位是否为<br>2、N&amp;N-1<br>一个数n与一个比它小1的数(n-1)与(&amp;)运算，会消除n中最低位的1</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="按位判断"><a href="#按位判断" class="headerlink" title="按位判断"></a>按位判断</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">32</span>;i++)&#123;<span class="hljs-keyword">int</span> t = <span class="hljs-number">1</span> &lt;&lt; i;<span class="hljs-keyword">if</span> (t &amp; n) count++;&#125;<span class="hljs-keyword">return</span> count;&#125;&#125;;</code></pre></div><h4 id="N-amp-N-1"><a href="#N-amp-N-1" class="headerlink" title="N&amp;N-1"></a>N&amp;N-1</h4><p><code>cppclass Solution {public:    int hammingWeight(uint32_t n) {        int count = 0;        while (n!=0)        {            n &amp;= n - 1;            count++;        }        return count;    }};</code><strong>加粗样式</strong></p>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】39.数组中出现次数超过一半的数字</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9139-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9139-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.html</url>
    
    <content type="html"><![CDATA[<h3 id="2020-7-15"><a href="#2020-7-15" class="headerlink" title="2020.7.15"></a>2020.7.15</h3><p>增加了新的方法，使用快排中的Partion函数实现，Partition函数每次会返回排在第j大的数及其位置，在leetcode上的前44个case可以跑通，但是不知道为什么在leetcode上的最后一个case总是超时，由于该方法会改变原始数组的顺序，因此如果不能改变顺序的这种方法不可行，还是应该采用摩尔投票法</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">return</span> MoreThanHalfNum(nums);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MoreThanHalfNum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> middle = nums.size() &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> end = nums.size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> index = Partition(nums, start, end);        <span class="hljs-keyword">while</span> (index != middle) &#123;            <span class="hljs-keyword">if</span> (index &gt; middle) &#123;                end = index - <span class="hljs-number">1</span>;                index = Partition(nums, start, end);            &#125;            <span class="hljs-keyword">else</span> &#123;                start = index + <span class="hljs-number">1</span>;                index = Partition(nums, start, end);            &#125;        &#125;        <span class="hljs-keyword">int</span> result = nums[middle];        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-comment">//使主元排在第j位</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> e)</span> </span>&#123;        <span class="hljs-keyword">int</span> index = (rand() % (e - s + <span class="hljs-number">1</span>)) + s;        swap(nums[index], nums[s]);        <span class="hljs-keyword">int</span> i = s + <span class="hljs-number">1</span>, j = e;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[i] &lt;= nums[s]) i++;            <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[j] &gt;= nums[s]) j--;            <span class="hljs-keyword">if</span> (i &gt; j) <span class="hljs-keyword">break</span>;            swap(nums[i], nums[j]);        &#125;        swap(nums[j], nums[s]);        <span class="hljs-keyword">return</span> j;    &#125;&#125;;</code></pre></div><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>利用题目所给数组特性，所求元素在数组中出现次数超过一半<br>设置两个变量：<br>result//记录当前元素值<br>times//记录次数<br>当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数+1；如果下一个数字和我们之前保存的数字不同，则次数-1.如果次数为0，那么我们需要保存下一个数字<br>，并把次数设为1.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-keyword">int</span> result=nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">int</span> times = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it=nums.begin()+<span class="hljs-number">1</span>;it!=nums.end();it++)&#123;<span class="hljs-comment">//次数为0，则更新result</span><span class="hljs-keyword">if</span> (times == <span class="hljs-number">0</span>) &#123;result = *it;times = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//相等，次数+1</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(result==*it)&#123;times++;&#125;<span class="hljs-comment">//不相等，次数-1</span><span class="hljs-keyword">else</span>&#123;times--;&#125;&#125;<span class="hljs-keyword">return</span> result;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>Partition分割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】40.最小的k个数</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9140-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9140-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.html</url>
    
    <content type="html"><![CDATA[<h3 id="2020-7-15更新"><a href="#2020-7-15更新" class="headerlink" title="2020.7.15更新"></a>2020.7.15更新</h3><h4 id="分割算法O-n"><a href="#分割算法O-n" class="headerlink" title="分割算法O(n)"></a>分割算法O(n)</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || arr.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();        <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> e = arr.size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> index = Partition(arr, s, e);        <span class="hljs-keyword">while</span> (index != k - <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">if</span> (index &gt; k - <span class="hljs-number">1</span>) &#123;                e = index - <span class="hljs-number">1</span>;<span class="hljs-comment">//注意每次要修改e,s</span>                index = Partition(arr, s, e);            &#125;            <span class="hljs-keyword">else</span>            &#123;                s = index + <span class="hljs-number">1</span>;                index = Partition(arr, s, e);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(arr.begin(), arr.begin() + k);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> e)</span> </span>&#123;        <span class="hljs-keyword">int</span> index = (rand() % (e - s + <span class="hljs-number">1</span>)) + s;<span class="hljs-comment">//随机获取[s,e]的位置</span>        <span class="hljs-built_in">std</span>::swap(arr[index], arr[s]);<span class="hljs-comment">//交换</span>        <span class="hljs-keyword">int</span> i = s + <span class="hljs-number">1</span>, j = e;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; arr[i] &lt;= arr[s]) i++;            <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; arr[j] &gt;= arr[s]) j--;            <span class="hljs-keyword">if</span> (i &gt; j) <span class="hljs-keyword">break</span>;            <span class="hljs-built_in">std</span>::swap(arr[i], arr[j]);        &#125;        <span class="hljs-built_in">std</span>::swap(arr[j], arr[s]);        <span class="hljs-keyword">return</span> j;    &#125;&#125;;</code></pre></div><p>快排切分时间复杂度分析： 因为我们是要找下标为k的元素，第一次切分的时候需要遍历整个数组 (0 ~ n) 找到了下标是 j 的元素，假如 k 比 j 小的话，那么我们下次切分只要遍历数组 (0~k-1)的元素就行啦，反之如果 k 比 j 大的话，那下次切分只要遍历数组 (k+1～n) 的元素就行啦，总之可以看作每次调用 partition 遍历的元素数目都是上一次遍历的 1/2，因此时间复杂度是 N + N/2 + N/4 + … + N/N = 2N, 因此时间复杂度是 O(N)O(N)。</p><h4 id="大顶堆算法O-nlogk"><a href="#大顶堆算法O-nlogk" class="headerlink" title="大顶堆算法O(nlogk)"></a>大顶堆算法O(nlogk)</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">//std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; q2;//小顶堆</span>        <span class="hljs-built_in">std</span>::priority_queue&lt;<span class="hljs-keyword">int</span>&gt; q;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : arr) &#123;            q.push(e);            <span class="hljs-keyword">if</span> (q.size() &gt; k) &#123;<span class="hljs-comment">//如果数量超过k个，弹出堆顶</span>                q.pop();            &#125;        &#125;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;        <span class="hljs-keyword">while</span> (!q.empty())        &#123;            ans.push_back(q.top());            q.pop();        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><p>本题是求前 K 小，因此用一个容量为 K 的大根堆，每次 poll 出最大的数，那堆中保留的就是前 K 小啦（注意不是小根堆！小根堆的话需要把全部的元素都入堆，那是 O(NlogN)😂，就不是 O(NlogK)～～）</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>维护一个k大小的大顶堆，如果当前堆的size&gt;k，则弹出</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function"></span>&#123;priority_queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, less&lt;<span class="hljs-keyword">int</span>&gt;&gt; q;<span class="hljs-comment">//大顶堆</span>        <span class="hljs-comment">//priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;//小顶堆</span><span class="hljs-keyword">for</span> (<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = arr.begin(); it != arr.end(); it++)&#123;    q.push(*it);<span class="hljs-comment">//堆的size&lt;=k，则加入到堆中</span><span class="hljs-keyword">if</span>(q.size()&gt;k) q.pop();&#125;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<span class="hljs-keyword">while</span> (!q.empty())&#123;res.push_back(q.top());q.pop();&#125;<span class="hljs-keyword">return</span> res;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优先队列</tag>
      
      <tag>剑指offer</tag>
      
      <tag>Partition分割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】38.字符串的排列</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9138-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9138-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>第一步求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换。<br>第二步固定第一个字符，求后面所有字符的排列。<br>这时候仍然把后面的所有字符分成两部分：后面字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换。<br>举例如下<br>以字符串”abc”为例<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL2IzMDZlM2JmY2UxMDY1MjJmMGVmOTY4M2Q0MjRmZDc4NDQ0YzFlZTJlMDY4OWQyN2YyM2IxODhjZDc0ZTZmMzYtaW1hZ2UucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="image.png"><br>对于重复结果的处理，我采用set进行解决</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; res;<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>&gt; tempRes;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<span class="hljs-keyword">if</span> (s.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<span class="hljs-comment">//字符串排列</span>solvePermutation(s, &amp;s[<span class="hljs-number">0</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>&gt;::iterator it=tempRes.begin();it!=tempRes.end();it++)&#123;res.push_back(*it);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solvePermutation</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">char</span>* sBegin)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//sBegin所指字符为空'\0'，将当前字符串s存储起来</span><span class="hljs-keyword">if</span> (*sBegin == <span class="hljs-string">'\0'</span>) tempRes.insert(s);<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//将字符串s中的字符从sBegin位置开始依次和当前字符串的首字符交换位置</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>* sCh = sBegin; *sCh != <span class="hljs-string">'\0'</span>; sCh++)&#123;<span class="hljs-comment">//交换位置</span><span class="hljs-keyword">char</span> temp = *sBegin;*sBegin = *sCh;*sCh = temp;<span class="hljs-comment">//交换完后继续全排列</span>solvePermutation(s, sBegin + <span class="hljs-number">1</span>);<span class="hljs-comment">//回溯</span>temp = *sBegin;*sBegin = *sCh;*sCh = temp;&#125;&#125;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>递归</tag>
      
      <tag>全排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】11.旋转数组的最小数字</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9111-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9111-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.html</url>
    
    <content type="html"><![CDATA[<p><strong><em>7.1号更新</em></strong></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分查找</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;        <span class="hljs-keyword">int</span> index1 = <span class="hljs-number">0</span>;<span class="hljs-comment">//左指针</span>        <span class="hljs-keyword">int</span> index2 = numbers.size() - <span class="hljs-number">1</span>;<span class="hljs-comment">//右指针</span>        <span class="hljs-keyword">int</span> midIndex = index1;<span class="hljs-comment">//中间位置</span>        <span class="hljs-keyword">while</span> (numbers[index1]&gt;=numbers[index2])        &#123;            <span class="hljs-keyword">if</span> (index2 - index1 == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//索引相邻，说明index2即为最小值</span>                midIndex = index2;                <span class="hljs-keyword">break</span>;            &#125;            midIndex = index1 + (index2 - index1) / <span class="hljs-number">2</span>;            <span class="hljs-comment">//当index1和index2和midIndex相等，需要顺序查找</span>            <span class="hljs-keyword">if</span> (numbers[index1] == numbers[index2] &amp;&amp; numbers[midIndex] == numbers[index1]) &#123;                <span class="hljs-keyword">int</span> result = numbers[index1];                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index1 + <span class="hljs-number">1</span>; i &lt;= index2; ++i) &#123;                    <span class="hljs-keyword">if</span> (result &gt; numbers[i]) result = numbers[i];<span class="hljs-comment">//找最小值</span>                &#125;                <span class="hljs-keyword">return</span> result;            &#125;            <span class="hljs-keyword">if</span> (numbers[midIndex] &gt;= numbers[index1]) index1 = midIndex;<span class="hljs-comment">//中间值比左边大,说明在左侧的递增子区间中</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[midIndex]&lt;=numbers[index2])index2 = midIndex;<span class="hljs-comment">//中间值比右边小，说明在右侧的递增子区间中</span>        &#125;        <span class="hljs-keyword">return</span> numbers[midIndex];    &#125;&#125;;</code></pre></div><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>看二分的解析头炸了，就采用传统的循环方法，感觉效果也不错<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tLzcyM2JjM2RiN2M0MGMxYWQ1YjY4Zjk1YzljNzcxZGJmY2UwYWVmZjA0YzI5NGEwZGM2Njk5MzBkOTNlYzc4MDItaW1hZ2UucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="image.png"><br>在另一道<a href="https://pic.leetcode-cn.com/c127219380f411a127d355e52062a99d19453c005c6dd4283617f28934b831f7" target="_blank" rel="noopener">154.寻找旋转排序数组中的最小值</a>中<br>执行耗时如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL2ZiNTRhZTQzMzJhNjM1NWNkZDQ4MzQ5NTlkNjE0Yjk4MWFmMDJiZjFjZjE1NTUxNmM4OGVkNTlhNjIwNGIyN2QtaW1hZ2UucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="image.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;<span class="hljs-keyword">if</span> (numbers.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//特判</span><span class="hljs-keyword">int</span> min = numbers[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;numbers.size();i++)&#123;<span class="hljs-keyword">if</span> (min &gt; numbers[i]) <span class="hljs-keyword">return</span> numbers[i];&#125;<span class="hljs-keyword">return</span> min;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】16.数值的整数次方</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9116-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9116-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.html</url>
    
    <content type="html"><![CDATA[<p>7.3号更新</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题的细节很多<br>1、要对无效输入进行判断<br>2、对指数的不同范围分别进行计算<br>3、计算Pow函数的优化</p><p>平常的Pow函数会这么计算</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Power</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">int</span> exponent)</span> </span>&#123;    <span class="hljs-keyword">double</span> result = <span class="hljs-number">1.0f</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= exponent; i++) &#123;        result *= base;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>上述代码的时间复杂度O(n)，进一步可以采用如下公式简化<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tLzllZjZmZWIyMTE0MWFmNGQzNmE2OWY1MDczYWNhNDA2Mzc4NjA2ZDAwYmYxMGYyZTI0YTVkYmU4MWZlMTIyZTgtaW1hZ2UucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="image.png"><br>实现代码如下</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">PowerWithUnsignedExponent</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">long</span> exponent)</span> </span>&#123;    <span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;    <span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> base;    <span class="hljs-keyword">double</span> result = PowerWithUnsignedExponent(base, exponent &gt;&gt; <span class="hljs-number">1</span>);<span class="hljs-comment">//为偶数时</span>    result *= result;    <span class="hljs-keyword">if</span> (exponent &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>)<span class="hljs-comment">//为奇数时</span>        result *= base;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">bool</span> g_InvalidInput = <span class="hljs-literal">false</span>;<span class="hljs-comment">//判断是否为无效输入</span>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span> (equal(x, <span class="hljs-number">0.0</span>) &amp;&amp; n &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//无效输入,对于x=0时，n为正数时为0，n为非正数时无意义</span>            g_InvalidInput = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;        &#125;        <span class="hljs-keyword">double</span> result;        <span class="hljs-keyword">long</span> num = n;        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//指数小于0</span>            num = -num;            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / PowerWithUnsignedExponent(x, num);        &#125;        <span class="hljs-comment">//指数大于等于0</span>        <span class="hljs-keyword">return</span> PowerWithUnsignedExponent(x, num);    &#125;    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">PowerWithUnsignedExponent</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">long</span> exponent)</span> </span>&#123;        <span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;        <span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> base;        <span class="hljs-keyword">double</span> result = PowerWithUnsignedExponent(base, exponent &gt;&gt; <span class="hljs-number">1</span>);<span class="hljs-comment">//为偶数时</span>        result *= result;        <span class="hljs-keyword">if</span> (exponent &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>)<span class="hljs-comment">//为奇数时</span>            result *= base;        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-keyword">double</span> n1, <span class="hljs-keyword">double</span> n2)</span> </span>&#123;<span class="hljs-comment">//浮点数大小判断</span>        <span class="hljs-keyword">if</span> (n1 - n2&lt;<span class="hljs-number">0.0000001</span> &amp;&amp; n1 - n2&gt;<span class="hljs-number">-0.0000001</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//|n1-n2|&lt;p</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre></div><h3 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h3><p>我发现此处使用unsigned int来保存exponent，过不了当int为负的最小值的case</p><hr><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>本道题目做了很久才通过，感觉有很多的坑等着自己。<br>首先刚拿到手，觉得题目很简单，开始时，分了两种情况（指数为正和负）+一些特殊情况（底数为0，指数为0）在做<br>但运行过程中，仍然有报错，第一个错误时n=-2147483648时的错误，刚开始没有反应过来，后来通过题意，才想明白，自己平时做题也没有去考虑过int型的范围，<br>在n=-2147483648时，由于我先转换成了abs(n)，而正数n最大值为2147483647，因此报错。<br>第二个遇到的问题是，总是运行超时，一开始我写的pow()函数，是一般的循环算法，但是进行运行测试发现需要2700多ms，所以这种方法不行；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL2VlODhjNzFmMDhmZGQ3MmQyMzgzNjQ0NDViOWYwMWNhNjAzMzVmOGM5ZThhOTFkODBmNmU4YzFhMWJjNzlkNDAtaW1hZ2UucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="image.png"><br>剑指offer中的公式<br>参考了剑指offer中的转换为递归的思路，<br>n为偶数，pow(8)=pow(4)<em>pow(4),pow(4)=pow(2)</em>pow(2),pow(2)=pow(1)<em>pow(1)<br>n为奇数，pow(9)=pow(4)</em>pow(4)<em>base,pow(4)=pow(2)</em>pow(2),pow(2)=pow(1)*pow(1)<br>在其编写的代码中，也了解到通过异常捕获，使程序鲁棒性更强，通过位运算，能实运行速度更加地快（B格也高了不少）；<br>总之，学习了。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPSILON 0.000001 <span class="hljs-comment">//根据精度需要进行调整</span></span><span class="hljs-keyword">bool</span> g_InvalidInput = <span class="hljs-literal">false</span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-comment">//基数为0且指数&lt;0</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(x - <span class="hljs-number">0.0</span>) &lt; EPSILON &amp;&amp; n &lt;= <span class="hljs-number">0</span>)&#123;g_InvalidInput = <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;&#125;<span class="hljs-comment">//如果指数为负时，为临界值时，要特殊处理</span><span class="hljs-keyword">if</span> (n == <span class="hljs-number">-2147483648</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / (x * Pow(x, <span class="hljs-built_in">abs</span>(n + <span class="hljs-number">1</span>)));&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">int</span> absN = <span class="hljs-built_in">abs</span>(n);<span class="hljs-comment">//指数&lt;0，返回其倒数</span><span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> ? Pow(x, absN) : <span class="hljs-number">1.0</span> / Pow(x, absN);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Pow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">int</span> e)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (e == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (e == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> base;<span class="hljs-comment">//右移1位，相等于/2，位运算速度更快</span><span class="hljs-keyword">double</span> result = Pow(base, e &gt;&gt; <span class="hljs-number">1</span>);result *= result;<span class="hljs-comment">//如果指数为奇数，根据公式，最后还要*base</span><span class="hljs-comment">//此处判断奇数，通过与1相与，速度更快</span><span class="hljs-keyword">if</span> (e &amp; <span class="hljs-number">0x1</span> == <span class="hljs-number">1</span>) result*= base;<span class="hljs-keyword">return</span> result;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>全排列</tag>
      
      <tag>大数问题</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】面试题10-II.青蛙跳台阶问题</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9810-ii-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9810-ii-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>把n级台阶时的跳法看出n的函数，记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：<br>一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；<br>二是第一次跳2级，此时跳法数目等于剩下的n-2级台阶的跳法数目，即为f(n-2.<br>因此，n级台阶的不同跳法的总数f(n)=f(n-1)+f(n-2);<br>于是此问题转换为求斐波那契数列问题。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">int</span> m = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<span class="hljs-keyword">return</span> Ways(n, dp);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Ways</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; dp)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//递归边界</span><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//状态转移方程</span><span class="hljs-keyword">if</span> (dp[n] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[n];<span class="hljs-keyword">else</span>&#123;dp[n] = (Ways(n<span class="hljs-number">-1</span>,dp) + Ways(n<span class="hljs-number">-2</span>,dp))%m;<span class="hljs-keyword">return</span> dp[n];&#125;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Blog】Markdown的写作技巧</title>
    <link href="/%E3%80%90blog%E3%80%91markdown%E7%9A%84%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7.html"/>
    <url>/%E3%80%90blog%E3%80%91markdown%E7%9A%84%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7.html</url>
    
    <content type="html"><![CDATA[<h2 id="Markdown中的公式书写"><a href="#Markdown中的公式书写" class="headerlink" title="Markdown中的公式书写"></a>Markdown中的公式书写</h2><p>1.markdown中的公式在线编辑网站</p><blockquote><p><a href="https://www.codecogs.com/latex/eqneditor.php" target="_blank" rel="noopener">https://www.codecogs.com/latex/eqneditor.php</a></p></blockquote><p>2.一些MarkDown 公式书写的指导手册</p><blockquote><p><a href="https://blog.csdn.net/u012736685/article/details/87009449" target="_blank" rel="noopener">https://blog.csdn.net/u012736685/article/details/87009449</a></p></blockquote><p>3.一些书写规范</p><blockquote><p>在行内的公式写在<code>$ $</code>内，行间的公式写在<code>$$ $$</code>内</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>【术】博客撰写</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
