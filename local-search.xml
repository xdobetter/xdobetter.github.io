<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【Blog】Markdown的写作技巧</title>
    <link href="/%E3%80%90blog%E3%80%91markdown%E7%9A%84%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7.html"/>
    <url>/%E3%80%90blog%E3%80%91markdown%E7%9A%84%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7.html</url>
    
    <content type="html"><![CDATA[<h2 id="Markdown中的公式书写"><a href="#Markdown中的公式书写" class="headerlink" title="Markdown中的公式书写"></a>Markdown中的公式书写</h2><p>1.markdown中的公式在线编辑网站</p><blockquote><p><a href="https://www.codecogs.com/latex/eqneditor.php" target="_blank" rel="noopener">https://www.codecogs.com/latex/eqneditor.php</a></p></blockquote><p>2.一些MarkDown 公式书写的指导手册</p><blockquote><p><a href="https://blog.csdn.net/u012736685/article/details/87009449" target="_blank" rel="noopener">https://blog.csdn.net/u012736685/article/details/87009449</a></p></blockquote><p>3.一些书写规范</p><blockquote><p>在行内的公式写在<code>$ $</code>内，行间的公式写在<code>$$ $$</code>内</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>【术】博客撰写</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】46. 把数字翻译成字符串</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9146-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9146-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h5 id="第一步：定义数组元素的含义"><a href="#第一步：定义数组元素的含义" class="headerlink" title="第一步：定义数组元素的含义"></a>第一步：定义数组元素的含义</h5><p>题目要求的是一个数字有多少种不同的翻译方法，因此设<code>dp[i]</code>代表第i个结尾的数字的翻译方案数量</p><h5 id="第二步：找出关系数组元素间的关系式"><a href="#第二步：找出关系数组元素间的关系式" class="headerlink" title="第二步：找出关系数组元素间的关系式"></a>第二步：找出关系数组元素间的关系式</h5><p>若$x_{i}$和$x_{i-1}$组成的数字可以被翻译，<br>则<code>dp[i]=dp[i-1]+dp[i-2]</code>,$x_{i-1}x_{i}\epsilon [10,25]$;<br>否则<code>dp[i]=dp[i-1]</code>,$x_{i-1}x_{i}\epsilon [1,10)\cup\left ( 25,99 \right ]$</p><h5 id="第三步：初始状态"><a href="#第三步：初始状态" class="headerlink" title="第三步：初始状态"></a>第三步：初始状态</h5><p><code>dp[0]=dp[1]=1</code> ,即“无数字”和“第1位数字”的翻译方法数量均为1</p><h5 id="第四步：返回值"><a href="#第四步：返回值" class="headerlink" title="第四步：返回值"></a>第四步：返回值</h5><p><code>dp[n]</code>，即此数字的翻译方案数量</p><h4 id="代码1——字符串遍历"><a href="#代码1——字符串遍历" class="headerlink" title="代码1——字符串遍历"></a>代码1——字符串遍历</h4><p>利用迭代方式编写</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ans = <span class="hljs-built_in">std</span>::to_string(num);        <span class="hljs-keyword">if</span> (ans.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//特判</span>        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(ans.size() + <span class="hljs-number">1</span>)</span></span>;        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= ans.size(); i++) &#123;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> temp = ans.substr(i - <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);            <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-string">"10"</span> || temp&gt;<span class="hljs-string">"25"</span>) dp[i] = dp[i - <span class="hljs-number">1</span>];<span class="hljs-comment">//不可以翻译</span>            <span class="hljs-keyword">else</span> dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<span class="hljs-comment">//可以翻译</span>        &#125;        <span class="hljs-keyword">return</span> dp[ans.size()];    &#125;&#125;;</code></pre></div><h4 id="代码2——数字求余"><a href="#代码2——数字求余" class="headerlink" title="代码2——数字求余"></a>代码2——数字求余</h4><p>利用递归方式编写</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">return</span> f(num);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (num % <span class="hljs-number">100</span> &lt; <span class="hljs-number">10</span> || num % <span class="hljs-number">100</span> &gt; <span class="hljs-number">25</span>) &#123;            <span class="hljs-keyword">return</span> f(num / <span class="hljs-number">10</span>);<span class="hljs-comment">//不可以翻译</span>        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> f(num / <span class="hljs-number">10</span>) + f(num / <span class="hljs-number">100</span>);<span class="hljs-comment">//可以翻译</span>        &#125;    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】45. 把数组排成最小的数</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9145-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9145-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过题意可知，不管这些数字如何排列，形成的数字位数时不变的。所以如果高位的数字越小，则最终的结果也就越小。下面的<code>n</code>为数字的个数</p><ul><li>对于<code>n=2</code>的情况<br>如[26,38],根据高位越小越好，可知，我们应该排列成2638</li><li>对于<code>n&gt;2</code>的情况<br>如[26,29,1]，根据我们定义的规则，一定是将第一位小的数字放在最高位，因此先选出1，对于剩下两个数字，由于第1位数字相同，我们会比较第2位，因此我们最终会排列成12629<br>从上面我们可以发现的排序规则就是，如果第1位小，就将其排到最前面，如果第1位相等，则比较第2位，直到数字位数结束。 </li></ul><p>注意，这里的排列规则和字符串的排列规则有区别，比如，2和20，明显应该20排在2前面，结果才会更小(202&lt;220)，因此我们可以得到最终的排序规则应该是<br>如果<code>s1+s2&lt;s2+s1</code>，那么<code>s1&lt;s2</code><br>因此我们可以写一个<code>cmp</code>函数</p><div class="hljs"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; s1, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; s2)</span> </span>&#123;    <span class="hljs-keyword">return</span> s1 + s2 &lt; s2 + s1;&#125;</code></pre></div><p>下面代码分别给出了<code>cmp</code>函数写排序规则和<code>lambda</code>写排序规则两种形式</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>1.初始化字符串数组<code>strs</code>，存储结果的字符串<code>ans</code><br>2.遍历初始的整型数组<code>nums</code>，将其元素加入<code>strs</code><br>3.调用排序<br>4.遍历<code>strs</code>，将其元素相加即为最终结果</p><p>由于使用了快排，时间复杂度<code>O(nlogn)</code><br>空间负责度<code>O(n)</code></p><h4 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h4><h5 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; s1, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; s2)</span> </span>&#123; <span class="hljs-comment">//注意这里的cmp函数可以写作Solution外</span>    <span class="hljs-keyword">return</span> s1 + s2 &lt; s2 + s1;&#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-keyword">public</span>:     <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;         <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; strs;         <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ans;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums) &#123;             strs.push_back(<span class="hljs-built_in">std</span>::to_string(n));         &#125;         <span class="hljs-built_in">std</span>::sort(strs.begin(), strs.end(), cmp);         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : strs) &#123;             ans += s;         &#125;         <span class="hljs-keyword">return</span> ans;     &#125; &#125;;</code></pre></div><h5 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; s1, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s2)</span> </span>&#123;<span class="hljs-comment">//也可以写作solution内，但要加上static，否则会报错</span>        <span class="hljs-keyword">return</span> s1 + s2 &lt; s2 + s1;    &#125;    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; strs;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ans;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums) &#123;            strs.push_back(<span class="hljs-built_in">std</span>::to_string(n));        &#125;        <span class="hljs-built_in">std</span>::sort(strs.begin(), strs.end(), cmp);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : strs) &#123;            ans += s;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><h5 id="代码3"><a href="#代码3" class="headerlink" title="代码3"></a>代码3</h5><p>利用lambda表达式写排序的规则，如果不熟悉lambda，可以采用上述方法即可</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//lambda表达式排序</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; strs;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ans;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;            strs.push_back(<span class="hljs-built_in">std</span>::to_string(nums[i]));        &#125;        <span class="hljs-comment">//lambda表达式</span>        <span class="hljs-built_in">std</span>::sort(strs.begin(), strs.end(), [](<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; s1, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; s2) &#123;<span class="hljs-keyword">return</span> s1 + s2 &lt; s2 + s1; &#125;);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.size(); i++) &#123;            ans += strs[i];        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>字符串</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】215.数组中的第K个最大元素</title>
    <link href="/%E3%80%90leetcode%E3%80%91215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html"/>
    <url>/%E3%80%90leetcode%E3%80%91215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>使用快速排序中的Partition函数，获得第j位上的元素，如果第j位和k-1相同，则直接返回即可<br>时间复杂度O(N)</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> end = nums.size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> index = Partition(nums, start, end);        <span class="hljs-keyword">while</span> (index!=k<span class="hljs-number">-1</span>) &#123;            <span class="hljs-keyword">if</span> (index &gt; k - <span class="hljs-number">1</span>) &#123;                end = index - <span class="hljs-number">1</span>;                index = Partition(nums, start, end);            &#125;            <span class="hljs-keyword">else</span> &#123;                start = index + <span class="hljs-number">1</span>;                index = Partition(nums, start, end);            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[index];    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;        <span class="hljs-keyword">int</span> index = (rand() % (end - start + <span class="hljs-number">1</span>)) + start;        <span class="hljs-built_in">std</span>::swap(nums[start], nums[index]);<span class="hljs-comment">//start为主元</span>        <span class="hljs-keyword">int</span> i = start + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> j = end;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-comment">//从大到小排序</span>            <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[i] &gt;= nums[start]) i++;<span class="hljs-comment">//注意要加上"="号</span>            <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[j] &lt;= nums[start]) j--;            <span class="hljs-keyword">if</span> (i &gt; j) <span class="hljs-keyword">break</span>;            <span class="hljs-built_in">std</span>::swap(nums[i], nums[j]);        &#125;        <span class="hljs-built_in">std</span>::swap(nums[j], nums[start]);        <span class="hljs-keyword">return</span> j;    &#125;&#125;;</code></pre></div><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>小顶堆，维护一个k大的小顶堆，最终的小顶堆的堆顶，即为第k大的元素<br>时间复杂度O(nlogk)</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-built_in">std</span>::priority_queue&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-built_in">std</span>::greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; q;<span class="hljs-comment">//小元素放在队首，小顶堆 </span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : nums) &#123;            q.push(e);            <span class="hljs-keyword">if</span> (q.size() &gt; k) &#123;                q.pop();            &#125;        &#125;        <span class="hljs-keyword">return</span> q.top();    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>优先队列</tag>
      
      <tag>Partition算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】36. 二叉搜索树与双向链表</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9136-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9136-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>算法流程：<br><code>Node* treeToDoublyList(Node* root)</code><br>1.特例处理：若结点root为空，直接返回<br>2.转化为排序双向链表：调用<code>inorder(Node* root)</code><br>3.构建循环链表：head和pre双向结点引用<br>4.返回头结点</p><p><code>void inorder(Node* root)</code><br>中序遍历的改写，在访问根节点时，同时更新pre，head的值，使其能够双向连接</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    Node* pre=<span class="hljs-literal">nullptr</span>, *head;<span class="hljs-comment">//需要初始化pre=nullptr,head为链表头结点，pre为链表前驱结点</span>    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//特例处理</span>        inorder(root);<span class="hljs-comment">//中序遍历</span>        <span class="hljs-comment">//遍历完成后，head指向头结点，pre指向尾结点，因此要修改head和pre的双向结点引用，使其首尾相连</span>        head-&gt;left = pre;        pre-&gt;right = head;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-comment">//中序遍历</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(Node* root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归边界</span>        inorder(root-&gt;left);        <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">nullptr</span>) head = root;<span class="hljs-comment">//pre为空，说明此结点为链表头结点</span>        <span class="hljs-keyword">else</span> &#123;            pre-&gt;right = root;<span class="hljs-comment">//前驱结点的后继即为root</span>            root-&gt;left = pre;<span class="hljs-comment">//当前结点的前驱即为pre</span>        &#125;        pre = root;<span class="hljs-comment">//pre更新，结点root是后继结点的pre</span>        inorder(root-&gt;right);    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BST</tag>
      
      <tag>剑指offer</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】35. 复杂链表的复制</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9135-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9135-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>算法流程：</p><ol><li>建立映射<blockquote><p>对新链表结点和原链表结点建立<code>hashmap</code>的映射关系，原链表结点为<code>key</code>，新链表结点为<code>value</code></p></blockquote></li><li>赋值 <blockquote><p>通过<code>hashmap</code>将原链表的<code>next</code>，<code>random</code>所指结点赋给新链表，注意赋值时，要判断该两值是否不为空，因为建立<code>hashmap</code>时，没有建立<code>null</code>，<code>null</code>的映射</p></blockquote></li><li>返回新链表头结点<code>hashmap[head]</code></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;Node*, Node*&gt; listMap;        Node* p = head;        <span class="hljs-comment">//将原链表和新链表建立映射关系</span>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>) &#123;            listMap[p] = <span class="hljs-keyword">new</span> Node(p-&gt;val);            p = p-&gt;next;        &#125;        p = head;        <span class="hljs-comment">//将原链表的next，random值赋给新链表</span>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>) &#123;            <span class="hljs-keyword">if</span>(p-&gt;next)  listMap[p]-&gt;next = listMap[p-&gt;next];<span class="hljs-comment">//如果p-&gt;next不为空</span>            <span class="hljs-keyword">if</span>(p-&gt;random) listMap[p]-&gt;random = listMap[p-&gt;random];<span class="hljs-comment">//如果p-&gt;random不为空</span>            p = p-&gt;next;        &#125;        <span class="hljs-keyword">return</span> listMap[head];    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】33.二叉搜索树的后序遍历序列</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9133-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9133-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BST</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【SUM】二叉树的遍历方法</title>
    <link href="/%E3%80%90sum%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95.html"/>
    <url>/%E3%80%90sum%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><h5 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h5><h5 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h5><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h5 id="递归版-1"><a href="#递归版-1" class="headerlink" title="递归版"></a>递归版</h5><h5 id="非递归版-1"><a href="#非递归版-1" class="headerlink" title="非递归版"></a>非递归版</h5><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><h5 id="递归版-2"><a href="#递归版-2" class="headerlink" title="递归版"></a>递归版</h5><h5 id="非递归版-2"><a href="#非递归版-2" class="headerlink" title="非递归版"></a>非递归版</h5><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span>      <span class="hljs-keyword">int</span> val;      TreeNode *left;      TreeNode *right;      TreeNode(<span class="hljs-keyword">int</span> x) : val(x), left(<span class="hljs-literal">NULL</span>), right(<span class="hljs-literal">NULL</span>) &#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ans;        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;        q.push(root);<span class="hljs-comment">//将根结点root加入队列q</span>        <span class="hljs-keyword">while</span> (!q.empty()) &#123;            TreeNode* front = q.front();<span class="hljs-comment">//取出队首结点，访问它</span>            ans.push_back(front-&gt;val);            q.pop();<span class="hljs-comment">//弹出</span>            <span class="hljs-keyword">if</span> (front-&gt;left != <span class="hljs-literal">nullptr</span>) q.push(front-&gt;left);<span class="hljs-comment">//左子树不为空，压入左子树</span>            <span class="hljs-keyword">if</span> (front-&gt;right != <span class="hljs-literal">nullptr</span>) q.push(front-&gt;right);<span class="hljs-comment">//右子树不为空，压入右子树</span>        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ans;        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;        q.push(root);        <span class="hljs-keyword">while</span> (!q.empty()) &#123;            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;            <span class="hljs-keyword">int</span> len = q.size();<span class="hljs-comment">//这里的size要提前拿，不要写作下面的循环中</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;                TreeNode* front = q.front();                temp.push_back(front-&gt;val);                q.pop();                <span class="hljs-keyword">if</span> (front-&gt;left != <span class="hljs-literal">nullptr</span>) q.push(front-&gt;left);                <span class="hljs-keyword">if</span> (front-&gt;right != <span class="hljs-literal">nullptr</span>) q.push(front-&gt;right);            &#125;            ans.push_back(temp);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SUM</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】31. 栈的压入、弹出序列</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9131-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9131-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>算法流程：</p><ol><li>初始化，辅助栈tempS和弹出序列的索引i</li><li>遍历压入序列pushed<ul><li>压入pushed的元素e</li><li>判断tempS是否为空且栈顶元素和popped[i]相等<ul><li>tempS出栈</li><li>i++</li></ul></li></ul></li></ol><p>3.返回tempS.empty()，如果其为空，说明合法，反之不合法</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; pushed, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; popped)</span> </span>&#123;        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; tempS;<span class="hljs-comment">//辅助栈</span>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//弹出序列的索引i</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : pushed) &#123;            tempS.push(e);<span class="hljs-comment">//入栈</span>            <span class="hljs-keyword">while</span> (!tempS.empty()&amp;&amp;tempS.top()==popped[i])&#123;<span class="hljs-comment">//栈顶元素，相等，弹出序列元素popped[i]</span>                tempS.pop();<span class="hljs-comment">//出栈</span>                i++;<span class="hljs-comment">//i++</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> tempS.empty();<span class="hljs-comment">//如果为空，说明合法</span>    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】21. 调整数组顺序使奇数位于偶数前面</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9121-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9121-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>双指针，p1指向头，p2指向尾，p1在遇到偶数时停下，p2在遇到奇数时停下，如果此时p1&lt;p2，则进行交换</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>, p2 = nums.size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (p1&lt;p2)        &#123;            <span class="hljs-keyword">while</span> (p1 &lt; p2 &amp;&amp; (nums[p1] &amp; <span class="hljs-number">1</span>)  ) p1++;<span class="hljs-comment">//p1所指为奇数时</span>            <span class="hljs-keyword">while</span> (p1 &lt; p2 &amp;&amp; (nums[p2] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) p2--;<span class="hljs-comment">//p2所指为偶数时</span>            <span class="hljs-keyword">if</span> (p1 &lt; p2) swap(nums[p1], nums[p2]);<span class="hljs-comment">//p1&lt;p2时</span>        &#125;        <span class="hljs-keyword">return</span> nums;    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【MIT6.837】A3:OpenGL &amp; Phong Shading</title>
    <link href="/%E3%80%90mit6-837%E3%80%91a3-opengl-phong-shading.html"/>
    <url>/%E3%80%90mit6-837%E3%80%91a3-opengl-phong-shading.html</url>
    
    <content type="html"><![CDATA[<h1 id="A3：OpenGL-amp-Phong-Shading"><a href="#A3：OpenGL-amp-Phong-Shading" class="headerlink" title="A3：OpenGL &amp; Phong Shading"></a>A3：<a href="http://groups.csail.mit.edu/graphics/classes/6.837/F04/assignments/assignment3/" target="_blank" rel="noopener">OpenGL &amp; Phong Shading</a></h1><hr><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><ul><li>实现交互式相机</li><li>实现Blinn-Phong光照模型及对应的光滑明暗处理技术</li><li>实现绘制各个图元的方法，尤其是球图元的绘制</li></ul><h2 id="Hints"><a href="#Hints" class="headerlink" title="Hints"></a>Hints</h2><h4 id="1、Phong模型与Bling-Phong的区别"><a href="#1、Phong模型与Bling-Phong的区别" class="headerlink" title="1、Phong模型与Bling-Phong的区别"></a>1、Phong模型与Bling-Phong的区别</h4><ul><li><p>Phong适合模拟塑料，比”反射”材质表现出的介质更光滑一些，适合模拟玻璃、水、冰等高反光特性的介质</p></li><li><p>BlinnPhong大多适用于金属材质</p></li><li><p>Blinn-Phong它能提供比Phong更柔和、更平滑的高光，而且速度上也更快，因此成为很多CG软件中默认的光照渲染方法，同时也被集成到大多数的图形芯片中</p></li></ul><h4 id="2、光滑明暗处理技术"><a href="#2、光滑明暗处理技术" class="headerlink" title="2、光滑明暗处理技术"></a>2、光滑明暗处理技术</h4><ul><li>平坦着色（Flat Shading）</li></ul><p>算法思想：</p><blockquote><p>通过三角形三顶点的坐标计算出整个三角形的法向量。<br>优缺点：<br>这样就导致相邻两个三角形的法向量差别很大，所以就能看到明显的三角形的边。</p></blockquote><ul><li>Gouraud光亮度插值技术</li></ul><p>算法思想：</p><blockquote><p>将曲面表面某一点的光亮度做近似表示，近似值取为该曲面的各多边形顶点光亮度的双线性插值。</p></blockquote><p>优缺点：</p><blockquote><p>采用Gouraud明暗处理不但可以克服由多边形近似表示的曲面的光亮度不连续现象，而且计算量也很小。<br>1.不能正确地模拟高光。这是因为采用光亮度插值后将使多边形内的高光丢失。<br>2.所绘制画面会诱发马赫带效应。<br>虽然光亮度双线性插值保证了由多边形近似表示的曲面上各处光亮度的连续变化，但在相邻多边形的公共边界上光亮度的一阶导数并不连续，由于人眼的光学错觉，光亮度变化一阶不连续的边界处会呈现亮带或黑带，即马赫带效应。<br>3.克服这些缺点的一种方法是采用Phong明暗处理。</p></blockquote><ul><li>Phong法向量插值技术</li></ul><p>算法思想：</p><blockquote><p>它的基本思想是对多边形顶点处（平均）法向量做双线性插值，以增加一定的计算量为代价克服了Gouraud明暗处理的缺点。</p></blockquote><p>优缺点：</p><blockquote><p>1.优点：绘制的图形比Gouraud方法更真实<br>2.缺点：计算量远大于Gouraud方法</p></blockquote><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>部分结果如下：<br><img src="https://img-blog.csdnimg.cn/2020051922240261.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020051922240259.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/fuzhanzhan/MIT-CG6.837-2004" target="_blank" rel="noopener">符佬的github</a></li><li><a href="https://baike.baidu.com/item/%E5%A5%87%E5%BC%82%E7%9F%A9%E9%98%B5/9658459?fr=aladdin" target="_blank" rel="noopener">奇异矩阵</a></li><li><a href="https://www.cnblogs.com/yuxingli/p/7821102.html" target="_blank" rel="noopener">extern的使用</a></li><li><a href="https://www.mathsisfun.com/algebra/matrix-inverse.html" target="_blank" rel="noopener">逆矩阵的含义和应用</a></li><li><a href="https://wenku.baidu.com/view/4e6443ea9b89680202d8250f.html" target="_blank" rel="noopener">phong光照模型</a>（此中文PPT讲的还不错）</li></ul><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/xdobetter/MIT-CG6.837/tree/master/A3%20Assignment%203%20OpenGL%20&%20Phong%20Shading" target="_blank" rel="noopener">Github</a></p>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.837</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【MIT6.837】A2:Transformations &amp; Additional Primitives</title>
    <link href="/%E3%80%90mit6-837%E3%80%91a2-transformations-additional-primitives.html"/>
    <url>/%E3%80%90mit6-837%E3%80%91a2-transformations-additional-primitives.html</url>
    
    <content type="html"><![CDATA[<h1 id="A2：Transformations-amp-Additional-Primitives"><a href="#A2：Transformations-amp-Additional-Primitives" class="headerlink" title="A2：Transformations &amp; Additional Primitives"></a>A2：<a href="http://groups.csail.mit.edu/graphics/classes/6.837/F04/assignments/assignment2/" target="_blank" rel="noopener">Transformations &amp; Additional Primitives</a></h1><hr><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><p>本实验的目标是实现更多的基本图元（如Plane、Triangle类的实现）、新增两种渲染模式(normal visualization和diffuse shading)、新增PerspectiveCamera类及变换(Transform类)的实现。</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="1-TASK分析"><a href="#1-TASK分析" class="headerlink" title="1 TASK分析"></a>1 TASK分析</h3><p><img src="https://img-blog.csdnimg.cn/20200517222206828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_8,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200517222206854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>下面右边的序号是在实验中实际完成的顺序</p><p>[1] Object中更新球的计算交点方法【3】<br>[2] Object中派生出plane【2】，并实现其求交点方法【3】<br><img src="https://img-blog.csdnimg.cn/20200517222245699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>[3] Object中派生出Triangle【2】，并实现其求交点方法【3】</p><p><img src="https://img-blog.csdnimg.cn/20200517222305400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200517222305395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><b>红色部分即为|A|</b></p><p><img src="https://img-blog.csdnimg.cn/20200517222339559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200517222339550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>[4]Object中派生出Transform【2】<br>[5]实现Transform类的求交点方法【3】<br>[6]实现normal visualization和diffuse shading的渲染模式【4】</p><blockquote><p>在主函数中实现两个渲染模式，同时封装一下命令解析代码</p></blockquote><p>[7]在Camera中派生出PerspectiveCamera【1】</p><h3 id="2-代码结构分析"><a href="#2-代码结构分析" class="headerlink" title="2 代码结构分析"></a>2 代码结构分析</h3><p>不需要的编写的文件</p><blockquote><p>hit.h（A2更新）、light.h（A2给出）、ray.h、vectors.h、materials.h、image.h(c)、matrix.h(c)、scene_parser.h(c)（A2更新）<br>需要编写的文件<br>camera.h(c)、main.c、object3d.h(c)、</p></blockquote><h2 id="注意点-Hints"><a href="#注意点-Hints" class="headerlink" title="注意点(Hints)"></a>注意点(Hints)</h2><p>除实验中给出的Hints，这里给出自己在完成过程中遇到的不懂之处。</p><p>1 virtual ~Object3D() {} 为什么加virtual，有什么含义？</p><blockquote><p>上述写法叫虚析构函数，和其他函数一样，我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本；当我们delete一个动态分配的对象的指针时将执行析构函数，如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。</p></blockquote><p>2 virtual 和 override</p><blockquote><p>override只能对virtual进行重写</p></blockquote><p>3 叉乘坐标系的表示方式</p><blockquote><p>右手法则（right hand rule）</p></blockquote><p>4 new并delete指针数组的方式</p><blockquote><p><a href="https://www.cnblogs.com/chenhuan001/p/7373448.html" target="_blank" rel="noopener">见此博客</a></p></blockquote><p>5 C/C++ assert()函数用法</p><blockquote><p><a href="https://blog.csdn.net/myyllove/article/details/82898875" target="_blank" rel="noopener">见此博客</a></p></blockquote><p>6 error C2065: “M_PI”: 未声明的标识符</p><blockquote><p><a href="https://www.cnblogs.com/zzsama/p/10993125.html" target="_blank" rel="noopener">见此博客</a></p></blockquote><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>部分实验结果如下:</p><p><img src="https://img-blog.csdnimg.cn/20200517222403886.png" srcset="/img/loading.gif" alt="在这里插入图片描述"> <img src="https://img-blog.csdnimg.cn/20200517222403463.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200517222427325.png" srcset="/img/loading.gif" alt="在这里插入图片描述"> <img src="https://img-blog.csdnimg.cn/20200517222427272.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/xdobetter/MIT-CG6.837/tree/master/A2%20Transformations%20%26%20Additional%20Primitives" target="_blank" rel="noopener">xdobetter的github</a></p>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.837</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【MIT6.837】A1:Ray Casting</title>
    <link href="/%E3%80%90mit6-837%E3%80%91a1-ray-casting.html"/>
    <url>/%E3%80%90mit6-837%E3%80%91a1-ray-casting.html</url>
    
    <content type="html"><![CDATA[<h1 id="A1：Ray-Casting（光线投射"><a href="#A1：Ray-Casting（光线投射" class="headerlink" title="A1：Ray Casting（光线投射)"></a>A1：<a href="http://groups.csail.mit.edu/graphics/classes/6.837/F04/assignments/assignment1/" target="_blank" rel="noopener">Ray Casting</a>（光线投射)</h1><hr><h2 id="学术名词"><a href="#学术名词" class="headerlink" title="学术名词"></a>学术名词</h2><blockquote><p>camera obscura：针孔照相机<br>Perspective：透视投影<br>Orthographic：正交投影<br>Parallel projection：平行投影<br>Ray-Plane Intersection：射线与平面相交<br>Ray-Sphere Intersection：射线与球面相交<br>orthonormal basis：标准正交基<br>Ray Casting：光线投射<br>Ray tracing：光线追踪<br>Geometric：几何学<br>Algebraic：代数学<br>Object-Oriented Design：面向对象设计</p></blockquote><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><p>本实验的目标是要完成一个光线投射算法。光线投射算法的原理如下图（文字部分为个人见解）：<br>对于每一个像素<br>&emsp;构建一条从视点处开始的射线<br>    &emsp;&emsp;对场景中的每一个对象<br>       &emsp;&emsp;判断当前射线是否和当前对象有交点（此处要用到求交点函数）<br>    &emsp;&emsp;如果有且该交点距离视点更近，则更新最近交点值</p><p><img src="https://img-blog.csdnimg.cn/20200513230801435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>下面说明一下本实验完成过程的重点。</p><h3 id="射线和球模型的计算交点方法的实现"><a href="#射线和球模型的计算交点方法的实现" class="headerlink" title="射线和球模型的计算交点方法的实现"></a>射线和球模型的计算交点方法的实现</h3><p>此处采用的是Algebraic方法，该方法的实现不是很难理解，根据PPT的公式及实验讲解即可完成该部分。Geometric方法使用较少因此没有实现。</p><p><img src="https://img-blog.csdnimg.cn/2020051323082180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200513230821154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Sphere::intersect</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ray&amp; r, Hit&amp; h, <span class="hljs-keyword">float</span> tmin)</span> </span>&#123;<span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<span class="hljs-comment">//有交点返回true</span>Vec3f ro = r.getOrigin() - center;<span class="hljs-comment">//ro:射线到球中心的向量</span>Vec3f rd = r.getDirection();<span class="hljs-comment">//射线方向</span><span class="hljs-keyword">float</span> a = rd.Dot3(rd);<span class="hljs-comment">//rd与rd点积</span><span class="hljs-keyword">float</span> b = <span class="hljs-number">2</span> * ro.Dot3(rd);<span class="hljs-comment">//ro与rd点积,可能为负</span><span class="hljs-keyword">float</span> c = ro.Dot3(ro) - radius * radius;<span class="hljs-keyword">float</span> delta = b * b - <span class="hljs-number">4</span> * a * c;<span class="hljs-comment">//float t;//当前距离,此处可以不用</span><span class="hljs-comment">//获取最近的交点</span><span class="hljs-keyword">if</span> (delta &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">float</span> d = <span class="hljs-built_in">sqrt</span>(delta);<span class="hljs-comment">//一定为正</span><span class="hljs-keyword">float</span> t1 = (-b - d) / (<span class="hljs-number">2</span> * a);<span class="hljs-comment">//通常t1更小</span><span class="hljs-keyword">float</span> t2 = (-b + d) / (<span class="hljs-number">2</span> * a);<span class="hljs-comment">// For an orthographic camera, rays always start at infinity, so tmin will be a large negative value</span><span class="hljs-comment">//由于本节作业是正交相机，正交相机的tmin为无穷大，因此下面这块代码可以不用</span><span class="hljs-comment">//if (t1 &gt;= tmin) &#123;//在origin之前</span><span class="hljs-comment">//t = t1;</span><span class="hljs-comment">//&#125;</span><span class="hljs-comment">//else if (t2 &gt;= tmin) &#123;</span><span class="hljs-comment">//t = t2;</span><span class="hljs-comment">//&#125;</span><span class="hljs-keyword">if</span> (t1 &lt; h.getT()) &#123;<span class="hljs-comment">//closer当前交点，更新</span>h.<span class="hljs-built_in">set</span>(t1, material, r);flag = <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-keyword">return</span> flag;&#125;</code></pre></div><h3 id="正交相机的实现"><a href="#正交相机的实现" class="headerlink" title="正交相机的实现"></a>正交相机的实现</h3><p>直接参见PPT上给出的原理进行实现<br><img src="https://img-blog.csdnimg.cn/20200513230920794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function">Ray <span class="hljs-title">OrthographicCamera::generateRay</span><span class="hljs-params">(Vec2f point)</span> </span>&#123;Vec3f ro = center + (point.x() - <span class="hljs-number">0.5</span>) * horizontal * size + (point.y() - <span class="hljs-number">0.5</span>) * up * size;<span class="hljs-comment">//射线起始点到对象中心</span><span class="hljs-keyword">return</span> Ray(ro, direction);&#125;</code></pre></div><h3 id="光线投射算法的实现"><a href="#光线投射算法的实现" class="headerlink" title="光线投射算法的实现"></a>光线投射算法的实现</h3><p>该函数在主函数中进行了实现，代码如下</p><div class="hljs"><pre><code class="hljs cpp">   <span class="hljs-comment">/*输入——初始化场景、相机、对象组及两幅图像*/</span><span class="hljs-function">SceneParser <span class="hljs-title">scene</span><span class="hljs-params">(input_file)</span></span>;Camera* camera = scene.getCamera();Object3D* group = scene.getGroup();<span class="hljs-function">Image <span class="hljs-title">image</span><span class="hljs-params">(width, height)</span></span>;<span class="hljs-comment">//设置图像大小</span>image.SetAllPixels(scene.getBackgroundColor());<span class="hljs-comment">//图像背景颜色设置为场景背景颜色</span><span class="hljs-function">Image <span class="hljs-title">depthImage</span><span class="hljs-params">(width, height)</span></span>;<span class="hljs-comment">//设置深度图像</span>depthImage.SetAllPixels(Vec3f(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>));<span class="hljs-comment">//设置成黑色</span>   <span class="hljs-comment">//光线投射</span><span class="hljs-comment">/*循环遍历图像平面中的像素，使用OrthographicCamera类生成射线，将其与Group中的各个对象求交点，并将最近点保存到hit中*/</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;width;++i)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; height; ++j) &#123;<span class="hljs-keyword">float</span> x = <span class="hljs-keyword">float</span>(i) / <span class="hljs-keyword">float</span>(width);<span class="hljs-keyword">float</span> y = <span class="hljs-keyword">float</span>(j) / <span class="hljs-keyword">float_t</span>(height);Ray ray = camera-&gt;generateRay(Vec2f(x, y));<span class="hljs-comment">//产生射线</span><span class="hljs-function">Hit <span class="hljs-title">hit</span><span class="hljs-params">(INFINITY, <span class="hljs-literal">nullptr</span>)</span></span>;<span class="hljs-comment">//hit存储最近的交点，此处初始t设置为了无穷大</span><span class="hljs-keyword">bool</span> flag = group-&gt;intersect(ray, hit, camera-&gt;getTMin());<span class="hljs-comment">//使该条射线和每一个基本图元求交点</span><span class="hljs-keyword">if</span> (flag) &#123;<span class="hljs-comment">//如果存在交点</span>image.SetPixel(i, j, hit.getMaterial()-&gt;getDiffuseColor());<span class="hljs-comment">//设置该点像素的颜色</span><span class="hljs-keyword">float</span> t = hit.getT();<span class="hljs-comment">//可视化深度t</span><span class="hljs-comment">//超过则设置为边界值</span><span class="hljs-keyword">if</span> (t &gt; depth_max) t = depth_max;<span class="hljs-comment">//此处max=1、min=0</span><span class="hljs-keyword">if</span> (t &lt; depth_min) t = depth_min;t = (depth_max - t) / (depth_max - depth_min);<span class="hljs-comment">//t越小越近，越近的颜色越深</span>depthImage.SetPixel(i, j, Vec3f(t, t, t));<span class="hljs-comment">//设置颜色值</span>&#125;&#125;&#125;</code></pre></div><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://img-blog.csdnimg.cn/20200513230851178.png" srcset="/img/loading.gif" alt="在这里插入图片描述">  <img src="https://img-blog.csdnimg.cn/20200513230851180.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>在实验的过程中，阅读完实验讲义和PPT，不是很明白实验需要完成那些内容。因此我直接参考了别人已完成的代码，并对需要实现的部分一点点对着阅读和理解。边看代码边看PPT和实验讲义，对每个文件每个函数充分理解，实验也逐渐完成，本实验也是之后实验的重点，需要充分弄明白。<br>自己完成实验的步骤：<br>1.通看PPT<br>2.通看实验讲义<br>3.执行别人的代码<br>4.在不懂的情况下阅读实验讲义、PPT并阅读别人的代码</p><ul><li>记录自己要编写那些文件，完成那些函数</li><li>记录这些函数的实验原理，进一步理解这些算法的思想</li><li>记录下参考过的资料</li><li>重复该过程，直到弄懂</li></ul><p>5.整理实验，并写成报告</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/weixin_40552524/article/details/104436544" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40552524/article/details/104436544</a></li><li><a href="https://www.cnblogs.com/fengyuheliu/archive/2011/08/28/2155627.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengyuheliu/archive/2011/08/28/2155627.html</a></li></ul><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/xdobetter/MIT-CG6.837/tree/master/A1%20Ray%20Casting" target="_blank" rel="noopener">xdobetter的GitHub</a></p>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.837</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【MIT6.837】A0:IFS</title>
    <link href="/%E3%80%90mit6-837%E3%80%91a0-ifs.html"/>
    <url>/%E3%80%90mit6-837%E3%80%91a0-ifs.html</url>
    
    <content type="html"><![CDATA[<h1 id="A0：IFS（迭代函数系统）"><a href="#A0：IFS（迭代函数系统）" class="headerlink" title="A0：IFS（迭代函数系统）"></a>A0：IFS（迭代函数系统）</h1><h2 id="任务概述"><a href="#任务概述" class="headerlink" title="任务概述"></a>任务概述</h2><p>6.837的第一个作业，实现IFS算法。目的是熟悉C++的语法特性，并且熟悉使用两个和图像生成和线性代数相关的简单库。通过生成一些奇妙的分形物体来体会图形学的乐趣。</p><p>IFS <strong>是一种构造分形的方法，得到的分形通常是自相似(self-similar)的</strong>。IFS最经典的例子是绘制一种蕨类植物(Barnsley’s fern)，如下图所示，可以看到，每一个子叶片与整个叶片的形状相同。</p><p>IFS由<strong>一个仿射变换(affine transformations)集合所定义，通常定义的仿射变换包括旋转(rotation)、缩放(scale)、平移(translations)、斜切(skew)等等线性变换方法</strong>。这些变换不着了自相似的物体形状。IFS可以定义在多个维度上，在这个作业中，我们只需实现二维的变换。</p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>本实验已经提供了matrix.h、vectors.h、image.h、image.cpp、matrix.cpp5个文件<br>而我们要实现的文件是ifs.h、ifs.cpp、main.cpp<br>因此本实验的关键是实现ifs类、ifs的输入和ifs的渲染算法</p><h3 id="ifs类的创建"><a href="#ifs类的创建" class="headerlink" title="ifs类的创建"></a>ifs类的创建</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"matrix.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"image.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"vectors.h"</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IFS</span> &#123;</span><span class="hljs-keyword">private</span>:<span class="hljs-comment">//仿射变换的个数</span><span class="hljs-keyword">int</span> n;<span class="hljs-comment">//仿射变换矩阵数组</span>Matrix* matrix;<span class="hljs-comment">//每一个仿射变换的选取概率数组</span><span class="hljs-keyword">float</span>* prob;<span class="hljs-keyword">public</span>:<span class="hljs-comment">//构造函数，使用仿射变换个数初始化</span>IFS():n(<span class="hljs-number">0</span>),matrix(<span class="hljs-literal">nullptr</span>),prob(<span class="hljs-literal">nullptr</span>)&#123;&#125;<span class="hljs-comment">//析构函数</span>~IFS() &#123;<span class="hljs-keyword">delete</span>[] matrix;<span class="hljs-keyword">delete</span>[] prob;&#125;<span class="hljs-comment">//读取IFS输入</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">input</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* file)</span></span>;<span class="hljs-comment">//绘制IFS图片</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">render</span><span class="hljs-params">(Image&amp; image, <span class="hljs-keyword">int</span> num_points, <span class="hljs-keyword">int</span> num_iters)</span></span>;&#125;;</code></pre></div><h3 id="IFS输入的实现"><a href="#IFS输入的实现" class="headerlink" title="IFS输入的实现"></a>IFS输入的实现</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IFS::input</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* file)</span> </span>&#123;FILE* input = fopen(file, <span class="hljs-string">"r"</span>);assert(input != <span class="hljs-literal">nullptr</span>);<span class="hljs-comment">//断言帮助调式解决逻辑bug</span><span class="hljs-comment">//从一个流中执行格式化输入，fscanf遇到空格和换行时结束，注意空格时也结束</span><span class="hljs-built_in">fscanf</span>(input, <span class="hljs-string">"%d"</span>, &amp;n);<span class="hljs-comment">//读取变换的数量</span>matrix = <span class="hljs-keyword">new</span> Matrix[n];prob = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-built_in">fscanf</span>(input, <span class="hljs-string">"%f"</span>, &amp;prob[i]);<span class="hljs-comment">//读取变换的概率</span>matrix[i].Read3x3(input);<span class="hljs-comment">//读取变换的3x3浮点矩阵</span>&#125;fclose(input);<span class="hljs-comment">//关闭输入流</span>&#125;</code></pre></div><h3 id="IFS算法的实现"><a href="#IFS算法的实现" class="headerlink" title="IFS算法的实现"></a>IFS算法的实现</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IFS::render</span><span class="hljs-params">(Image&amp; image, <span class="hljs-keyword">int</span> num_points, <span class="hljs-keyword">int</span> num_iters)</span> </span>&#123;<span class="hljs-keyword">int</span> width = image.Width();<span class="hljs-keyword">int</span> height = image.Height();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_points;++i)&#123;Vec2f v = Vec2f(rand() * <span class="hljs-number">1.0f</span> / RAND_MAX, rand() * <span class="hljs-number">1.0f</span> / RAND_MAX);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; num_iters; ++j) &#123;<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<span class="hljs-keyword">float</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">float</span> t = rand() * <span class="hljs-number">1.0f</span> / RAND_MAX;<span class="hljs-keyword">for</span> (;k&lt;n;++k)&#123;sum += prob[k];<span class="hljs-keyword">if</span> (sum &gt; t) <span class="hljs-keyword">break</span>;&#125;matrix[k].Transform(v);&#125;<span class="hljs-keyword">if</span> (v.x() &gt;= <span class="hljs-number">0</span> &amp;&amp; v.x() &lt;= <span class="hljs-number">1</span> &amp;&amp; v.y() &gt;= <span class="hljs-number">0</span> &amp;&amp; v.y() &lt;= <span class="hljs-number">1</span>) &#123;image.SetPixel(v.x() * width, v.y() * height, Vec3f(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>));&#125;&#125;&#125;</code></pre></div><p>这里我不是很懂这个算法的思想，主要是参考了别人的代码完成</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://img-blog.csdnimg.cn/20200512201918546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200512201918518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200512201918506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200512201918519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/nycshisan/MIT6_837_Assignments/tree/master/src" target="_blank" rel="noopener">https://github.com/nycshisan/MIT6_837_Assignments/tree/master/src</a></li><li><a href="https://blog.csdn.net/u012420309/article/details/52948729" target="_blank" rel="noopener">vs2013遇到fopen不安全替换fopen_s的问题</a></li><li><a href="https://www.cnblogs.com/132818Creator/p/11014639.html" target="_blank" rel="noopener">VS中多级目录的写法</a></li><li><a href="https://blog.csdn.net/poinsettia/article/details/17138801" target="_blank" rel="noopener">CMAKE的学习</a></li><li><a href="https://github.com/fuzhanzhan/MIT-CG6.837-2004" target="_blank" rel="noopener">https://github.com/fuzhanzhan/MIT-CG6.837-2004</a></li><li><a href="https://blog.csdn.net/wonggonghong/article/details/16381975" target="_blank" rel="noopener">(MIT 6.837)迭代函数系统IFS画自相似图形的算法</a></li></ul><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/xdobetter/MIT-CG6.837" target="_blank" rel="noopener">Github下载</a></p>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.837</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【OpenGL】三维场景漫游的实现</title>
    <link href="/%E3%80%90opengl%E3%80%91%E4%B8%89%E7%BB%B4%E5%9C%BA%E6%99%AF%E6%BC%AB%E6%B8%B8%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <url>/%E3%80%90opengl%E3%80%91%E4%B8%89%E7%BB%B4%E5%9C%BA%E6%99%AF%E6%BC%AB%E6%B8%B8%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>构建一个三维场景<br>  可利用glut提供的各种简单形体来搭建，或者读入别的模型，并加入光照效果</li><li>用键盘操作一个物体（如一艘飞船，或一个机器人），在三维场景中漫游<br>视点可以放在物体上，或跟随物体，利用gluLookAt()函数来实现对视点的控制</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、开始想直接利用OpenGL的glulookAt函数，但发现并不好用<br>2、之后参考他人资料寻思构造一个摄像机类，通过摄像机类达到控制视点，这部分通过参考LearnOpenGL上的摄像机类进行实现 </p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="实验效果图"><a href="#实验效果图" class="headerlink" title="实验效果图"></a>实验效果图</h3><p><img src="https://img-blog.csdnimg.cn/2020051220023985.gif#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="程序控制键说明"><a href="#程序控制键说明" class="headerlink" title="程序控制键说明"></a>程序控制键说明</h3><ul><li>w,s,a,d分别控制视点的前进，后推，左移，右移</li><li>q，e控制视点进行左旋转，右旋转</li><li>方向键LEFT、RIGHT、UP、DOWN，视线方向转向左，视线方向转向右，视线方向转向上，视线方向转向下</li><li>Page_UP、Page_Down，视点位置升高，降低</li></ul><h2 id="实验思考"><a href="#实验思考" class="headerlink" title="实验思考"></a>实验思考</h2><h3 id="glulookAt"><a href="#glulookAt" class="headerlink" title="glulookAt()"></a>glulookAt()</h3><p>一般gluLookAt()用于从世界坐标系到眼坐标系的转换，但是由于OpenGL里面模型视图矩阵直接将本地坐标系转换为眼坐标系，所以gluLookAt()应该被用来设置模型视图矩阵，但是有一点得注意了：<br>gluLookAt()的调用应该在场景绘制初glLoadIdentity()函数调用之后，在所有的glTranslate<em>()、glRotate</em>()、glScale*()函数调用之前调用，且只调用一次<br>参考自以下资料<br><a href="https://bbs.csdn.net/topics/390124968" target="_blank" rel="noopener">https://bbs.csdn.net/topics/390124968</a><br><a href="https://blog.csdn.net/fyyyr/article/details/79298636" target="_blank" rel="noopener">https://blog.csdn.net/fyyyr/article/details/79298636</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://blog.csdn.net/conan_4869lucky/article/details/72811009" target="_blank" rel="noopener">OpenGL初探：三维迷宫游戏（一）——场景漫游</a></p><blockquote><p>首先是是场景漫游：实现场景漫游有两种方式，一种是固定照相机的位置，对整个场景进行变换，例如当人物前进时，其实是通过将整个场景向后平移实现的，转向时，是通过反向旋转整个场景实现的；另一种方式是使照相机在场景中移动，通过gluLookAt()函数设定照相机的位置，可以任意指定照相机的位置和朝向。</p></blockquote><ul><li><a href="https://blog.csdn.net/qq_27161673/article/details/72860890" target="_blank" rel="noopener">OPENGL三维场景搭建、漫游、交互</a></li></ul><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><ul><li><a href="https://download.csdn.net/download/weixin_41234001/12412946" target="_blank" rel="noopener">CSDN下载</a></li><li><a href="">Github下载</a> 待完成</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>MOOC-图形编程技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【OpenGL】机器人手臂的实现</title>
    <link href="/%E3%80%90opengl%E3%80%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%89%8B%E8%87%82%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <url>/%E3%80%90opengl%E3%80%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%89%8B%E8%87%82%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>MOOC-图形编程技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】134.加油站</title>
    <link href="/%E3%80%90leetcode%E3%80%91134-%E5%8A%A0%E6%B2%B9%E7%AB%99.html"/>
    <url>/%E3%80%90leetcode%E3%80%91134-%E5%8A%A0%E6%B2%B9%E7%AB%99.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><p>暴力破解，一方面验证自己对题目的理解是否正确，另一方面后续的优化也可以从这里入手。<br>1、考虑从第<code>0</code>个点出发，能否回到第<code>0</code>个点。<br>2、考虑从第<code>1</code>个点出发，能否回到第<code>1</code>个点。<br>3、考虑从第<code>2</code>个点出发，能否回到第<code>2</code>个点。<br>… …<br>4、考虑从第<code>n</code>个点出发，能否回到第<code>n</code>个点。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//暴力法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; gas, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; cost)</span> </span>&#123;<span class="hljs-keyword">int</span> n = gas.size();<span class="hljs-comment">//考虑从每一个点出发</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-keyword">int</span> j = i;<span class="hljs-keyword">int</span> remain = gas[i];<span class="hljs-comment">//当前剩余的油能否到达下一个点</span><span class="hljs-keyword">while</span> (remain-cost[j]&gt;=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//减去花费的加上新的点的补给</span>remain = remain - cost[j] + gas[(j + <span class="hljs-number">1</span>) % n];j = (j + <span class="hljs-number">1</span>) % n;<span class="hljs-comment">//如果j回到了i</span><span class="hljs-keyword">if</span> (j == i) &#123;<span class="hljs-keyword">return</span> i;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;&#125;;</code></pre></div><h4 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h4><p>说实话这个在LeetCode上看了很久的题解，但还是对于官方题解不是很懂，对于这个问题，主要参考了该博主的题解<a href="https://leetcode-cn.com/problems/gas-station/solution/shi-yong-tu-de-si-xiang-fen-xi-gai-wen-ti-by-cyayc/" target="_blank" rel="noopener">使用图的思想分析该问题</a></p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; gas, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; cost)</span> </span>&#123;<span class="hljs-keyword">int</span> len = gas.size();<span class="hljs-keyword">int</span> spare = <span class="hljs-number">0</span>;<span class="hljs-comment">//总剩余汽油量</span><span class="hljs-keyword">int</span> minSpare = <span class="hljs-number">9999999999</span>;<span class="hljs-comment">//最小的总剩余汽油量</span><span class="hljs-keyword">int</span> minIndex = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录出发点</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;spare += gas[i] - cost[i];<span class="hljs-keyword">if</span> (spare&lt;minSpare)&#123;minSpare = spare;minIndex = i;&#125;&#125;<span class="hljs-keyword">return</span> spare &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : (minIndex + <span class="hljs-number">1</span>) % len;<span class="hljs-comment">//minIndex+1%len为出发点</span>&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】面试题51. 数组中的逆序对</title>
    <link href="/%E3%80%90leetcode%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9851-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.html"/>
    <url>/%E3%80%90leetcode%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9851-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>分治法：<br>采用的就是归并函数中的分治思想，该题与分治排序的不同点在于，在治的过程中进行逆序对的统计，逆序对的个数为<br><code>cnt += center - i + 1;</code><br>这也是在归并排序上要加的代码</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><span class="hljs-comment">思路：分治</span><span class="hljs-comment">通过分的方式，获得每个子区间，在合并每个子区间时计算每个子区间内部的逆序对个数</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-keyword">if</span> (nums.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//特判，size为0,1不可能出现逆序对</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temps</span><span class="hljs-params">(nums.size())</span></span>;mergeSort(nums, temps, <span class="hljs-number">0</span>, nums.size() - <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-comment">//归并排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; temps, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<span class="hljs-keyword">if</span> (left &lt; right) &#123;<span class="hljs-keyword">int</span> center = left + (right - left) / <span class="hljs-number">2</span>;mergeSort(nums, temps, left, center);<span class="hljs-comment">//左分</span>mergeSort(nums, temps, center + <span class="hljs-number">1</span>, right);<span class="hljs-comment">//右分</span>merge(nums, temps, left, center, right);<span class="hljs-comment">//治</span>&#125;&#125;<span class="hljs-comment">//合并</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; temp, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> center, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<span class="hljs-keyword">int</span> i = left, j = center + <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = left; k &lt;= right; k++) &#123;<span class="hljs-keyword">if</span> (i &gt; center) &#123;<span class="hljs-comment">//左边的已经比较完，将右边的全部放到temp中</span>temp[k] = nums[j++];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; right) &#123;<span class="hljs-comment">//右边的已经比较完，将左边的全部放到temp中</span>temp[k] = nums[i++];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<span class="hljs-comment">//左边大于右边，出现逆序对，</span>temp[k] = nums[j++];<span class="hljs-comment">//取右边数组值</span>cnt += center - i + <span class="hljs-number">1</span>;<span class="hljs-comment">//此处+1是因为center是等于right的,这里也是比归并排序多的一行代码</span>&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//左边小于等于右边</span>&#123;temp[k] = nums[i++];<span class="hljs-comment">//取左边数组值</span>&#125;&#125;<span class="hljs-comment">//将temp中的元素复制到nums中</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = left; k &lt;= right; k++) &#123;nums[k] = temp[k];&#125;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【OpenGL】光照太阳系</title>
    <link href="/%E3%80%90opengl%E3%80%91%E5%85%89%E7%85%A7%E5%A4%AA%E9%98%B3%E7%B3%BB.html"/>
    <url>/%E3%80%90opengl%E3%80%91%E5%85%89%E7%85%A7%E5%A4%AA%E9%98%B3%E7%B3%BB.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>MOOC-图形编程技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【OpenGL】太阳星系的实现</title>
    <link href="/%E3%80%90opengl%E3%80%91%E5%A4%AA%E9%98%B3%E6%98%9F%E7%B3%BB%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <url>/%E3%80%90opengl%E3%80%91%E5%A4%AA%E9%98%B3%E6%98%9F%E7%B3%BB%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[<h2 id="一、功能"><a href="#一、功能" class="headerlink" title="一、功能"></a>一、功能</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>三个球体、一个表示太阳、一个表示地球、一个表示月亮；地球不停地绕太阳旋转，月亮绕地球旋转，期间它们三者都发生自转。</p><h3 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h3><p>地球有两个月亮，画上轨道线，使轨道倾斜，放缩效果</p><h3 id="自己完成的效果图"><a href="#自己完成的效果图" class="headerlink" title="自己完成的效果图"></a>自己完成的效果图<img src="https://img-blog.csdnimg.cn/20200322143615489.gif#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></h3><h2 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h2><h3 id="基本功能的实现"><a href="#基本功能的实现" class="headerlink" title="基本功能的实现"></a>基本功能的实现</h3><p>首先搭好程序框架：<br>1、    设置显示模式<br>2、    初始化窗口<br>3、    创建窗口<br>4、    设置一系列回调函数<br>5、    启动主循环<br>框架设置完毕后，针对display()函数进行编写，关于display函数的编写，即是整个基本功能的绘制，本人刚开始编写的时候，对全局变换和局部变换理解不够透彻，因此我在编写过程中一直采用全局变换的思路，并没有采用的局部变换的思路。</p><h4 id="1、创建三个球体，分别为太阳、地球和月亮，并移至对应位置"><a href="#1、创建三个球体，分别为太阳、地球和月亮，并移至对应位置" class="headerlink" title="1、创建三个球体，分别为太阳、地球和月亮，并移至对应位置"></a>1、创建三个球体，分别为太阳、地球和月亮，并移至对应位置</h4><p> <img src="https://img-blog.csdnimg.cn/20200322143807518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="2、使地球绕太阳转起来"><a href="#2、使地球绕太阳转起来" class="headerlink" title="2、使地球绕太阳转起来"></a>2、使地球绕太阳转起来</h4><p>我假设太阳为默认原点位置，地球将在xoz平面围绕太阳进行旋转，绕其旋转，起初，我思考地球位置的改变即为其x,z值的改变，对于一个圆，其x,z值采用极坐标的形式来表达，        </p><div class="hljs"><pre><code class="hljs cpp">   earthPosX=earthBound*<span class="hljs-built_in">cos</span>(curTheta*pi);<span class="hljs-comment">//求地球x</span>earthPosZ=earthBound*<span class="hljs-built_in">sin</span>(curTheta*pi);<span class="hljs-comment">//求地球z</span></code></pre></div><p>因此只要改变坐标，就能使求发生转动，于是通过编写定义定时器回调函数<code>void myTimerFunc(int value)</code>，在函数中不断增加theda的值，就可以使圆不断转动。</p><h4 id="3、使月亮绕地球转起来"><a href="#3、使月亮绕地球转起来" class="headerlink" title="3、使月亮绕地球转起来"></a>3、使月亮绕地球转起来</h4><p>月亮围绕地球转，由于我始终是从全局坐标的角度考虑了这个问题，<br>因此，月亮的坐标也要转换为全局坐标值，假设月球绕地球转动角度为far，则其x，z采用极坐标的形式来表达为</p><div class="hljs"><pre><code class="hljs cpp">monthPosX = earthPosX + monthBound* <span class="hljs-built_in">cos</span>(curFar * pi);<span class="hljs-comment">//求月球x</span>monthPosZ = earthPosZ + monthBound* <span class="hljs-built_in">sin</span>(curFar * pi);<span class="hljs-comment">//求月球y</span></code></pre></div><p>同样使其转动，在<code>void myTimerFunc(int value)</code>中，不断增加far的值即可，具体效果见SunEarthMonth.gif。而其中两个球体的自转，则设定一个自转角度curSpeed来控制，而其值的变化也在定时器回调函数中完成。<br><img src="https://img-blog.csdnimg.cn/20200322143920762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="扩展功能的实现"><a href="#扩展功能的实现" class="headerlink" title="扩展功能的实现"></a>扩展功能的实现</h3><h4 id="1、（扩展功能）实现地球上有两个月亮"><a href="#1、（扩展功能）实现地球上有两个月亮" class="headerlink" title="1、（扩展功能）实现地球上有两个月亮"></a>1、（扩展功能）实现地球上有两个月亮</h4><p>对于这个效果，很容易实现，此处简化，只设置月亮B和月亮A在同一平面内，并且两者速度相等，只需要保持轨道半径相等，位置不同即可，而如何做到这一点，仍然可以从圆出发，这里我做的是将另一个月亮和此月亮形成对称，因此使月亮B绕地球的角度比月亮A多180度即可，坐标值如下：</p><div class="hljs"><pre><code class="hljs cpp">month2PosX = earthPosX + monthBound * <span class="hljs-built_in">cos</span>(curFar * pi+pi);<span class="hljs-comment">//求月球2x</span>month2PosZ = earthPosZ + monthBound * <span class="hljs-built_in">sin</span>(curFar * pi+pi);<span class="hljs-comment">//求月球2z</span></code></pre></div><p>具体实现效果见下图<br><img src="https://img-blog.csdnimg.cn/2020032214435296.gif#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="2、（扩展功能）画上轨道线"><a href="#2、（扩展功能）画上轨道线" class="headerlink" title="2、（扩展功能）画上轨道线"></a>2、（扩展功能）画上轨道线</h4><p>实现地球绕太阳的轨道线描绘的就是以太阳为中心，以地球到太阳的距离为半径画的圆，而在OpenGL中，绘画基本图元没有圆，因此我思考通过不断的画直线来逼近圆，因此使用GL_LINE_LOOP来绘制，线段我一共绘制了7200次。同理，月亮绕地球的轨道线，就是以地球为中心，以月亮到地球的距离为半径画的圆。效果图可见下图：</p><p><img src="https://img-blog.csdnimg.cn/20200322144340217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="3、（扩展功能）让轨道倾斜"><a href="#3、（扩展功能）让轨道倾斜" class="headerlink" title="3、（扩展功能）让轨道倾斜"></a>3、（扩展功能）让轨道倾斜</h4><p>首先我实现的是地球绕太阳的轨道倾斜，要做的效果实际上就是使xoy平面发生旋转，此处我是使其绕z轴先进行旋转，后续步骤不变即可。需要注意的是此处轨道倾斜，相应的地球和月亮也要随着倾斜。<br>倾斜代码为：<br>glRotatef(earthOrbitAngle, 0.0f, 0.0f, 1.0f);//地球轨道倾斜earthOrbitAngle度,轨道沿着Z轴逆时针旋转<br>对于月亮绕地球的轨道倾斜，其效果就是在地球绕太阳的轨道平面上，再旋转即可，此处我假定月亮绕地球的轨道平面绕地球到月亮的轴线进行旋转。因此先将其变换到地球绕太阳的轨道平面上后，再进行旋转一定角度即可实现。效果图详见：<br> <img src="https://img-blog.csdnimg.cn/20200322144047223.gif#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="4、（扩展功能）实现按键控制轨道倾斜与整体图形放大缩小功能"><a href="#4、（扩展功能）实现按键控制轨道倾斜与整体图形放大缩小功能" class="headerlink" title="4、（扩展功能）实现按键控制轨道倾斜与整体图形放大缩小功能"></a>4、（扩展功能）实现按键控制轨道倾斜与整体图形放大缩小功能</h4><p>对于轨道倾斜，通过键盘控制函数改变其角度参数值（earthOrbitAngle、monthOrbitAngle）即可，对于放大缩小，通过控制G_fDistance值即可。效果图详见SunEarthMonth4.gif：</p><p><img src="https://img-blog.csdnimg.cn/20200322144102861.gif#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="三、源代码"><a href="#三、源代码" class="headerlink" title="三、源代码"></a>三、源代码</h2><p><a href="https://download.csdn.net/download/weixin_41234001/12262604" target="_blank" rel="noopener">CSDN下载</a><br><a href="">Github下载</a></p>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>MOOC-图形编程技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】409. 最长回文串</title>
    <link href="/%E3%80%90leetcode%E3%80%91409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2.html"/>
    <url>/%E3%80%90leetcode%E3%80%91409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>若要形成最长的回文串，则回文串中只会出现1次单个字符，因此只需统计字符串中有多少个字符其数目为奇数，s.size()-n个为奇数个数的字符+1即为最长回文串<br>如果字符串没有出现奇数个数目的字符，则s.size()即为最长回文串</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; sMap;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c:s)&#123;sMap[c]++;&#125;<span class="hljs-keyword">int</span> oddNum = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; it:sMap)&#123;<span class="hljs-keyword">if</span> (it.second % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) oddNum++;&#125;<span class="hljs-keyword">if</span> (oddNum &gt; <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> s.size() - oddNum + <span class="hljs-number">1</span>;<span class="hljs-comment">//s.size()-为奇数个的字符数目+1</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> s.size();<span class="hljs-comment">//无奇数</span>&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】142. 环形链表 II</title>
    <link href="/%E3%80%90leetcode%E3%80%91142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii.html"/>
    <url>/%E3%80%90leetcode%E3%80%91142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="hashmap法"><a href="#hashmap法" class="headerlink" title="hashmap法"></a>hashmap法</h4><p>思路简单，时间复杂度O(n),空间复杂度O(n)</p><h4 id="Floyd法"><a href="#Floyd法" class="headerlink" title="Floyd法"></a>Floyd法</h4><p>知道结论进行编程容易，但是自己推导出Floyd公式比较难，理解该方法，进行编程即可<br>时间复杂度O(n),空间复杂度O(1)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="hashmap法-1"><a href="#hashmap法-1" class="headerlink" title="hashmap法"></a>hashmap法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function">ListNode* <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<span class="hljs-built_in">unordered_map</span>&lt;ListNode*, <span class="hljs-keyword">int</span>&gt; nodeMap;ListNode* cur = head;<span class="hljs-keyword">while</span> (cur)&#123;<span class="hljs-keyword">if</span> (nodeMap.find(cur) != nodeMap.end()) <span class="hljs-keyword">return</span> cur;nodeMap[cur]++;cur = cur-&gt;next;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;&#125;;</code></pre></div><h4 id="Floyd法-1"><a href="#Floyd法-1" class="headerlink" title="Floyd法"></a>Floyd法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function">ListNode* <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<span class="hljs-comment">//特判</span><span class="hljs-comment">//排除空节点或单个节点不成环的情况</span><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;ListNode* slow, * fast;slow = head;<span class="hljs-comment">//slow和fast要从head同时出发，要不然根据Floyd的原理进行指针移动会发生死循环</span>fast = head;<span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next)&#123;slow = slow-&gt;next;fast = fast-&gt;next-&gt;next;<span class="hljs-keyword">if</span> (fast==slow)<span class="hljs-comment">//存在环</span>&#123;fast = head;<span class="hljs-comment">//fast重置为head，slow不变，然后fast和slow现在开始每次只走一步，相遇点就是环的入口</span><span class="hljs-keyword">while</span> (fast!=slow)&#123;fast = fast-&gt;next;slow = slow-&gt;next;&#125;<span class="hljs-keyword">return</span> fast;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
      <tag>Floyd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】141.环形链表</title>
    <link href="/%E3%80%90leetcode%E3%80%91141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html"/>
    <url>/%E3%80%90leetcode%E3%80%91141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html</url>
    
    <content type="html"><![CDATA[<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="方法1-hash表"><a href="#方法1-hash表" class="headerlink" title="方法1 hash表"></a>方法1 hash表</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<span class="hljs-comment">//特判</span><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-built_in">unordered_map</span>&lt;ListNode*,<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">list</span>;ListNode* cur = head;<span class="hljs-keyword">while</span> (cur)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span>.find(cur) != <span class="hljs-built_in">list</span>.end()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-built_in">list</span>[cur]++;cur = cur-&gt;next;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;;</code></pre></div><h4 id="方法2-双指针"><a href="#方法2-双指针" class="headerlink" title="方法2 双指针"></a>方法2 双指针</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<span class="hljs-comment">//特判</span><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;ListNode *slow = head;<span class="hljs-comment">//慢指针</span>ListNode* fast = head-&gt;next;<span class="hljs-comment">//快指针</span><span class="hljs-keyword">while</span> (slow!=fast)&#123;<span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">nullptr</span> || fast-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//fast已走为null或fast走一步已为null</span>slow = slow-&gt;next;fast = fast-&gt;next-&gt;next;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】516. 最长回文子序列</title>
    <link href="/%E3%80%90leetcode%E3%80%91516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <url>/%E3%80%90leetcode%E3%80%91516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实就是求ｓ和ｓ的逆序的最长公共子序列的。转化成最长公共子序列问题就迎刃而解了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s2</span><span class="hljs-params">(s)</span></span>;<span class="hljs-comment">//s2反转</span>reverse(s2.begin(), s2.end());<span class="hljs-comment">//定义状态</span><span class="hljs-comment">//s的前i个字符和s2的前j个字符的LCS</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(s.size() + <span class="hljs-number">1</span>))</span></span>;<span class="hljs-comment">//初始化</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=s.size();i++)&#123;dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=s.size();i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=s.size();j++)&#123;<span class="hljs-keyword">if</span> (s[i<span class="hljs-number">-1</span>] == s2[j<span class="hljs-number">-1</span>]) &#123;dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span>&#123;dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[s.size()][s.size()];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】647. 回文子串</title>
    <link href="/%E3%80%90leetcode%E3%80%91647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html"/>
    <url>/%E3%80%90leetcode%E3%80%91647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路同最长回文子串，只不过此题再开辟一个变量记录回文子串出现的次数即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(s.size()))</span></span>;<span class="hljs-comment">//初始化</span><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.size();i++)&#123;dp[i][i] = <span class="hljs-number">1</span>;ans++;<span class="hljs-keyword">if</span> (s[i] == s[i + <span class="hljs-number">1</span>]) &#123;dp[i][i + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;ans++;&#125;&#125;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len=<span class="hljs-number">3</span>;len&lt;=s.size();len++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i+len<span class="hljs-number">-1</span>&lt;s.size();i++)&#123;<span class="hljs-keyword">int</span> j = i + len - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (s[i]==s[j]&amp;&amp;dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>])&#123;ans++;dp[i][j] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span>&#123;dp[i][j] = <span class="hljs-number">0</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> ans;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】1160. 拼写单词</title>
    <link href="/%E3%80%90leetcode%E3%80%911160-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D.html"/>
    <url>/%E3%80%90leetcode%E3%80%911160-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><font color=red size=5><br> 哈希表计数</font></br><br>对于一个单词<code>word</code>，只要其中的每个字母数量都不大于<code>chars</code>中对应的字母的数量，那么就可以用<code>chars</code>中的字母拼写出<code>word</code>。所以我们只需要用一个哈希表存储<code>chars</code>中每个字母的数量，再用一个哈希表存储<code>word</code>中每个字母的数量，最后将两个哈希表的键值逐一进行比较即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countCharacters</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words, <span class="hljs-built_in">string</span> chars)</span> </span>&#123;<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; charMap;<span class="hljs-comment">//存储chars字符串每个字符出现的次数</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars)&#123;charMap[c]++;&#125;<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;words.size();i++)&#123;<span class="hljs-comment">//存储word字符串每个字符出现的次数</span><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; wordMap;<span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c:words[i])&#123;wordMap[c]++;&#125;<span class="hljs-comment">//逐一比较</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c:words[i])&#123;<span class="hljs-keyword">if</span> (wordMap[c] &gt; charMap[c]) &#123;flag = <span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (flag) ans += words[i].size();&#125;<span class="hljs-keyword">return</span> ans;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】5. 最长回文子串</title>
    <link href="/%E3%80%90leetcode%E3%80%915-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html"/>
    <url>/%E3%80%90leetcode%E3%80%915-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="1、定义数组元素的含义-定义状态"><a href="#1、定义数组元素的含义-定义状态" class="headerlink" title="1、定义数组元素的含义/定义状态"></a>1、定义数组元素的含义/定义状态</h4><p><code>dp[i][j]</code>表示<code>S[i]</code>至<code>s[j]</code>所表示的子串是否是回文子串，是则为1，不是为0.</p><h4 id="2、找出数组间的关系式"><a href="#2、找出数组间的关系式" class="headerlink" title="2、找出数组间的关系式"></a>2、找出数组间的关系式</h4><div class="hljs"><pre><code class="hljs cpp">dp[i][j]=&#123;        dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>],S[i]==S[j]        <span class="hljs-number">0</span>,S[i]!=S[j]&#125;</code></pre></div><h4 id="3、找出初始值"><a href="#3、找出初始值" class="headerlink" title="3、找出初始值"></a>3、找出初始值</h4><p><code>dp[i][i]=1,dp[i][i+1]=(S[i]==S[i+1])?1:0</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<span class="hljs-built_in">string</span> ans;<span class="hljs-comment">//dp[i][j]:s[i]到s[j]之间所表示的字符串是否为回文子串</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(s.size()))</span></span>;<span class="hljs-comment">//初始化</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.size();i++)&#123;<span class="hljs-keyword">if</span> (ans.size() &lt; <span class="hljs-number">1</span>) ans = s[i];dp[i][i] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (i&lt;s.size()<span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">if</span> (s[i] == s[i + <span class="hljs-number">1</span>])&#123;dp[i][i + <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (ans.size() &lt; <span class="hljs-number">2</span>) ans = s.substr(i, <span class="hljs-number">2</span>);&#125;&#125;&#125;<span class="hljs-comment">//状态转移</span><span class="hljs-comment">//从字符串长度及位置开始枚举，进行状态的转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len=<span class="hljs-number">3</span>;len&lt;=s.size();len++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i+len<span class="hljs-number">-1</span>&lt;s.size();i++)&#123;<span class="hljs-keyword">int</span> j = i + len - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (s[i] == s[j]&amp;&amp;dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]) &#123;<span class="hljs-comment">//两个字符相等，且s[i+1]与s[j-1]之间也为回文串</span>dp[i][j] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (ans.size() &lt; len) ans=s.substr(i, len);&#125;<span class="hljs-keyword">else</span>&#123;dp[i][j] = <span class="hljs-literal">false</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> ans;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】57. 和为s的两个数字</title>
    <link href="/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9157-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97.html"/>
    <url>/%E3%80%90%E5%89%91%E6%8C%87offer%E3%80%9157-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>刚开始自己的想法，对数组进行遍历，取第一个数时，通过二分法来找<code>target-nums[i]</code>，但发现最终这样的代码超时，时间复杂度<code>O(nlogn)</code></p><p>改进的想法<br>使用双指针法，左指针指向最小元素，右指针指向最大元素，<br>比较两个指针所指元素的和与<code>target</code>的大小，如果相等，则说明找到，如果<code>sum&gt;target</code>，则左指针++，反之，右指针++</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size()<span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span> (left&lt;right)&#123;sum = nums[left] + nums[right];<span class="hljs-keyword">if</span> (sum==target)&#123;ans.push_back(nums[left]);ans.push_back(nums[right]);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (sum &gt; target) right--;<span class="hljs-keyword">else</span> left++;&#125;<span class="hljs-keyword">return</span> ans;&#125;&#125;;</code></pre></div><h4 id="超时解法"><a href="#超时解法" class="headerlink" title="超时解法"></a>超时解法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)&#123;ans.push_back(nums[i]);<span class="hljs-keyword">if</span> (binarySearch(nums, target - nums[i])) &#123;ans.push_back(target - nums[i]);<span class="hljs-keyword">return</span> ans;&#125;ans.pop_back();&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums, <span class="hljs-keyword">int</span> t)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> right = nums.size() - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (left&lt;=right)&#123;<span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (nums[mid] == t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; t) &#123;<span class="hljs-comment">//向左找</span>right = mid - <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid]&lt;t)<span class="hljs-comment">//向右找</span>&#123;left = mid + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【程序员面试金典】17.16.按摩师</title>
    <link href="/%E3%80%90%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E3%80%9117-16-%E6%8C%89%E6%91%A9%E5%B8%88.html"/>
    <url>/%E3%80%90%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E3%80%9117-16-%E6%8C%89%E6%91%A9%E5%B8%88.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="一、定义数组元素的含义"><a href="#一、定义数组元素的含义" class="headerlink" title="一、定义数组元素的含义"></a>一、定义数组元素的含义</h4><p><code>dp[i]</code>:第i次预约时，按摩师总预约时间长</p><h4 id="二、找出关系数组元素间的关系式"><a href="#二、找出关系数组元素间的关系式" class="headerlink" title="二、找出关系数组元素间的关系式"></a>二、找出关系数组元素间的关系式</h4><p>第i次时，总预约时长，要么是从第i-2次接受预约后，本次也接受预约，要么本次不接受预约<br><code>dp[i] = max(dp[i - 2] + nums[i-1], dp[i - 1]);</code></p><h4 id="三、找出初始值"><a href="#三、找出初始值" class="headerlink" title="三、找出初始值"></a>三、找出初始值</h4><p>由题目可知，第1次接受预约时，总预约时长为<code>dp[1]=nums[0]</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">massage</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-keyword">if</span> (nums.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size() +<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//初始值</span>dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=nums.size();i++)&#123;dp[i] = max(dp[i - <span class="hljs-number">2</span>] + nums[i<span class="hljs-number">-1</span>], dp[i - <span class="hljs-number">1</span>]);&#125;<span class="hljs-keyword">return</span> dp[nums.size()];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>程序员面试金典</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【程序员面试金典】16.17.连续数列</title>
    <link href="/%E3%80%90%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E3%80%9116-17-%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%88%97.html"/>
    <url>/%E3%80%90%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E3%80%9116-17-%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%88%97.html</url>
    
    <content type="html"><![CDATA[<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-keyword">if</span> (nums.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">int</span> sum = dp[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.size();i++)&#123;dp[i] = max(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]);<span class="hljs-keyword">if</span> (dp[i] &gt; sum) sum = dp[i];&#125;<span class="hljs-keyword">return</span> sum;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>程序员面试金典</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【程序员面试金典】16.17.三步问题</title>
    <link href="/%E3%80%90%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E3%80%9116-17-%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98.html"/>
    <url>/%E3%80%90%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E3%80%9116-17-%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98.html</url>
    
    <content type="html"><![CDATA[<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">waysToStep</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">4</span>)</span></span>;dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;dp[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">4</span>;i&lt;=n;i++)&#123;dp[i] = ((dp[i - <span class="hljs-number">1</span>] % mod  + dp[i - <span class="hljs-number">2</span>] % mod ) % mod + dp[i - <span class="hljs-number">3</span>] % mod )%mod;&#125;<span class="hljs-keyword">return</span> dp[n];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>程序员面试金典</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】300. 最长上升子序列</title>
    <link href="/%E3%80%90leetcode%E3%80%91300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <url>/%E3%80%90leetcode%E3%80%91300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一、定义数组元素的含义<br><code>dp[i]</code>：到第i个元素的时最长子序列的长度<br>二、找出关系数组间的关系式</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (nums[i] &gt; nums[j])<span class="hljs-comment">//出现上升</span>&#123;dp[i] = max(dp[j] + <span class="hljs-number">1</span>, dp[i]);&#125;</code></pre></div><p>三、找出初始值<br><code>dp[i] = 1;</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//dp[i]：到第i个元素的时最长子序列的长度</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-keyword">if</span> (nums.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)&#123;dp[i] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<span class="hljs-comment">//将第i个元素与前j个元素一一比较</span>&#123;<span class="hljs-keyword">if</span> (nums[i] &gt; nums[j])<span class="hljs-comment">//出现上升</span>&#123;dp[i] = max(dp[j] + <span class="hljs-number">1</span>, dp[i]);&#125;&#125;&#125;<span class="hljs-keyword">return</span> *max_element(dp.begin(), dp.end());&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】1071. 字符串的最大公因子</title>
    <link href="/%E3%80%90leetcode%E3%80%911071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90.html"/>
    <url>/%E3%80%90leetcode%E3%80%911071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>枚举法<br>从<code>1~min(str1.length(), str2.length())</code>的范围枚举每个子串，对每个子串进行check，判断其是否属于将等于该字符串</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">gcdOfStrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str1, <span class="hljs-built_in">string</span> str2)</span> </span>&#123;<span class="hljs-keyword">if</span> (str1.empty() || str2.empty()) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = min(str1.length(), str2.length()); i &gt; <span class="hljs-number">0</span>; i--)&#123;<span class="hljs-keyword">if</span> (str1.length() % i == <span class="hljs-number">0</span> &amp;&amp; str2.length() % i == <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">string</span> temp = str1.substr(<span class="hljs-number">0</span>, i);<span class="hljs-keyword">if</span> (check(temp, str1) &amp;&amp; check(temp, str2)) &#123;<span class="hljs-keyword">return</span> temp;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-built_in">string</span> temp, <span class="hljs-built_in">string</span> str)</span> </span>&#123;<span class="hljs-keyword">int</span> count = str.size() / temp.size();<span class="hljs-built_in">string</span> x = <span class="hljs-string">""</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)&#123;x += temp;&#125;<span class="hljs-keyword">return</span> x==str;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】912. 排序数组</title>
    <link href="/%E3%80%90leetcode%E3%80%91912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.html"/>
    <url>/%E3%80%90leetcode%E3%80%91912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.html</url>
    
    <content type="html"><![CDATA[<h1 id="本道题目专用于练习排序算法，后续会补齐其他排序算法的代码"><a href="#本道题目专用于练习排序算法，后续会补齐其他排序算法的代码" class="headerlink" title="本道题目专用于练习排序算法，后续会补齐其他排序算法的代码"></a><strong><em>本道题目专用于练习排序算法，后续会补齐其他排序算法的代码</em></strong></h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">/*归并排序*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(nums.size())</span></span>;MergeSort(nums, temp, <span class="hljs-number">0</span>, nums.size() - <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> nums;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;temp,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (l&lt;r)&#123;<span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<span class="hljs-comment">//分</span>MergeSort(nums, temp, l, mid);<span class="hljs-comment">//分</span>MergeSort(nums, temp, mid + <span class="hljs-number">1</span>, r);<span class="hljs-comment">//治</span>Merge(nums, temp, l, mid, r);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; temp, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k=l;k &lt;= r;k++)<span class="hljs-comment">//将分的数组合并到nums中，</span>&#123;<span class="hljs-keyword">if</span> (i &gt; mid) &#123;<span class="hljs-comment">//此时左边部分已全部加入到temp中</span>temp[k] = nums[j++];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; r) &#123;<span class="hljs-comment">//此时右边部分已全部加入到temp中</span>temp[k] = nums[i++];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &lt; nums[j]) &#123;<span class="hljs-comment">//左边数组中的元素小于右边数组的元素</span>temp[k] = nums[i++];&#125;<span class="hljs-keyword">else</span>&#123;temp[k] = nums[j++];&#125;&#125;<span class="hljs-comment">//将temp中的元素赋值给nums中</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k=l;k&lt;=r;k++)&#123;nums[k] = temp[k];&#125;&#125;&#125;;</code></pre></div><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="分割操作，单向调整"><a href="#分割操作，单向调整" class="headerlink" title="分割操作，单向调整"></a>分割操作，单向调整</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;QuickSort(nums, <span class="hljs-number">0</span>, nums.size()<span class="hljs-number">-1</span>);<span class="hljs-keyword">return</span> nums;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (l&lt;r)&#123;<span class="hljs-keyword">int</span> mid = partition(nums, l, r);QuickSort(nums, l, mid<span class="hljs-number">-1</span>);<span class="hljs-comment">//注意点，l和r的值自己写错</span>QuickSort(nums, mid + <span class="hljs-number">1</span>, r);<span class="hljs-comment">//注意点,l和r的值自己写错</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//选取不同的主元，交换方式不一样，选取左主元，得从右向左遍历，且判断该pivot是否小于当前元素，小于则交换</span><span class="hljs-comment">//下面以右主元为例</span><span class="hljs-keyword">int</span> pivot = nums[r];<span class="hljs-comment">//两个指针,一者移动</span><span class="hljs-keyword">int</span> i = l, j = l,temp;<span class="hljs-comment">//遍历序列，找主元应该插入的位置</span><span class="hljs-keyword">for</span> (;j&lt;r;j++)&#123;<span class="hljs-comment">//交换</span><span class="hljs-keyword">if</span> (nums[j] &lt; pivot) &#123;temp = nums[i];nums[i] = nums[j];nums[j] = temp;i++;&#125;&#125;nums[r] = nums[i];nums[i] = pivot;<span class="hljs-keyword">return</span> i;<span class="hljs-comment">//返回分割位置</span>&#125;&#125;;</code></pre></div><h3 id="分割操作，双向调整"><a href="#分割操作，双向调整" class="headerlink" title="分割操作，双向调整"></a>分割操作，双向调整</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;QuickSort(nums, <span class="hljs-number">0</span>, nums.size() - <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> nums;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (l &lt; r)&#123;<span class="hljs-keyword">int</span> mid = partition(nums, l, r);QuickSort(nums, l, mid - <span class="hljs-number">1</span>);<span class="hljs-comment">//注意点，l和r的值自己写错</span>QuickSort(nums, mid + <span class="hljs-number">1</span>, r);<span class="hljs-comment">//注意点,l和r的值自己写错</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> pivot = nums[l];<span class="hljs-keyword">int</span> i = l + <span class="hljs-number">1</span>, j = r;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[i] &lt;= pivot) i++;<span class="hljs-comment">//寻找比pivot大的元素</span><span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[j] &gt;= pivot) j--;<span class="hljs-comment">//寻找比pivot小的元素</span><span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-keyword">break</span>;swap(nums[i], nums[j]);&#125;<span class="hljs-comment">//把arr[j]和主元交换</span>swap(nums[j], nums[l]);<span class="hljs-keyword">return</span> j;<span class="hljs-comment">//为什么返回j而不是i，因为swap是先执行i++的while语句，如果和下面的替换顺序，则返回i</span>&#125;&#125;;</code></pre></div><h3 id="分割操作，双向调整，加入随机函数"><a href="#分割操作，双向调整，加入随机函数" class="headerlink" title="分割操作，双向调整，加入随机函数"></a>分割操作，双向调整，加入随机函数</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;QuickSort(nums, <span class="hljs-number">0</span>, nums.size() - <span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> nums;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<span class="hljs-keyword">if</span> (l &lt; r)&#123;<span class="hljs-keyword">int</span> partition = randomPartition(nums, l, r);QuickSort(nums, l, partition - <span class="hljs-number">1</span>);QuickSort(nums, partition + <span class="hljs-number">1</span>, r);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">randomPartition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i = (rand() % (r - l + <span class="hljs-number">1</span>)) + l;<span class="hljs-comment">//产生[a,b]的随机整数</span>swap(nums[i], nums[l]);<span class="hljs-keyword">return</span> partition(nums, l, r);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> pivot = nums[l];<span class="hljs-keyword">int</span> i = l + <span class="hljs-number">1</span>, j = r;<span class="hljs-comment">//双指针，分别指向首尾</span><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[i] &lt;= pivot) i++;<span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[j] &gt;= pivot) j--;<span class="hljs-keyword">if</span> (i &gt; j) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//交换位置</span>swap(nums[i], nums[j]);&#125;<span class="hljs-comment">//交换主元</span>swap(nums[j], nums[l]);<span class="hljs-keyword">return</span> j;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>SUM</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】395. 至少有K个重复字符的最长子串</title>
    <link href="/%E3%80%90leetcode%E3%80%91395-%E8%87%B3%E5%B0%91%E6%9C%89k%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html"/>
    <url>/%E3%80%90leetcode%E3%80%91395-%E8%87%B3%E5%B0%91%E6%9C%89k%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分治思想<br>先遍历一遍统计字符串S中每个字母出现的次数，然后再遍历一遍找到出现次数小于k的一个字母对应的位置(partition)，包含S[mid]的子串显然不可能符合题目要求，所以原问题求S[l,r]字符串对应的答案等价于求S[l,partition-1]和S[partition+1,r]；<br>此外，可以对一些情况进行优化，例如，当l和r所指字符已经不符合题目要求，可以跳过这些字符，以减少计算量。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="未改进代码"><a href="#未改进代码" class="headerlink" title="未改进代码"></a>未改进代码</h4><p>超时</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">int</span> k;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<span class="hljs-keyword">this</span>-&gt;k = k;<span class="hljs-keyword">return</span> cnt(s,<span class="hljs-number">0</span>,s.size()<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; ch;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= r; i++)<span class="hljs-comment">//统计每个字符出现的次数</span>&#123;ch[s[i]]++;&#125;<span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//此时该子串size小于k，不存在</span><span class="hljs-comment">//寻找分割位置</span><span class="hljs-comment">//如果在l和r和范围内遇到不满足&gt;=k的，即为分割位置</span><span class="hljs-keyword">int</span> partition = l;<span class="hljs-keyword">while</span> (partition&lt;=r&amp;&amp;ch[s[partition]]&gt;=k)&#123;partition++;&#125;<span class="hljs-keyword">if</span> (partition &gt; r) <span class="hljs-keyword">return</span> r - l+<span class="hljs-number">1</span>;<span class="hljs-comment">//分割位置不存在，说明此时的串符合要求</span><span class="hljs-comment">//存在分割位置，则取其左右子串两者的最大值</span><span class="hljs-keyword">return</span> max(cnt(s, l, partition - <span class="hljs-number">1</span>), cnt(s, partition + <span class="hljs-number">1</span>, r));&#125;&#125;;</code></pre></div><h4 id="改进代码"><a href="#改进代码" class="headerlink" title="改进代码"></a>改进代码</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">int</span> k;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<span class="hljs-keyword">this</span>-&gt;k = k;<span class="hljs-keyword">return</span> cnt(s,<span class="hljs-number">0</span>,s.size()<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; ch;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= r; i++)<span class="hljs-comment">//统计每个字符出现的次数</span>&#123;ch[s[i]]++;&#125;<span class="hljs-comment">//从左到右和从右到左分别跳过字符串中不符合的字符，直到遇到符合的字符位置为止</span><span class="hljs-keyword">while</span> (l&lt;=r&amp;&amp;ch[s[l]]&lt;k)&#123;l++;&#125;<span class="hljs-keyword">while</span> (l&lt;=r&amp;&amp;ch[s[r]]&lt;k)&#123;r--;&#125;<span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//此时该子串size小于k，不存在</span><span class="hljs-comment">//寻找分割位置</span><span class="hljs-comment">//如果在l和r和范围内遇到不满足&gt;=k的，即为分割位置</span><span class="hljs-keyword">int</span> partition = l;<span class="hljs-keyword">while</span> (partition&lt;=r&amp;&amp;ch[s[partition]]&gt;=k)&#123;partition++;&#125;<span class="hljs-keyword">if</span> (partition &gt;= r) <span class="hljs-keyword">return</span> r - l + <span class="hljs-number">1</span>;<span class="hljs-comment">//分割位置不存在，说明此时的串符合要求</span><span class="hljs-comment">//存在分割位置，则取其左右子串两者的最大值</span><span class="hljs-keyword">return</span> max(cnt(s, l, partition - <span class="hljs-number">1</span>), cnt(s, partition + <span class="hljs-number">1</span>, r));&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】1025. 除数博弈</title>
    <link href="/%E3%80%90leetcode%E3%80%911025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88.html"/>
    <url>/%E3%80%90leetcode%E3%80%911025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一 动态规划"></a>方法一 动态规划</h4><h5 id="第一步：定义数组元素的含义"><a href="#第一步：定义数组元素的含义" class="headerlink" title="第一步：定义数组元素的含义"></a>第一步：定义数组元素的含义</h5><p><code>dp[n]</code>:数字为n时，此时取数字者的游戏结果</p><h5 id="第二步：找出关系数组元素间的关系时"><a href="#第二步：找出关系数组元素间的关系时" class="headerlink" title="第二步：找出关系数组元素间的关系时"></a>第二步：找出关系数组元素间的关系时</h5><p>假设Alice的<code>dp[i]=false</code>;<br>如果Alice取某个数字后，能使得Bob一定为<code>false</code>，则此时Alice一定胜</p><h5 id="第三步：找出初始值"><a href="#第三步：找出初始值" class="headerlink" title="第三步：找出初始值"></a>第三步：找出初始值</h5><p>在<code>n=1</code>时，Alice先取，一定无法获胜<code>dp[1]=false</code>;<br>在<code>n=2</code>时，Alice先取，一定可以获胜 <code>dp[2]=true</code>;</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">divisorGame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(N+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//base case</span>dp[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;dp[<span class="hljs-number">2</span>] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;i&lt;=N;i++)&#123;dp[i] = <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<span class="hljs-keyword">if</span> ((i%j==<span class="hljs-number">0</span>)&amp;&amp;!dp[i-j])<span class="hljs-comment">//所取的数复合条件，且取完该数后，Bob在i-j数的游戏结果为false，则此时alice的游戏结果为true</span>&#123;dp[i] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[N];&#125;&#125;;</code></pre></div><h4 id="方法二-数学法"><a href="#方法二-数学法" class="headerlink" title="方法二 数学法"></a>方法二 数学法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">divisorGame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<span class="hljs-keyword">return</span> N%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】746. 使用最小花费爬楼梯</title>
    <link href="/%E3%80%90leetcode%E3%80%91746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html"/>
    <url>/%E3%80%90leetcode%E3%80%91746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="第一步：定义数组元素的含义"><a href="#第一步：定义数组元素的含义" class="headerlink" title="第一步：定义数组元素的含义"></a>第一步：定义数组元素的含义</h4><p>题目的要求的是爬到楼层顶部需要的最低花费。因此可将<code>dp</code>定义为，<strong>到达第n阶台阶时的最低花费<code>dp[i]</code></strong><br>由于最终要到达的是楼顶，所以此处<code>dp</code>的<code>size</code>为<code>cost</code>的<code>size+1</code>。</p><h4 id="第二步：找出关系数组元素间的关系式"><a href="#第二步：找出关系数组元素间的关系式" class="headerlink" title="第二步：找出关系数组元素间的关系式"></a>第二步：找出关系数组元素间的关系式</h4><p>要到达下一阶，可以走一步，也可以走两步，要到达位置<code>i</code>，<br>一种是从<code>i-1</code>这个位置走一步到达<br>一种是从<code>i-2</code>这个位置走一步到达<br>因为是要计算走到<code>i</code>位置时，花费最小，要取上述两种情况中的最小者，此处<code>cost[i]</code>表示的是到达i+1/i+2阶所需要的体力花费值，所以到达了i-1/i-2阶后，再到达i阶台阶要花费的最小力气关系式是<code>dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])</code></p><h4 id="第三步：找出初始值"><a href="#第三步：找出初始值" class="headerlink" title="第三步：找出初始值"></a>第三步：找出初始值</h4><p>由题目可知，在开始时，我们可以从索引0或者1的元素作为初始阶梯，因此初始值为<code>dp[0]=0</code>和<code>dp[1]=0</code></p><p>另外需要注意的是对特殊情况的判断</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; cost)</span> </span>&#123;<span class="hljs-comment">//特判</span><span class="hljs-keyword">if</span> (cost.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (cost.size() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> cost[<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span> (cost.size() == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> min(cost[<span class="hljs-number">0</span>], cost[<span class="hljs-number">1</span>]);<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size()+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//初始值</span>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=cost.size();i++)&#123;dp[i] = min(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);&#125;<span class="hljs-keyword">return</span> dp[cost.size()];&#125;&#125;;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】72. 编辑距离</title>
    <link href="/%E3%80%90leetcode%E3%80%9172-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html"/>
    <url>/%E3%80%90leetcode%E3%80%9172-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="第一步：定义数组元素的含义"><a href="#第一步：定义数组元素的含义" class="headerlink" title="第一步：定义数组元素的含义"></a>第一步：定义数组元素的含义</h4><p><strong>当字符串<code>word1</code>的长度为i，字符串<code>word2</code>的长度为j时，将<code>word1</code>转化为<code>word2</code>所使用的最少操作次数为<code>dp[i][j]</code></strong><br><em>这句定义可以说使理解这道题目的核心，一定要理解dp数组的含义，这样才会理解关系式是如何得出的</em></p><h4 id="第二步：找出关系数组元素间的关系时"><a href="#第二步：找出关系数组元素间的关系时" class="headerlink" title="第二步：找出关系数组元素间的关系时"></a>第二步：找出关系数组元素间的关系时</h4><p>我们的目标是，从规模小的，通过一些操作，推导出规模大的。对于这道题，对<code>word1</code>进行三种操作<br>插入、删除、替换<br>由于我们是要让操作的次数最小，所以我们要寻找最佳操作<br>2.2 当<code>word1[i]```与`word[j]</code>相等，这个时候不需要任何操作，此时最少操作次数<code>dp[i][j]=dp[i-1][j-1]</code><br>2.3 如果不相等，此时有三种操作</p><ul><li>2.3.1 如果实行插入<code>dp[i][j]=dp[i][j-1]+1</code>;</li><li>2.3.2 如果实行删除<code>dp[i][j]=dp[i-1][j]+1</code>;</li><li>2.3.3 如果实行替换<code>dp[i][j]=dp[i-1][j-1]+1</code>;<h4 id="第三步：找出初始值"><a href="#第三步：找出初始值" class="headerlink" title="第三步：找出初始值"></a>第三步：找出初始值</h4>如果i或者<code>j</code>有一个为0，则<code>word1</code>要么一直插入<code>(i==0)</code>，要么一直删除<code>(j==0)</code>，才能到达<code>word2</code></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word1, <span class="hljs-built_in">string</span> word2)</span> </span>&#123;<span class="hljs-keyword">int</span> n1 = word1.length();<span class="hljs-keyword">int</span> n2 = word2.length();<span class="hljs-comment">//特判</span><span class="hljs-comment">//if (n1*n2==0) return n1+n2;</span><span class="hljs-comment">//定义数组元素的含义</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n1+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n2+<span class="hljs-number">1</span>))</span></span>;<span class="hljs-comment">//初始值</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n2; j++)<span class="hljs-comment">//插入</span>&#123;dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++)<span class="hljs-comment">//删除</span>&#123;dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n1; i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n2; j++)&#123;<span class="hljs-keyword">if</span> (word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>]) &#123;dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">else</span>&#123;dp[i][j] = min(dp[i - <span class="hljs-number">1</span>][j], min(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<span class="hljs-comment">//删除、插入、替换</span>&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[n1][n2];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】64. 最小路径和</title>
    <link href="/%E3%80%90leetcode%E3%80%9164-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.html"/>
    <url>/%E3%80%90leetcode%E3%80%9164-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="第一步：定义数组元素的含义"><a href="#第一步：定义数组元素的含义" class="headerlink" title="第一步：定义数组元素的含义"></a>第一步：定义数组元素的含义</h4><p>题目的要求的是到达网格的右下角，路径上的数字和为最小。因此可将<code>dp</code>定义为，<strong>当走到(i,j)这个位置时，路径数字和最小为<code>dp[i][j]</code></strong></p><h4 id="第二步：找出关系数组元素间的关系时"><a href="#第二步：找出关系数组元素间的关系时" class="headerlink" title="第二步：找出关系数组元素间的关系时"></a>第二步：找出关系数组元素间的关系时</h4><p>要到达右下角，可以往下走，也可以往右走，要到达位置<code>(i,j)</code>，<br>一种是从<code>(i-1,j)</code>这个位置走一步到达<br>一种是从<code>(i,j-1)</code>这个位置走一步到达<br>因为是要计算走到<code>(i,j)</code>位置时，数字和要为最小，所以是要取上述两种情况中的最小者，所以关系式是<code>dp[i][j]=min(dp[i][j-1],dp[i-1][j])+grid[i][j];</code></p><h4 id="第三步：找出初始值"><a href="#第三步：找出初始值" class="headerlink" title="第三步：找出初始值"></a>第三步：找出初始值</h4><p><code>dp[i][j]</code>中，如果i或者j有一个为0，那么就不能用关系式了，因为这个时候i-1或者j-1就变成负数了，数组就会出问题，所以我们的初始值是计算出所有的<code>dp[0][0...n-1]</code>和所有的<code>dp[0...m-1][0]</code>。初始值如下<br><code>i=0,j=0,dp[0][0]=num[0][0]</code>//起点(0,0)<br><code>i=0,dp[0][j]=dp[0][j-1]+grid[0][j];</code> // 相当于最上面一行，只能一直往左走<br><code>j=0,dp[i][0]=dp[i-1][0]+grid[i][0]</code> // 相当于最左面一列，只能一直往下走</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//1、走到(i,j)这个位置时，路径上的最小数字和为dp[i][j]</span><span class="hljs-comment">//2、dp[i][j]=min(dp[i][j-1],dp[i-1][j])+grid[i][j];</span><span class="hljs-comment">//3、i=0,j=0,dp[0][0]=num[0][0]</span><span class="hljs-comment">//  i=0,dp[0][j]=dp[0][j-1]+grid[0][j]</span><span class="hljs-comment">//  j=0,dp[i][0]=dp[i-1][0]+grid[i][0]</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(grid.size(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(grid[<span class="hljs-number">0</span>].size))</span></span>;<span class="hljs-comment">//Base case</span>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;grid[<span class="hljs-number">0</span>].size();j++)&#123;dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;grid.size();i++)&#123;dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;grid.size();i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;grid[<span class="hljs-number">0</span>].size();j++)&#123;dp[i][j] = min(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]) + grid[i][j];&#125;&#125;<span class="hljs-keyword">return</span> dp[dp.size() - <span class="hljs-number">1</span>][dp[<span class="hljs-number">0</span>].size() - <span class="hljs-number">1</span>];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】62. 不同路径</title>
    <link href="/%E3%80%90leetcode%E3%80%9162-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html"/>
    <url>/%E3%80%90leetcode%E3%80%9162-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="第一步：定义数组元素的含义"><a href="#第一步：定义数组元素的含义" class="headerlink" title="第一步：定义数组元素的含义"></a>第一步：定义数组元素的含义</h4><p>题目的要求的是机器人到达网格的右下角，总共有多少条不同的路径。因此可将<code>dp</code>定义为，<strong>当机器人走到(i,j)这个位置时，一共有<code>dp[i][j]</code>条路径</strong></p><h4 id="第二步：找出关系数组元素间的关系时"><a href="#第二步：找出关系数组元素间的关系时" class="headerlink" title="第二步：找出关系数组元素间的关系时"></a>第二步：找出关系数组元素间的关系时</h4><p>机器人要到达右下角，可以往下走，也可以往右走，要到达位置<code>(i,j)</code>，<br>一种是从<code>(i-1,j)</code>这个位置走一步到达<br>一种是从<code>(i,j-1)</code>这个位置走一步到达<br>因为是要计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是<code>dp[i][j]=dp[i-1][j]+dp[i][j-1]</code></p><h4 id="第三步：找出初始值"><a href="#第三步：找出初始值" class="headerlink" title="第三步：找出初始值"></a>第三步：找出初始值</h4><p><code>dp[i][j]</code>中，如果i或者j有一个为0，那么就不能用关系式了，因为这个时候i-1或者j-1就变成负数了，数组就会出问题，所以我们的初始值是计算出所有的<code>dp[0][0...n-1]</code>和所有的<code>dp[0...m-1][0]</code>。这个是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下<br><code>dp[0] [0….n-1] = 1;</code> // 相当于最上面一行，机器人只能一直往左走<br><code>dp[0…m-1] [0] = 1;</code> // 相当于最左面一列，机器人只能一直往下走</p><h3 id="代码（自底向上）"><a href="#代码（自底向上）" class="headerlink" title="代码（自底向上）"></a>代码（自底向上）</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-comment">//定义数组元素的含义</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n))</span></span>;<span class="hljs-comment">//初始化</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<span class="hljs-comment">//dp[0][j]=dp[0][j-1]</span>&#123;dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<span class="hljs-comment">//dp[i][0]=dp[i][0]</span>&#123;dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];&#125;&#125;<span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】322. 零钱兑换</title>
    <link href="/%E3%80%90leetcode%E3%80%91322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html"/>
    <url>/%E3%80%90leetcode%E3%80%91322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>dp[n]:当前的目标金额是n，至少需要dp[n]个金币凑出该金额<br>初始值，dp[0]=0,目标金额为0，需要0个金币<br>状态转移，dp[money] = min(dp[money], dp[money - coin] + 1);<br>当前需要金币个数，等于dp[money-coin]+1个与dp[money]的小者</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//动态规划-迭代</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<span class="hljs-comment">//初始化dp数组</span><span class="hljs-comment">//初始值为amount+1是因为，amount+1将是硬币个数的最大值，所以可以用此数值</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, amount + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//base case </span>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> money = <span class="hljs-number">1</span>; money &lt;= amount; money++)<span class="hljs-comment">//内层for求所有子问题+1的最小值</span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins)&#123;<span class="hljs-comment">//状态转移</span><span class="hljs-keyword">if</span> (money - coin &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//当前的钱数比硬币的面额大，才能选择这种硬币</span>dp[money] = min(dp[money], dp[money - coin] + <span class="hljs-number">1</span>);&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[amount] == amount + <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : dp[amount];&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【OpenGL】绘制球体</title>
    <link href="/%E3%80%90opengl%E3%80%91%E7%BB%98%E5%88%B6%E7%90%83%E4%BD%93.html"/>
    <url>/%E3%80%90opengl%E3%80%91%E7%BB%98%E5%88%B6%E7%90%83%E4%BD%93.html</url>
    
    <content type="html"><![CDATA[<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="1-初始化："><a href="#1-初始化：" class="headerlink" title="1-初始化："></a>1-初始化：</h4><p> GLFW窗口，GLAD</p><h4 id="2-计算球体顶点："><a href="#2-计算球体顶点：" class="headerlink" title="2-计算球体顶点："></a>2-计算球体顶点：</h4><p>通过数学方法计算球体的每个顶点坐标</p><h4 id="3-数据处理："><a href="#3-数据处理：" class="headerlink" title="3-数据处理："></a>3-数据处理：</h4><p> 通过球体顶点坐标构造三角形网络，生成并绑定VAO&amp;VBO&amp;EBO（准备再GPU中进行处理)，设置顶点属性指针（本质上就是告诉OpenGL如何处理数据）</p><h4 id="4-着色器："><a href="#4-着色器：" class="headerlink" title="4-着色器："></a>4-着色器：</h4><p>给出顶点和片段着色器，然后链接为着色器程序，渲染时使用着色器程序</p><h4 id="5-渲染："><a href="#5-渲染：" class="headerlink" title="5-渲染："></a>5-渲染：</h4><p>使用画线模式画圆，开启面剔除，剔除背面，使用线框模式画球,清空缓冲，交换缓冲区检查触发事件</p><h4 id="6-结束："><a href="#6-结束：" class="headerlink" title="6-结束："></a>6-结束：</h4><p>释放资源</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><h4 id="填充模式和线框模式效果对比"><a href="#填充模式和线框模式效果对比" class="headerlink" title="填充模式和线框模式效果对比"></a>填充模式和线框模式效果对比</h4><div align=center><img src="https://img-blog.csdnimg.cn/20200306183123169.png" srcset="/img/loading.gif" width=400 height=400><img src="https://img-blog.csdnimg.cn/20200306183442280.png" srcset="/img/loading.gif" width=400 height=400></div><h4 id="开启面剔除和线框模式效果对比"><a href="#开启面剔除和线框模式效果对比" class="headerlink" title="开启面剔除和线框模式效果对比"></a>开启面剔除和线框模式效果对比</h4><p>只需要展示一个面，否则会有重合，此处剔除背面为例</p><div align=center><img src="https://img-blog.csdnimg.cn/20200306183708962.png" srcset="/img/loading.gif" width=400 height=400><img src="https://img-blog.csdnimg.cn/20200306183442280.png" srcset="/img/loading.gif" width=400 height=400></div><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>此处只给出main.cpp,具体工程参考<a href="">本人的github</a></p><h5 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><span class="hljs-comment">步骤：</span><span class="hljs-comment">1-初始化： GLFW窗口，GLAD</span><span class="hljs-comment">2-计算球体顶点：通过数学方法计算球体的每个顶点坐标</span><span class="hljs-comment">3-数据处理： 通过球体顶点坐标构造三角形网络，生成并绑定VAO&amp;VBO&amp;EBO（准备再GPU中进行处理)，设置顶点属性指针（本质上就是告诉OpenGL如何处理数据）</span><span class="hljs-comment">4-着色器：给出顶点和片段着色器，然后链接为着色器程序，渲染时使用着色器程序</span><span class="hljs-comment">5-渲染：使用画线模式画圆，开启面剔除，剔除背面，使用线框模式画球,清空缓冲，交换缓冲区检查触发事件</span><span class="hljs-comment">6-结束：释放资源</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glad/glad.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GLFW/glfw3.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Shader.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> screen_width = <span class="hljs-number">780</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> screen_height = <span class="hljs-number">780</span>;<span class="hljs-keyword">const</span> GLfloat PI= <span class="hljs-number">3.14159265358979323846f</span>;<span class="hljs-comment">//将球横纵划分成50*50的网格</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Y_SEGMENTS = <span class="hljs-number">50</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> X_SEGMENTS = <span class="hljs-number">50</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*1-初始化*/</span><span class="hljs-comment">//初始化GLFW</span>glfwInit();<span class="hljs-comment">//初始化GLFW</span>glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);<span class="hljs-comment">//opengl版本号3.3</span>glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);<span class="hljs-comment">// 次版本号3</span>glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="hljs-comment">//使用核心模式(无序向后兼容性)</span>glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);<span class="hljs-comment">//如果使用的是Mac OS X系统，需加上这行</span>glfwWindowHint(GLFW_RESIZABLE, <span class="hljs-literal">false</span>);<span class="hljs-comment">//不可改变窗口大小</span><span class="hljs-comment">//创建窗口（宽、高、窗口名称）</span><span class="hljs-keyword">auto</span> window = glfwCreateWindow(screen_width, screen_height,<span class="hljs-string">"Sphere"</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<span class="hljs-comment">//检测窗口是否创建成功</span><span class="hljs-keyword">if</span> (window==<span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to Create OpenGL Context"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;glfwTerminate();<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;glfwMakeContextCurrent(window);<span class="hljs-comment">//将窗口的上下文设置为当前进程的主上下文</span><span class="hljs-comment">//初始化GLAD，加载OpenGL指针地址的函数</span><span class="hljs-keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Failed to initialize GLAD"</span>&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-comment">//指定当前视口尺寸（前两个参数为左下角位置，后两个参数是渲染窗口宽、高）</span>glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, screen_width, screen_height);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">float</span>&gt; sphereVertices;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sphereIndices;<span class="hljs-comment">/*2-计算球体顶点*/</span><span class="hljs-comment">//生成球的顶点</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>;y&lt;=Y_SEGMENTS;y++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x&lt;=X_SEGMENTS;x++)&#123;<span class="hljs-keyword">float</span> xSegment = (<span class="hljs-keyword">float</span>)x / (<span class="hljs-keyword">float</span>)X_SEGMENTS;<span class="hljs-keyword">float</span> ySegment = (<span class="hljs-keyword">float</span>)y / (<span class="hljs-keyword">float</span>)Y_SEGMENTS;<span class="hljs-keyword">float</span> xPos = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cos</span>(xSegment * <span class="hljs-number">2.0f</span> * PI) * <span class="hljs-built_in">std</span>::<span class="hljs-built_in">sin</span>(ySegment * PI);<span class="hljs-keyword">float</span> yPos = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cos</span>(ySegment * PI);<span class="hljs-keyword">float</span> zPos = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">sin</span>(xSegment * <span class="hljs-number">2.0f</span> * PI) * <span class="hljs-built_in">std</span>::<span class="hljs-built_in">sin</span>(ySegment * PI);sphereVertices.push_back(xPos);sphereVertices.push_back(yPos);sphereVertices.push_back(zPos);&#125;&#125;<span class="hljs-comment">//生成球的Indices</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;Y_SEGMENTS;i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;X_SEGMENTS;j++)&#123;sphereIndices.push_back(i * (X_SEGMENTS + <span class="hljs-number">1</span>) + j);sphereIndices.push_back((i + <span class="hljs-number">1</span>) * (X_SEGMENTS + <span class="hljs-number">1</span>) + j);sphereIndices.push_back((i + <span class="hljs-number">1</span>) * (X_SEGMENTS + <span class="hljs-number">1</span>) + j+<span class="hljs-number">1</span>);sphereIndices.push_back(i* (X_SEGMENTS + <span class="hljs-number">1</span>) + j);sphereIndices.push_back((i + <span class="hljs-number">1</span>) * (X_SEGMENTS + <span class="hljs-number">1</span>) + j + <span class="hljs-number">1</span>);sphereIndices.push_back(i * (X_SEGMENTS + <span class="hljs-number">1</span>) + j + <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-comment">/*3-数据处理*/</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> VBO, VAO;glGenVertexArrays(<span class="hljs-number">1</span>, &amp;VAO);glGenBuffers(<span class="hljs-number">1</span>, &amp;VBO);<span class="hljs-comment">//生成并绑定球体的VAO和VBO</span>glBindVertexArray(VAO);glBindBuffer(GL_ARRAY_BUFFER, VBO);<span class="hljs-comment">//将顶点数据绑定至当前默认的缓冲中</span>glBufferData(GL_ARRAY_BUFFER, sphereVertices.size() * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), &amp;sphereVertices[<span class="hljs-number">0</span>], GL_STATIC_DRAW);GLuint element_buffer_object;<span class="hljs-comment">//EBO</span>glGenBuffers(<span class="hljs-number">1</span>, &amp;element_buffer_object);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, element_buffer_object);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sphereIndices.size() * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), &amp;sphereIndices[<span class="hljs-number">0</span>], GL_STATIC_DRAW);<span class="hljs-comment">//设置顶点属性指针</span>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);glEnableVertexAttribArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//解绑VAO和VBO</span>glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);glBindVertexArray(<span class="hljs-number">0</span>);<span class="hljs-comment">/*4-着色器*/</span><span class="hljs-function">Shader <span class="hljs-title">shader</span><span class="hljs-params">(<span class="hljs-string">"task3.vs"</span>, <span class="hljs-string">"task3.fs"</span>)</span></span>;<span class="hljs-comment">/*5-渲染*/</span><span class="hljs-comment">//渲染循环</span><span class="hljs-keyword">while</span> (!glfwWindowShouldClose(window))&#123;<span class="hljs-comment">//清空颜色缓冲</span>glClearColor(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.34f</span>, <span class="hljs-number">0.57f</span>, <span class="hljs-number">1.0f</span>);glClear(GL_COLOR_BUFFER_BIT);shader.Use();<span class="hljs-comment">//绘制球</span><span class="hljs-comment">//开启面剔除(只需要展示一个面，否则会有重合)</span>glEnable(GL_CULL_FACE);glCullFace(GL_BACK);glBindVertexArray(VAO);<span class="hljs-comment">//使用线框模式绘制</span>glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);glDrawElements(GL_TRIANGLES, X_SEGMENTS * Y_SEGMENTS * <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<span class="hljs-comment">//点阵模式绘制</span><span class="hljs-comment">//glPointSize(5);</span><span class="hljs-comment">//glDrawElements(GL_POINTS, X_SEGMENTS * Y_SEGMENTS * 6, GL_UNSIGNED_INT, 0);</span><span class="hljs-comment">//交换缓冲并且检查是否有触发事件(比如键盘输入、鼠标移动)</span>glfwSwapBuffers(window);glfwPollEvents();&#125;<span class="hljs-comment">/*6-结束*/</span><span class="hljs-comment">//删除VAO和VBO，EBO</span>glDeleteVertexArrays(<span class="hljs-number">1</span>, &amp;VAO);glDeleteBuffers(<span class="hljs-number">1</span>, &amp;VBO);glDeleteBuffers(<span class="hljs-number">1</span>, &amp;element_buffer_object);<span class="hljs-comment">//清理所有的资源并正确退出程序</span>glfwTerminate();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>MOOC-计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C/C++】C/C++头文件的引用格式</title>
    <link href="/%E3%80%90c-c-%E3%80%91c-c-%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%BC%95%E7%94%A8%E6%A0%BC%E5%BC%8F.html"/>
    <url>/%E3%80%90c-c-%E3%80%91c-c-%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%BC%95%E7%94%A8%E6%A0%BC%E5%BC%8F.html</url>
    
    <content type="html"><![CDATA[<h4 id="include-lt-gt"><a href="#include-lt-gt" class="headerlink" title="#include&lt;&gt;"></a>#include&lt;&gt;</h4><p>1.在编译器设置的include路径内搜索；<br>2.如果是在命令行中编译，则在系统的INCLUDE环境变量内搜索。</p><h4 id="include””"><a href="#include””" class="headerlink" title="#include””"></a>#include””</h4><p>1.在包含当前include指令的文件所在的文件夹内搜索；<br>2.如果上一步找不到，则在之前已经使用include指令打开过的文件所在的文件夹内搜索，如果已经有多个被include的文件，则按照它们被打开的相反顺序去搜索；<br>3.如果上一步找不到，则在编译器设置的include路径内搜索；<br>4.如果上一步找不到，则在系统的include环境变量内搜索。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、使用<code>#include&lt;&gt;</code> 程序会直接到标准函数库中找文件<br>2、使用<code>#include&quot;&quot;</code> 程序会会先从当前目录中找文件，如果找不到会再到标准函数库中找文件。所以，一般情况下我们引用标准函数库中的头文件时，用#include&lt;&gt;能有更高的效率。<br>3、另外，要注意的一点就是，<strong>如果我们自己写的头文件，而不是标准库函数中的，那么引用这个头文件要使用<code>#include&quot;&quot;</code>，而不能使用<code>#include&lt;&gt;</code></strong>，因为我们<strong>自己写的头文件并不在编译器设置的路径内</strong>，使用<code>#include&lt;&gt;</code>会提示无法找到。</p>]]></content>
    
    
    <categories>
      
      <category>【被·技】C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【OpenGL】绘制四边形</title>
    <link href="/%E3%80%90opengl%E3%80%91%E7%BB%98%E5%88%B6%E5%9B%9B%E8%BE%B9%E5%BD%A2.html"/>
    <url>/%E3%80%90opengl%E3%80%91%E7%BB%98%E5%88%B6%E5%9B%9B%E8%BE%B9%E5%BD%A2.html</url>
    
    <content type="html"><![CDATA[<h3 id="EBO、VBO和VAO的简介"><a href="#EBO、VBO和VAO的简介" class="headerlink" title="EBO、VBO和VAO的简介"></a>EBO、VBO和VAO的简介</h3><p><img src="https://img-blog.csdnimg.cn/20200305224816650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200305224826602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200305224838148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200305224858755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>画一个四边形，可以有两种方法</p><p>1、通过2个三角形拼接而成，这就和前一个实验画三角形类似，利用VAO和VBO实验，我们要做的只是需要把给出的顶点增加为6个即可。</p><p>2、但是我们会发现使用上述方式，会有两个顶点我们使用了两次，一个矩形只有四个顶点，如果是大量的复杂模型计算就会产生很大浪费。如何解决这个问题呢？其实我们只要存储矩形的四个顶点，然后指定绘制顺序就好了，EBO帮助我们实现了这个功能。这种方式我们可以称之为<font color=red><strong>索引绘制</strong></font>。</p><p>定义不重复的顶点及索引数据如下：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//四边形的顶点数据</span><span class="hljs-keyword">float</span> vertices[] = &#123;<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//右上</span><span class="hljs-number">0.5f</span>,<span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//右下</span><span class="hljs-number">-0.5f</span>,<span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//左下</span><span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.0f</span><span class="hljs-comment">//左上</span>&#125;;<span class="hljs-comment">//索引数据（注意这里是从0开始的）</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> indices[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-comment">//第一个三角形</span><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><span class="hljs-comment">//第二个三角形</span>&#125;;</code></pre></div><p>创建索引缓冲对象如下：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//生成并绑定EBO</span>GLuint element_buffer_object;<span class="hljs-comment">//EBO</span>glGenBuffers(<span class="hljs-number">1</span>, &amp;element_buffer_object);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, element_buffer_object);<span class="hljs-comment">//将索引数据绑定至EBO中</span>glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</code></pre></div><p><font color=red>下面介绍通过<code>VAO+VBO+EBO</code>的形式画一个四边形</font>，<code>VAO+VBO</code>的方法同该过程，两种方法的代码都将在后面贴出</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h5 id="1-初始化："><a href="#1-初始化：" class="headerlink" title="1-初始化："></a>1-初始化：</h5><p>初始化GLFW，创建窗口，初始化GLAD，创建视口</p><h5 id="2-数据处理："><a href="#2-数据处理：" class="headerlink" title="2-数据处理："></a>2-数据处理：</h5><p>给定顶点数据，生成并绑定VAO、VBO、EBO（准备在GPU中进行处理），设置顶点属性指针（本质上就是告诉OpenGL如何处理数据）。</p><h5 id="3-着色器："><a href="#3-着色器：" class="headerlink" title="3-着色器："></a>3-着色器：</h5><p>给出顶点和片段着色器，然后链接为着色器程序，渲染时使用着色器程序。</p><h5 id="4-渲染："><a href="#4-渲染：" class="headerlink" title="4-渲染："></a>4-渲染：</h5><p>清空缓冲，使用着色器程序，绘制三角形，交换缓冲区并检查触发事件（比如键盘移动、鼠标移动）</p><h5 id="5-释放资源："><a href="#5-释放资源：" class="headerlink" title="5-释放资源："></a>5-释放资源：</h5><p>删除VAO、VBO、EBO，调用GLFW的函数来清理所有的资源并退出程序</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://img-blog.csdnimg.cn/20200305225149303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>开启线框模式的效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200305223713257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTIzNDAwMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在配置好基本的OpenGL环境下，可直接运行</p><h4 id="VAO-VBO-EBO"><a href="#VAO-VBO-EBO" class="headerlink" title="VAO+VBO+EBO"></a>VAO+VBO+EBO</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glad/glad.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GLFW/glfw3.h&gt;</span></span><span class="hljs-comment">//四边形的顶点数据</span><span class="hljs-keyword">float</span> vertices[] = &#123;<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//右上</span><span class="hljs-number">0.5f</span>,<span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//右下</span><span class="hljs-number">-0.5f</span>,<span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//左下</span><span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.0f</span><span class="hljs-comment">//左上</span>&#125;;<span class="hljs-comment">//索引数据（注意这里是从0开始的）</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> indices[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-comment">//第一个三角形</span><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><span class="hljs-comment">//第二个三角形</span>&#125;;<span class="hljs-comment">//屏幕宽、高</span><span class="hljs-keyword">int</span> screen_width = <span class="hljs-number">1280</span>;<span class="hljs-keyword">int</span> screen_height = <span class="hljs-number">720</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*初始化*/</span>glfwInit();<span class="hljs-comment">//初始化glfw</span>glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);<span class="hljs-comment">//OpenGl版本为3.3，主次版本号均为3</span>glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="hljs-comment">//使用核心模式（无需向后兼容性）</span>glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);<span class="hljs-comment">//如果使用的是Mac OS X系统，需加上这行</span>glfwWindowHint(GLFW_RESIZABLE,<span class="hljs-literal">false</span>);<span class="hljs-comment">//不可改变窗口大小</span><span class="hljs-comment">//创建窗口（宽，高，窗口名称）</span><span class="hljs-keyword">auto</span> window = glfwCreateWindow(screen_width, screen_height, <span class="hljs-string">"Quad"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<span class="hljs-keyword">if</span> (window==<span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//如果窗口创建失败，输出报错信息</span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to Create OpenGL Context"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;glfwTerminate();<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;glfwMakeContextCurrent(window);<span class="hljs-comment">//将窗口的上下文设置为当前线程的上下文</span><span class="hljs-comment">//初始化GLAD,加载OpenGL函数指针地址的函数</span><span class="hljs-keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-comment">//指定当前视口尺寸（前两个参数为左下角位置，后两个参数是渲染窗口宽、高）</span>glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, screen_width, screen_height);<span class="hljs-comment">/*数据处理*/</span><span class="hljs-comment">//生成并绑定VAO和VBO</span>GLuint vertex_array_object;<span class="hljs-comment">//VAO</span>glGenVertexArrays(<span class="hljs-number">1</span>, &amp;vertex_array_object);glBindVertexArray(vertex_array_object);GLuint vertex_buffer_object;<span class="hljs-comment">//VBO</span>glGenBuffers(<span class="hljs-number">1</span>, &amp;vertex_buffer_object);glBindBuffer(GL_ARRAY_BUFFER,vertex_buffer_object);<span class="hljs-comment">//将顶点数据绑定至VBO中</span>glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices),vertices, GL_STATIC_DRAW);<span class="hljs-comment">//生成并绑定EBO</span>GLuint element_buffer_object;<span class="hljs-comment">//EBO</span>glGenBuffers(<span class="hljs-number">1</span>, &amp;element_buffer_object);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, element_buffer_object);<span class="hljs-comment">//将索引数据绑定至EBO中</span>glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);<span class="hljs-comment">//设置顶点属性指针</span>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT,GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>),(<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);glEnableVertexAttribArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//开启0通道，默认不开启</span><span class="hljs-comment">//解绑VAO和VBO</span>glBindVertexArray(<span class="hljs-number">0</span>);glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<span class="hljs-comment">/*着色器*/</span><span class="hljs-comment">//顶点着色器和片段着色器源码</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* vertex_shader_source =<span class="hljs-string">"#version 330 core\n"</span><span class="hljs-string">"layout (location=0) in vec3 aPos;\n"</span><span class="hljs-comment">//位置变量的属性位置值为0</span><span class="hljs-string">"void main()\n"</span><span class="hljs-string">"&#123;\n"</span><span class="hljs-string">"gl_Position=vec4(aPos,1.0);\n"</span><span class="hljs-string">"&#125;\n\0"</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fragment_shader_source =<span class="hljs-string">"#version 330 core\n"</span><span class="hljs-string">"out vec4 FragColor;\n"</span><span class="hljs-comment">//输出的颜色向量</span><span class="hljs-string">"void main()\n"</span><span class="hljs-string">"&#123;\n"</span><span class="hljs-string">"  FragColor=vec4(1.0f,0.5f,0.2f,1.0f);\n"</span><span class="hljs-string">"&#125;\n\0"</span>;<span class="hljs-comment">//生成并编译着色器</span><span class="hljs-comment">//顶点着色器</span><span class="hljs-keyword">int</span> vertex_shader = glCreateShader(GL_VERTEX_SHADER);glShaderSource(vertex_shader, <span class="hljs-number">1</span>, &amp;vertex_shader_source, <span class="hljs-literal">nullptr</span>);glCompileShader(vertex_shader);<span class="hljs-keyword">int</span> success;<span class="hljs-keyword">char</span> info_log[<span class="hljs-number">512</span>];<span class="hljs-comment">//检查着色器是否成功编译，如果编译失败，打印错误信息</span>glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &amp;success);<span class="hljs-keyword">if</span> (!success)&#123;glGetShaderInfoLog(vertex_shader, <span class="hljs-number">512</span>, <span class="hljs-literal">nullptr</span>, info_log);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//片段着色器</span><span class="hljs-keyword">int</span> fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragment_shader, <span class="hljs-number">1</span>, &amp;fragment_shader_source, <span class="hljs-literal">nullptr</span>);glCompileShader(fragment_shader);<span class="hljs-comment">//检查着色器是否成功编译，如果编译失败，打印错误信息</span>glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &amp;success);<span class="hljs-keyword">if</span> (!success)&#123;glGetShaderInfoLog(vertex_shader, <span class="hljs-number">512</span>, <span class="hljs-literal">nullptr</span>, info_log);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//链接顶点和片段着色器至一个着色器程序</span><span class="hljs-keyword">int</span> shader_program = glCreateProgram();glAttachShader(shader_program, vertex_shader);glAttachShader(shader_program, fragment_shader);glLinkProgram(shader_program);<span class="hljs-comment">//检查着色器是否成功链接，如果链接失败，打印错误信息</span>glGetProgramiv(shader_program, GL_LINK_STATUS, &amp;success);<span class="hljs-keyword">if</span> (!success)&#123;glGetProgramInfoLog(shader_program, <span class="hljs-number">512</span>, <span class="hljs-literal">nullptr</span>, info_log);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//删除着色器</span>glDeleteShader(vertex_shader);glDeleteShader(fragment_shader);<span class="hljs-comment">//线框模式-可选（GL-LINE为线框模式，GL_FILL为填充模式（无下面该语句默认该模式）</span><span class="hljs-comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span><span class="hljs-comment">/*渲染*/</span><span class="hljs-keyword">while</span> (!glfwWindowShouldClose((window)))&#123;<span class="hljs-comment">//清空颜色缓冲</span>glClearColor(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.34f</span>, <span class="hljs-number">0.57f</span>, <span class="hljs-number">1.0f</span>);glClear(GL_COLOR_BUFFER_BIT);<span class="hljs-comment">//使用着色器程序</span>glUseProgram(shader_program);<span class="hljs-comment">//绘制四边形</span>glBindVertexArray(vertex_array_object);<span class="hljs-comment">//绑定VAO</span>glDrawElements(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<span class="hljs-comment">//EBO绘制四边形</span>glBindVertexArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//解除绑定VAO</span><span class="hljs-comment">//交换缓冲并且检查是否有触发时间（比如键盘输入，鼠标移动等）</span>glfwSwapBuffers(window);glfwPollEvents();&#125;<span class="hljs-comment">/*释放资源*/</span><span class="hljs-comment">//删除VAO/VBO/EBO</span>glDeleteVertexArrays(<span class="hljs-number">1</span>, &amp;vertex_array_object);glDeleteBuffers(<span class="hljs-number">1</span>, &amp;vertex_buffer_object);glDeleteBuffers(<span class="hljs-number">1</span>, &amp;vertex_buffer_object);<span class="hljs-comment">//清理所有资源并正确退出程序</span>glfwTerminate();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h4 id="VAO-VBO"><a href="#VAO-VBO" class="headerlink" title="VAO+VBO"></a>VAO+VBO</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><span class="hljs-comment">步骤：</span><span class="hljs-comment">1-初始化：GLFW窗口，GLAD</span><span class="hljs-comment">2-数据处理：给定顶点数据，生成并绑定VAO&amp;VBO（准备再GPU中进行处理），设置顶点属性指针（本质上就是告诉OpenGL如何处理数据）。</span><span class="hljs-comment">3-着色器：给出顶点和片段着色器，然后链接为着色器程序，渲染时使用着色器程序。</span><span class="hljs-comment">4-渲染：清空缓冲，绑定纹理，使用着色器程序，绘制三角形，交换缓冲区检查触发时间后释放资源</span><span class="hljs-comment">*/</span><span class="hljs-comment">//使用VAO、VBO的方式形成四边形</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glad/glad.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GLFW/glfw3.h&gt;</span></span><span class="hljs-comment">//using namespace std;</span><span class="hljs-comment">//三角形顶点数据</span><span class="hljs-comment">//const float triangle[] = &#123;</span><span class="hljs-comment">//     //位置</span><span class="hljs-comment">//     -0.5,-0.5,0.0,//左下</span><span class="hljs-comment">//     0.5f,-0.5f,0.0f,//右下</span><span class="hljs-comment">//     0.0f,0.5f,0.0f//正上</span><span class="hljs-comment">//&#125;;</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> triangle[] = &#123;<span class="hljs-comment">//第一个三角形66</span><span class="hljs-number">0.5f</span>,<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//右上</span><span class="hljs-number">0.5f</span>,<span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//右下</span><span class="hljs-number">-0.5f</span>,<span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//左下</span><span class="hljs-comment">//第二个三角形</span><span class="hljs-number">-0.5f</span>,<span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//左下</span><span class="hljs-number">0.5f</span>,<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">//右上</span><span class="hljs-number">-0.5f</span>,<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.0f</span><span class="hljs-comment">//左上</span>&#125;;<span class="hljs-comment">//屏幕宽，高</span><span class="hljs-keyword">int</span> screen_width = <span class="hljs-number">1280</span>;<span class="hljs-keyword">int</span> screen_height = <span class="hljs-number">720</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//初始化GLFW</span>glfwInit();<span class="hljs-comment">//OpenGL版本为3.3，主次版本号均设为3</span>glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);glfwWindowHint(GLFW_OPENGL_ANY_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="hljs-comment">//使用核心模式，无需向后兼容</span>glfwWindowHint(GLFW_RELEASE, <span class="hljs-literal">false</span>);<span class="hljs-comment">//创建窗口（宽、高、窗口名称）</span><span class="hljs-keyword">auto</span> window = glfwCreateWindow(screen_width, screen_height, <span class="hljs-string">"Triangle"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<span class="hljs-keyword">if</span> (window == <span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//如果窗口创建失败</span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to Create OpenGL ConText"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;glfwTerminate();<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;glfwMakeContextCurrent(window);<span class="hljs-comment">//将窗口的上下文设置为当前线程的主上下文</span><span class="hljs-comment">//初始化GLAD,加载OpenGL函数指针地址的函数</span><span class="hljs-keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//指定当前视口尺寸(前两个参数为左下角位置，后两个参数是渲染窗口宽、高)</span>glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, screen_width, screen_height);<span class="hljs-comment">//生成并绑定VAO和VBO</span>GLuint vertex_array_object;<span class="hljs-comment">//VAO</span>glGenVertexArrays(<span class="hljs-number">1</span>, &amp;vertex_array_object);glBindVertexArray(vertex_array_object);GLuint vertex_buffer_object;<span class="hljs-comment">//VBO</span>glGenBuffers(<span class="hljs-number">1</span>, &amp;vertex_buffer_object);glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer_object);<span class="hljs-comment">//将顶点数据绑定至当前默认的缓存中</span>glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(triangle), triangle, GL_STATIC_DRAW);<span class="hljs-comment">//设置顶点属性指针</span>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);glEnableVertexAttribArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//解绑VAO和VBO</span>glBindVertexArray(<span class="hljs-number">0</span>);glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<span class="hljs-comment">//顶点着色器和片段着色器源码</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* vertex_shader_source =<span class="hljs-string">"#version 330 core\n"</span><span class="hljs-string">"layout (location=0) in vec3 aPos;\n"</span><span class="hljs-string">"void main()\n"</span><span class="hljs-string">"&#123;\n"</span><span class="hljs-string">"      gl_Position=vec4(aPos,1.0);\n"</span><span class="hljs-string">"&#125;\n\0"</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fragment_shader_source =<span class="hljs-string">"#version 330 core\n"</span><span class="hljs-string">"out vec4 FragColor;\n"</span><span class="hljs-string">"void main()\n"</span><span class="hljs-string">"&#123;\n"</span><span class="hljs-string">"      FragColor=vec4(0.5f,1.5f,0.2f,1.0f);\n"</span><span class="hljs-comment">//三角形的颜色</span><span class="hljs-string">"&#125;\n\0"</span>;<span class="hljs-comment">//生成并编译着色器</span><span class="hljs-comment">//顶点着色器</span><span class="hljs-keyword">int</span> vertex_shader = glCreateShader(GL_VERTEX_SHADER);glShaderSource(vertex_shader, <span class="hljs-number">1</span>, &amp;vertex_shader_source, <span class="hljs-literal">NULL</span>);glCompileShader(vertex_shader);<span class="hljs-keyword">int</span> success;<span class="hljs-keyword">char</span> info_log[<span class="hljs-number">512</span>];<span class="hljs-comment">//检查着色器是否编译成功，如果编译失败，打印错误信息</span>glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &amp;success);<span class="hljs-keyword">if</span> (!success)&#123;glGetShaderInfoLog(vertex_shader, <span class="hljs-number">512</span>, <span class="hljs-literal">nullptr</span>, info_log);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//片段着色器</span><span class="hljs-keyword">int</span> fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragment_shader, <span class="hljs-number">1</span>, &amp;fragment_shader_source, <span class="hljs-literal">nullptr</span>);glCompileShader(fragment_shader);<span class="hljs-comment">//检查着色器是否成功编译，如果编译失败，打印错误信息</span>glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &amp;success);<span class="hljs-keyword">if</span> (!success)&#123;glGetShaderInfoLog(fragment_shader, <span class="hljs-number">512</span>, <span class="hljs-literal">nullptr</span>, info_log);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//链接顶点和片段着色器至一个着色器程序</span><span class="hljs-keyword">int</span> shader_program = glCreateProgram();glAttachShader(shader_program, vertex_shader);glAttachShader(shader_program, fragment_shader);glLinkProgram(shader_program);<span class="hljs-comment">//检查着色器是否成功链接，如果链接失败，打印错误信息</span>glGetProgramiv(shader_program, GL_LINK_STATUS, &amp;success);<span class="hljs-keyword">if</span> (!success)&#123;glGetProgramInfoLog(shader_program, <span class="hljs-number">512</span>, <span class="hljs-literal">nullptr</span>, info_log);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//删除着色器</span>glDeleteShader(vertex_shader);glDeleteShader(fragment_shader);<span class="hljs-comment">//线框模式</span><span class="hljs-comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span><span class="hljs-comment">//渲染循环4</span><span class="hljs-keyword">while</span> (!glfwWindowShouldClose((window)))&#123;<span class="hljs-comment">//清空颜色缓冲</span>glClearColor(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.34f</span>, <span class="hljs-number">0.57f</span>, <span class="hljs-number">1.0f</span>);<span class="hljs-comment">//背景色</span>glClear(GL_COLOR_BUFFER_BIT);<span class="hljs-comment">//使用着色器程序</span>glUseProgram(shader_program);<span class="hljs-comment">//绘制三角形</span>glBindVertexArray(vertex_array_object);<span class="hljs-comment">//绑定VAO</span>glDrawArrays(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);<span class="hljs-comment">//绑定三角形</span>glBindVertexArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//解除绑定</span><span class="hljs-comment">//交换缓冲并且检查是否有触发事件(比如键盘输入、鼠标移动等)</span>glfwSwapBuffers(window);glfwPollEvents();&#125;<span class="hljs-comment">//删除VAO和VBO</span>glDeleteVertexArrays(<span class="hljs-number">1</span>, &amp;vertex_array_object);glDeleteBuffers(<span class="hljs-number">1</span>, &amp;vertex_buffer_object);<span class="hljs-comment">//清理所有的资源并正确退出程序</span>glfwTerminate();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://learnopengl-cn.github.io/#_1" target="_blank" rel="noopener">LearnOpenGL</a><br><a href="https://www.icourse163.org/learn/HUST-1003636001?tid=1206895203#/learn/announce" target="_blank" rel="noopener">中国大学MOOC《计算机图形学》——华中科技大学</a></p>]]></content>
    
    
    <categories>
      
      <category>【精·术】计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>MOOC-计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】69. x的平方根</title>
    <link href="/%E3%80%90leetcode%E3%80%9169-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9.html"/>
    <url>/%E3%80%90leetcode%E3%80%9169-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目要求的是x的平方根，且只保留整数的部分，小数部分都被舍去<br>以x=8为例，题目是 <strong>求最后1个小于2.828的正整数</strong><br>这属于“寻找有序序列中第一个满足某条件的元素的位置”中的一类题目（所要求的的正整数就是位置），如果想要寻找最后一个满足“条件C”的元素的位置，则可以先求第一个满足“条件!C”的元素的位置，然后将该位置减1即可。<br>因此题目就变为了 <strong>求第一个大于2.828的正整数</strong> ，套用“求序列中第一个大于x的元素的位置”的二分查找模板即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> x;<span class="hljs-comment">//特殊情况</span><span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> right = x;<span class="hljs-keyword">while</span> (left &lt; right)&#123;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-comment">//使用长整数，之后相乘有可能出现溢出</span><span class="hljs-keyword">if</span> (mid*mid&gt;x)<span class="hljs-comment">//说明第一个大于x的位置一定在mid处或mid的左侧</span>&#123;right = mid;<span class="hljs-comment">//往左子区间[left,mid]查找</span>&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//说明第一个大于等于x的元素的位置一定在mid+1处或mid+1的右侧</span>&#123;left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//往右子区间[mid+1,right]查找</span>&#125;&#125;<span class="hljs-keyword">return</span> left<span class="hljs-number">-1</span>;<span class="hljs-comment">//返回夹出来的位置</span>&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】278. 第一个错误的版本</title>
    <link href="/%E3%80%90leetcode%E3%80%91278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC.html"/>
    <url>/%E3%80%90leetcode%E3%80%91278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>二分查找的经典问题：“寻找有序序列中第一个满足某条件的元素的位置”<br>时间复杂度：O(logn)。<br>空间复杂度：O(1)。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// Forward declaration of isBadVersion API.</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBadVersion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> version)</span></span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstBadVersion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">int</span> pLeft = <span class="hljs-number">1</span>, pRight = n;<span class="hljs-keyword">while</span> (pLeft &lt; pRight)&#123;<span class="hljs-keyword">int</span> mid = pLeft + (pRight - pLeft) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (isBadVersion(mid)) &#123;pRight = mid;&#125;<span class="hljs-keyword">else</span>&#123;pLeft = mid + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> pLeft;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【SUM】二分查找</title>
    <link href="/%E3%80%90sum%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html"/>
    <url>/%E3%80%90sum%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近自己在做二分查找类题目，二分查找是非常基础的算法，但其并不简单，有很多细节需要掌握，因此自己结合资料进行了一些整理，在看完这些后，建议做几道给出的习题这样效果会更好。</p><h2 id="二分查找介绍"><a href="#二分查找介绍" class="headerlink" title="二分查找介绍"></a>二分查找介绍</h2><p>二分查找是<strong>基于有序序列</strong>的查找算法。二分查找的高效之处在于，每一步都可以去除当前区间的一半元素，因此其时间复杂度时<code>O(logn)</code>，这是十分优秀的。</p><h3 id="基本的二分查找"><a href="#基本的二分查找" class="headerlink" title="基本的二分查找"></a>基本的二分查找</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p><font color=red> <strong>“查找序列中是否存在某条件的元素”</strong></font></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>首先给出最基本的二分查找问题及解决代码</p><p>eg：查找某元素在数组中的位置，如果找到，则返回下标，未找到，返回-1</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//二分区间为[left,right]，传入的初值为[0,n-1]</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;       <span class="hljs-keyword">int</span> mid;<span class="hljs-comment">//mid为中点</span>       <span class="hljs-keyword">while</span> (left&lt;=right)<span class="hljs-comment">//如果left&gt;right就没办法形成闭区间</span>       &#123;              mid = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-comment">//取中点-采用此种形式防止left+right超出int范围</span>              <span class="hljs-keyword">if</span> (nums[mid] == x) <span class="hljs-keyword">return</span> mid;<span class="hljs-comment">// 找到x，返回下标</span>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid]&gt;x)<span class="hljs-comment">//中间的数大于x</span>              &#123;                     right = mid - <span class="hljs-number">1</span>;<span class="hljs-comment">//往左子区间[left,mid-1]查找</span>              &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//中间的数小于x</span>                     left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//往右子区间[mid+1,right]查找</span>              &#125;       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//查找失败，返回-1</span>&#125;</code></pre></div><h3 id="二分查找的变形"><a href="#二分查找的变形" class="headerlink" title="二分查找的变形"></a>二分查找的变形</h3><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p><font color=red><strong>寻找有序序列中第一个满足某条件的元素的位置</strong></font>。</p><h5 id="举例1：求序列中的第一个大于等于x的元素的位置"><a href="#举例1：求序列中的第一个大于等于x的元素的位置" class="headerlink" title="举例1：求序列中的第一个大于等于x的元素的位置"></a>举例1：求序列中的第一个大于等于x的元素的位置</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//二分区间为[left,right]，传入的初值为[0,n],函数返回第一个大于等于x的元素的位置</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;       <span class="hljs-keyword">int</span> mid;<span class="hljs-comment">//mid为中点</span>       <span class="hljs-keyword">while</span> (left &lt; right)<span class="hljs-comment">//对于[left,right来说]，left==right说明找到了唯一位置</span>       &#123;              mid = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-comment">//取中点</span>              <span class="hljs-keyword">if</span> (nums[mid]&gt;=x)<span class="hljs-comment">//说明第一个大于等于x的元素的位置一定在mid处或mid的左侧</span>              &#123;                     right = mid;<span class="hljs-comment">//往左子区间[left,mid]查找</span>              &#125;              <span class="hljs-keyword">else</span><span class="hljs-comment">//说明第一个大于等于x的元素的位置一定在mid+1处处或mid+1的右侧</span>              &#123;                     left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//往右子区间[mid+1,right]查找</span>              &#125;       &#125;       <span class="hljs-keyword">return</span> left;<span class="hljs-comment">//返回夹出来的位置</span>&#125;</code></pre></div><p>注意点：</p><ul><li>循环条件为<code>left&lt;right</code>而非之前的<code>left&lt;=right</code>，这是由问题本身决定的。在上一个问题中，需要当元素不存在时返回-1，这样当<code>left&gt;right</code>时<code>[left,right]</code>就不再是闭区间，可以此作为元素不存在的判定原则，因此<code>left&lt;=right</code>满足时循环应当一致执行；但是如果想要返回第一个大于等于<code>x</code>的元素的位置，就不需要判断<code>x</code>本身是否存在，因为就算它不存在，返回的也是<b>“假设它存在，它应该在的位置”</b>，于是当<code>left==right</code>时，<code>[left,right]</code>刚好能夹出唯一的位置，就是需要的结果，因此只需要当<code>left&lt;right</code>时让循环一直执行即可。</li><li>由于当<code>left==right</code>时<code>while</code>循环停止，因此最后的返回值既可以是<code>left</code>，也可以是<code>right</code>。</li><li>二分的初始区间应当能覆盖到所有可能返回的结果。首先，二分下界是0是显然的，但是二分上界是<code>n-1</code>还是<code>n</code>呢？考虑到要查询元素有可能比序列中的所有元素都要大，此时应当返回<code>n</code>（即假设它存在，它应该在的位置），因此二分上界是<code>n</code>，故二分的初始区间为<code>[left,right]=[0,n]</code></li></ul><h5 id="举例2：求序列中第一个大于x的元素的位置"><a href="#举例2：求序列中第一个大于x的元素的位置" class="headerlink" title="举例2：求序列中第一个大于x的元素的位置"></a>举例2：求序列中第一个大于x的元素的位置</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//二分区间为[left,right]，传入的初值为[0,n],函数返回第一个大于x的元素的位置</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;       <span class="hljs-keyword">int</span> mid;<span class="hljs-comment">//中点</span>       <span class="hljs-keyword">while</span> (left&lt;right)<span class="hljs-comment">//对于[left,right来说]，left==right说明找到了唯一位置</span>       &#123;              mid = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-comment">//取中点</span>              <span class="hljs-keyword">if</span> (nums[mid]&gt;x)<span class="hljs-comment">//说明第一个大于x的元素的位置一定在mid处或mid的左侧</span>              &#123;                     right = mid;<span class="hljs-comment">//往左子区间[left,mid]查找</span>              &#125;              <span class="hljs-keyword">else</span><span class="hljs-comment">//说明第一个大于等于x的元素的位置一定在mid+1处或mid+1的右侧</span>              &#123;                     left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//往右子区间[mid+1,right]查找</span>              &#125;       &#125;       <span class="hljs-keyword">return</span> left;<span class="hljs-comment">//返回夹出来的位置</span>&#125;</code></pre></div><p>通过思考会发现，<code>lower_bound</code>函数和<code>upper_bound</code>函数都在解决这样一个问题：<font color=red><strong>寻找有序序列中第一个满足某条件的元素的位置</strong></font>。这是一个非常重要的且经典的问题，<strong>平时能碰到的大部分二分法问题都可以归结于这个问题</strong>。<br>例如对<code>lower_bound</code>函数来说，它寻找的就是第一个满足条件值“大于等于<code>x</code>”的元素的位置；<br>而对<code>upper_bound</code>函数来说，它寻找的是第一个满足条件“值大于<code>x</code>”的元素的位置。<br>显然，<font color=red>所谓的<strong>“某条件”在序列中一定是从左到右先不满足，然后满足的（否则把该条件取反即可）</strong><font>。</p><h4 id="变形问题的代码模板"><a href="#变形问题的代码模板" class="headerlink" title="变形问题的代码模板"></a>变形问题的代码模板</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//解决“寻找有序序列中第一个满足某条件的元素的位置”问题的固定模板</span><span class="hljs-comment">//二分区间为[left,right]，传入的初值为[0,n],函数返回第一个大于x的元素的位置</span><span class="hljs-function"><span class="hljs-keyword">int</span>   <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;       <span class="hljs-keyword">int</span> mid;<span class="hljs-comment">//中点</span>       <span class="hljs-keyword">while</span> (left &lt; right)<span class="hljs-comment">//对于[left,right来说]，left==right说明找到了唯一位置</span>       &#123;              mid = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-comment">//取中点</span>              <span class="hljs-keyword">if</span> (条件成立)<span class="hljs-comment">//位置一定在mid处或mid的左侧</span>              &#123;                     right = mid;<span class="hljs-comment">//往左子区间[left,mid]查找</span>              &#125;              <span class="hljs-keyword">else</span><span class="hljs-comment">//条件不成立，位置一定在mid+1处或mid+1的右侧</span>              &#123;                     left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//往右子区间[mid+1,right]查找</span>              &#125;       &#125;       <span class="hljs-keyword">return</span> left;<span class="hljs-comment">//返回夹出来的位置</span>&#125;</code></pre></div><p>另外，<font color=red><strong>如果想要寻找最后一个满足“条件C”的元素的位置，则可以先求第一个满足“条件!C”的元素的位置，然后将该位置减1即可</strong></font>（在最长回文子串的二分解法用到了这一点）。</p><p>最后，如何判断lower_bound函数和upper_bound函数的查询是否成功，只需对上界进行处理即可。例如下面的处理代码：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (left == nums.length) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">// 数组中未找到</span><span class="hljs-keyword">return</span> nums[left] == target ? left : <span class="hljs-number">-1</span>;<span class="hljs-comment">//如果该位置元素值和目标值相等，则找到，否则，未找到</span></code></pre></div><h3 id="LeetCode练习题"><a href="#LeetCode练习题" class="headerlink" title="LeetCode练习题"></a>LeetCode练习题</h3><p><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">278. 第一个错误的版本</a></p><ul><li>“寻找有序序列中第一个满足某条件的元素的位置”的方法的应用</li></ul><p><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a></p><ul><li>“如果想要寻找最后一个满足“条件C”的元素的位置，则可以先求第一个满足“条件!C”的元素的位置，然后将该位置减1即可”该方法的应用</li><li>思路可以参考<a href="https://blog.csdn.net/weixin_41234001/article/details/104666868" target="_blank" rel="noopener">我的blog</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
      <tag>SUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】167. 两数之和 II - 输入有序数组</title>
    <link href="/%E3%80%90leetcode%E3%80%91167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-ii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.html"/>
    <url>/%E3%80%90leetcode%E3%80%91167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-ii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.html</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>自己开始的思路是，对另一个数，在已有的数组中进行二分查找，而不是简单的遍历，自己觉得复杂度挺小的O(nlogn)，但是一直超时，同时自己的代码考虑了一种情况[2,7,7,10,11]，target=9，如果是官方题解应该是返回值时{1,3}；而我觉得正确的情况是[1,2]（我写的代码可以获得该结果），因此从官方题解可以看出没有这种情况出现。代码见后<br><img src="https://img-blog.csdnimg.cn/20200304191328292.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>之后参考自<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-by-leetco/" target="_blank" rel="noopener">LeetCode官方提解</a><br>使用两个指针，初始分别位于第一个元素和最后一个元素位置，比较这两个元素之和与目标值的大小。<br>如果和等于目标值，我们发现了这个唯一解。<br>如果比目标值小，我们将较小元素指针增加一。<br>如果比目标值大，将较大指针减小一。移动指针后重复上述比较直到找到答案。<br>时间复杂度O(n)，空间复杂度O(1)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//双指针</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>, high = numbers.size() - <span class="hljs-number">1</span>;<span class="hljs-comment">//low低指针，high高指针</span><span class="hljs-keyword">while</span> (low &lt; high)&#123;<span class="hljs-keyword">int</span> sum = numbers[low] + numbers[high];<span class="hljs-keyword">if</span> (sum == target) <span class="hljs-keyword">return</span> &#123; low + <span class="hljs-number">1</span>,high + <span class="hljs-number">1</span> &#125;;<span class="hljs-comment">//学到了</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target)&#123;low++;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target)&#123;high--;&#125;&#125;<span class="hljs-keyword">return</span> &#123; <span class="hljs-number">-1</span>,<span class="hljs-number">-1</span> &#125;;<span class="hljs-comment">//学到了</span>&#125;&#125;;</code></pre></div><h4 id="自己的想法"><a href="#自己的想法" class="headerlink" title="自己的想法"></a>自己的想法</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//下列算法，超时无法通过题目</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numbers.size();i++)&#123;res.push_back(i+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> index = binarySearch(i+<span class="hljs-number">1</span>, numbers, target - numbers[i]);<span class="hljs-keyword">if</span> (index != <span class="hljs-number">-1</span>)&#123;res.push_back(index+<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> res;&#125;res.pop_back();&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">//寻找左侧边界的二分搜索</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; numbers,<span class="hljs-keyword">int</span> target)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> left = i;<span class="hljs-keyword">int</span> right = numbers.size();<span class="hljs-keyword">while</span> (left&lt;right) &#123;<span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (numbers[mid] == target) right=mid;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] &lt; target) &#123;left = mid + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid]&gt;target)&#123;right = mid;&#125;&#125;<span class="hljs-keyword">if</span> (left == numbers.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-keyword">return</span> numbers[left]==target?left:<span class="hljs-number">-1</span>;&#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>【魂】数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
